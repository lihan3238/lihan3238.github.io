[{"content":"hugo网站搭建 1.前置条件 go git hugo hugo下载 1.1 hugo下载安装 1 2 go env -w CGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest 如果出现gcc报错，需要根据如下流程安装gcc\n打开链接下载 选择版本下载（win11为例） 解压到目录 C:\\Program Files (x86)\\mingw64 设置环境变量 1.2 hugo使用 参考文档 中文文档\n1.3 github部署hugo模板 在github创建仓库 Repository name那一栏，格式为\u0026lt;name\u0026gt;.github.io。如果你想让你的博客网址就是.github.io，则\u0026lt;name\u0026gt;不能是任意名字，必须是你的github用户名。 gitclone仓库到本地 下载主题模板到本地文件夹内并git push 进入https://github.com/\u0026lt;name\u0026gt;/\u0026lt;name\u0026gt;.github.io点击上方栏的Settings，然后点击左方栏的Pages，在Build and deployment里的Source中选择Github Actions，在下面找到Hugo，点击Configure，在新界面点击右侧的绿色按钮的Commit changes...。 找不到Hugo就去browse all workflows里找。 后续写博客 后续更新只需要在content文件夹加入md文件，然后执行 1.4 links 在某一博的frontmatter中加入如下内容即可\n1 2 3 4 5 6 7 8 9 links: - title: GitHub description: GitHub is the world\u0026#39;s largest software development platform. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png - title: TypeScript description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. website: https://www.typescriptlang.org image: ts-logo-128.jpg image 允许在线图片和本地图片，如果是本地图片，需要放在 static 文件夹下，然后使用相对路径引用。\n1.5 基于gitalk的评论区 使用 GitHub 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter） Readme 在线示例\n安装 两种方式\n直接引入 1 2 3 4 5 6 7 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- or --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/gitalk/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/gitalk/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; npm 安装 1 npm i --save gitalk 1 2 import \u0026#39;gitalk/dist/gitalk.css\u0026#39; import Gitalk from \u0026#39;gitalk\u0026#39; 使用 首先，您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论，\n然后需要创建 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。\n最后, 您可以选择如下的其中一种方式应用到页面：\n在hugo的网站文件夹下的config/params.toml下填写 1 2 3 4 5 6 7 8 9 10 11 12 [comments.gitalk] clientID = \u0026#34;id\u0026#34; clientSecret = \u0026#34;cs\u0026#34; repo = \u0026#34;lihan3238.github.io\u0026#34;,//博客网站仓库名字 owner = \u0026#34;lihan3238\u0026#34;,//github用户名 admin = [\u0026#34;lihan3238\u0026#34;],//github用户名（仓库有权写写入的人） perpage = 10//每页多少个评论 pagerDirection = \u0026#34;last\u0026#34;//排序方式\u0026#34;last/first\u0026#34; createIssueManually = true//管理员是否手动创建issue distractionFreeMode = false//是否开启无干扰模式（cmd|ctrl+enter）自动发送评论 labels = \u0026#34;gitalk\u0026#34;//issue标签 id = \u0026#34;lihan3238.github.io\u0026#34;//页面唯一id 问题 评论区报错 1 2 3 未找到相关的 Issues 进行评论 请联系 @[lihan3238] 初始化创建 解决方法： 管理员账户登录评论区即可 ","date":"2023-09-05T00:00:00+08:00","image":"/lihan3238.github.io/p/hugowebtest/swwlz_hu4fc87ac40ce0485d329b584162ffd86e_505599_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/hugowebtest/","title":"hugo网站搭建"},{"content":"代码介绍: 代码使用pipenv进行包管理 代码分为三部分:\ndubbingVideo 用于从解说素材中生成音频 使用了edge-tts包 resize_images 用于将图片素材格式调整至一致 使用了PIL包 cideoCreate 用于将图片素材和音频合成为视频 使用了moviepy包 代码使用方法 将图片素材放在1-图像素材文件夹下，解说素材放在2-解说素材文件夹下，配乐素材放在3-配乐素材文件夹下，打开命令行进入主目录下，进行输入操作:\n确定python版本为 3.10 pip install pipenv pipenv shell pipenv install python ./基于MoviePy的影视解说视频合成.py ","date":"2023-12-20T18:27:00+08:00","image":"/lihan3238.github.io/p/moviepy/moviepy_hu4aa774fa7f69433c26b270ae4ca021ba_23219_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/moviepy/","title":"基于MoviePy和edge-tts的python生成解说音频并合成视频"},{"content":"环境 windows11上的ubuntu22.04的wsl2 ubuntu22.04 hadoop-3.1.2 hbase-1.2.11 jdk-8u201-linux-x64 配置环境 hadooptest 192.168.50.156 成品镜像 /lihan3238/hadoop_hbase-ubuntu:lihanhadoop docker pull lihan3238/hadoop_hbase-ubuntu:lihanhadoop\n使用 1 2 3 4 5 6 7 8 9 # 创建容器 sudo docker run -di --name hadooptest -v /media/sf_share_001/:/home/shareFiles lihan3238/hadoop_hbase-ubuntu:lihanhadoop # 进入容器 docker exec -it hadooptest /bin/bash # 启动hadoop时要注意切换到hadoop用户和启动ssh服务 su hadoop sudo service ssh start docker容器配置 windows11上的ubuntu22.04的wsl2\ndocker0网桥:\n1 2 3 mysqlBridge: Subnet:192.168.50.0/24 Gateway:192.168.50.1 安装依赖文件 hadooptest 192.168.50.156 创建容器 1 2 # 创建容器 sudo docker run -di --name hadooptest -v /media/sf_share_001/:/home/shareFiles ubuntu22.04:1.0 进入容器 1 2 3 4 5 6 7 8 # 进入容器 docker exec -it hadooptest /bin/bash # 安装基础工具 apt update apt upgrade apt install vim sudo dialog net-tools iputils-ping 创建用户 1 2 3 4 5 6 7 8 # 创建用户 sudo useradd -m hadoop -s /bin/bash #创建hadoop用户，并使用/bin/bash作为shell sudo passwd hadoop #为hadoop用户设置密码，之后需要连续输入两次密码 # 密码 lihan sudo adduser hadoop sudo #为hadoop用户增加管理员权限 su - hadoop #切换当前用户为用户hadoop sudo apt-get update #更新hadoop用户的apt,方便后面的安装 配置SSH免密登录 1 2 3 4 5 6 7 8 9 10 sudo apt-get install openssh-server #安装SSH server ssh localhost #登陆SSH，第一次登陆输入yes exit #退出登录的ssh localhost cd ~/.ssh/ #如果没法进入该目录，执行一次ssh localhost ssh-keygen -t rsa　输入完 $ ssh-keygen -t rsa　语句以后，需要连续敲击三次回车 cat ./id_rsa.pub \u0026gt;\u0026gt; ./authorized_keys #加入授权 ssh localhost #此时已不需密码即可登录localhost，如果失败则可以搜索SSH免密码登录来寻求答案 报错1: 执行ssh localhost时报错ssh: connect to host localhost port 22: Cannot assign requested address\n解决1: ssh-server未运行，执行sudo /etc/init.d/ssh start启动ssh-server\n安装配置jdk1.8 jdk-8u201-linux-x64.tar.gz为例 1 2 3 4 5 6 mkdir /usr/lib/jvm sudo tar zxvf /home/shareFiles/jdk-8u201-linux-x64.tar.gz -C /usr/lib/jvm cd /usr/lib/jvm mv jdk1.8.0_201 java vim ~/.bashrc # 给环境变量添加jdk 1 2 3 4 5 # .bashrc文件添加如下内容 export JAVA_HOME=/usr/lib/jvm/java export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export PATH=${JAVA_HOME}/bin:$PATH 注意不同用户的环境变量不同，需要在不同用户下添加环境变量 1 2 3 source ~/.bashrc # 使环境变量生效 java -version # 查看jdk版本 安装配置hadoop hadoop-3.1.2.tar.gz为例 1 2 3 4 5 6 sudo tar -zxvf /home/shareFiles/hadoop-3.1.2.tar.gz -C /usr/local #解压到/usr/local目录下 cd /usr/local sudo mv hadoop-3.1.2 hadoop #重命名为hadoop sudo chown -R hadoop ./hadoop #修改文件权限，根据实际情况确定用户名 vim ~/.bashrc # 给环境变量添加jdk 注意不同用户的环境变量不同，需要在不同用户下添加环境变量 1 2 3 4 # .bashrc文件添加如下内容 export HADOOP_HOME=/usr/local/hadoop export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 1 2 3 source ~/.bashrc # 使环境变量生效 hadoop version # 查看hadoop版本 配置hadoop 伪分布式配置 Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。Hadoop 的配置文件位于/usr/local/hadoop/etc/hadoop/中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。\n1 2 3 4 5 6 7 8 #首先将jdk1.8的路径添（`export JAVA_HOME=/usr/lib/jvm/java` ）加到hadoop-env.sh文件 sudo vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh # 在文件中添加如下内容 export JAVA_HOME=/usr/lib/jvm/java # 修改core-site.xml文件 sudo vim /usr/local/hadoop/etc/hadoop/core-site.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 #在文件中添加如下内容 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/usr/local/hadoop/tmp\u0026lt;/value\u0026gt; \u0026lt;description\u0026gt;A base for other temporary directories.\u0026lt;/description\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://localhost:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 1 2 # 修改hdfs-site.xml文件 sudo vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/usr/local/hadoop/tmp/dfs/name\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/usr/local/hadoop/tmp/dfs/data\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（可参考官方教程），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。 NameNode 格式化 1 2 3 4 #注意切换到hadoop用户下执行命令 #/usr/local/hadoop/bin/hdfs namenode –format hdfs namenode -format 问题1： hdfs namenode -format报错\n解决1： 手动输入，可能有奇怪的空格\n1 2 3 4 5 6 7 #启动namenode和datanode进程，并查看启动结果 su hadoop sudo service ssh start #/usr/local/hadoop/sbin/start-dfs.sh start-dfs.sh # 启动完成后，通过命令 jps 来判断是否成功启动 jps 问题1： /usr/local/hadoop/sbin/start-dfs.sh报错\n解决1：\n注意切换到hadoop用户下执行命令 注意检查ssh是否在运行sudo service ssh status 问题2： 1d55461ab30f: ERROR: Unable to write in /usr/local/hadoop/logs. Aborting.报错\n解决2：\nsudo chown -R hadoop /usr/local/hadoop/logs修改文件权限 问题3： WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable报错\n解决3：\n解决方案是在文件hadoop-env.sh中增加： export HADOOP_OPTS=\u0026quot;-Djava.library.path=${HADOOP_HOME}/lib/native\u0026quot;\n启动Hadoop例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #创建执行MapReduce作业所需的 DFS 目录: hdfs dfs -mkdir /user hdfs dfs -mkdir /user/\u0026lt;username\u0026gt; #\u0026lt;username\u0026gt; 问用户名，如hadoop #拷贝输入文件到分布式文件系统: hdfs dfs -put /usr/local/hadoop/etc/hadoop input #可以运行一些例子: hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.2.jar grep input output \u0026#39;dfs[a-z.]+\u0026#39; #查看输出的文件(files): 从分布式文件系统中拷贝文件到本地文件系统并查看: hdfs dfs -get output /usr/local/hadoop/output cat /usr/local/hadoop/output/* #或者直接在分布式文件系统上查看: hdfs dfs -cat output/* YARN 单机配置 通过设置几个参数并运行ResourceManager daemon and NodeManager daemon，你可以在YARN上以伪分布模式运行MapReduce job。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vim /usr/local/hadoop/etc/hadoop/mapred-site.xml #修改mapred-site.xml文件 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; vim /usr/local/hadoop/etc/hadoop/yarn-site.xml #修改yarn-site.xml文件 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; # 启动ResourceManager daemon 和 NodeManager daemon: start-yarn.sh ResourceManager - http://localhost:8088/ #可以通过下列命令停止hadoop和YARN stop-dfs.sh stop-yarn.sh 配置hbase 安装配置hbase hbase-1.2.11-bin.tar.gz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 解压 sudo tar -zxvf /home/shareFiles/hbase-1.2.11-bin.tar.gz -C /usr/local sudo mv /usr/local/hbase-1.2.11 /usr/local/hbase cd /usr/local sudo chown -R hadoop /usr/local/hbase # 配置环境变量 vim ~/.bashrc # .bashrc文件添加如下内容 export PATH=$PATH:/usr/local/hbase/bin source ~/.bashrc # 使环境变量生效 # 查看版本 hbase version 配置hbase 单机配置（可能需要配置JAVA_HOME环境变量， 由于本实验指南在HADOOP安装时已配置，故省略） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 修改hbase-site.sh文件 sudo vim /usr/local/hbase/conf/hbase-site.xml # 在文件中添加如下内容 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hbase.rootdir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:///usr/local/hbase/hbase-tmp\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; #采用如下命令启动服务、查看进程和启动客户端 cd /usr/local/hbase #/usr/local/hbase/bin/start-hbase.sh start-hbase.sh jps #/usr/local/hbase/bin/hbase shell hbase shell 下面为配置伪分布模式的指南 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 修改hbase-env.sh文件 #在conf/hbase-env.sh文件里设置 JAVA_HOME 环境变量. 首先确定java安装位置，本实验为：usr/lib/jvm/java，然后编辑 conf/hbase-env.sh 文件, sudo vim /usr/local/hbase/conf/hbase-env.sh #加入： export JAVA_HOME=/usr/lib/jvm/java # 修改hbase-site.xml文件 sudo vim /usr/local/hbase/conf/hbase-site.xml # 添加 \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hbase.cluster.distributed\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; # 启动 start-dfs.sh cd /usr/local/hbase/bin start-hbase.sh jps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 3. 操作hbase ```bash # Start a backup HBase Master (HMaster) server.（仅仅为了测试和学习，生产环境不会在一台机器上启动备份master） # HMaster服务器控制 HBase集群. 你可以启动最多9个后备HMaster。 # 用 localmaster-backup.sh启动. 为每个后背HMaster加一个16000端口之上的偏移量。 启动后可以查看结果。 local-master-backup.sh start 2 3 5 jps # 启动和停止附加区域服务器RegionServers local-regionservers.sh start 2 3 4 5 #进入交互界面 hbase shell # 进行一些基本数据库操作 ## 创建表(使用create命令创建一个新表.你必须规定表名和列族名) create \u0026#39;test\u0026#39;, \u0026#39;cf\u0026#39; ## 查看表 ### list 命令可以显示表信息 list \u0026#39;test\u0026#39; ### describe 命令显示表的详细信息 describe \u0026#39;test\u0026#39; ## 插入数据 ### put put \u0026#39;test\u0026#39;, \u0026#39;row1\u0026#39;, \u0026#39;cf:a\u0026#39;, \u0026#39;value1\u0026#39; put \u0026#39;test\u0026#39;, \u0026#39;row2\u0026#39;, \u0026#39;cf:b\u0026#39;, \u0026#39;value2\u0026#39; put \u0026#39;test\u0026#39;, \u0026#39;row3\u0026#39;, \u0026#39;cf:c\u0026#39;, \u0026#39;value3\u0026#39; ## 扫描表 使用scan 命令扫描整个表取得数据 scan \u0026#39;test\u0026#39; ## 取一行数据，使用get指令 get \u0026#39;test\u0026#39;, \u0026#39;row1\u0026#39; ## 修改表模式，使用alter命令，如修改存储版本数 disable \u0026#39;test\u0026#39; alter \u0026#39;test\u0026#39;, NAME =\u0026gt; \u0026#39;cf\u0026#39;, VERSIONS =\u0026gt; 5 enable \u0026#39;test\u0026#39; ## 删除表，使用drop命令 disable \u0026#39;test\u0026#39; drop \u0026#39;test\u0026#39; 思考题： 1 请问伪分布和分布式的含义有何不同？就本实验，你是如何理解在一台计算机上做到“伪分布”的？ 伪分布通常指的是在单台计算机上模拟分布式环境，即将分布式系统的各个组件部署在同一台机器上，以方便开发和调试。而分布式系统是在多台计算机上部署的系统，各个计算机之间通过网络进行通信和协作。\n在一台计算机上实现“伪分布”通常是为了方便在单机上测试和调试分布式系统的各个组件，以便更好地理解和解决分布式系统的问题。\n2 在1.2小节进行安装SSH并设置SSH无密码登陆，请问这个安装的目的是什么？ 在1.2小节进行安装SSH并设置SSH无密码登录的目的是为了实现集群中各个节点之间的安全通信。SSH（Secure Shell）是一种加密的网络协议，通过在集群节点之间建立SSH无密码登录，可以实现在节点之间的安全通信，方便集群管理和操作\n3 如果继续向Hbase的test表中put行键为”row1”，值为其它字符串的数据，put ‘test’ ,’row1’, ‘cf:a’, ‘value6’，会发生什么？如果采用语句get ‘test’, ‘row1’, {COLUMN=\u0026gt;’cf:a’, VERSIONS=\u0026gt;3} 进行查询，分析你得到的结果。put与关系数据库的插入有何不同？ 这将在test表的row1行的cf:a列插入新的值\u0026rsquo;value6\u0026rsquo;。如果之前已经存在相同行键和列族的数据，它会被覆盖。\n对于查询语句：\njavascript\nget \u0026rsquo;test\u0026rsquo;, \u0026lsquo;row1\u0026rsquo;, {COLUMN=\u0026gt;\u0026lsquo;cf:a\u0026rsquo;, VERSIONS=\u0026gt;3}\n这将获取test表中row1行cf:a列的最近3个版本的数据。如果之前的put操作执行成功，你可能会得到包含\u0026rsquo;value6\u0026rsquo;的结果。\n相较于关系数据库的插入，HBase是一种NoSQL数据库，支持灵活的列族和列的存储，而不需要提前定义表的结构。插入数据时，可以方便地插入不同列族的数据，而不受严格的表结构限制。\n","date":"2023-12-19T10:30:00+08:00","image":"/lihan3238.github.io/p/hadoop/Hadoop_hue0e83bff08c116e1ffda76326880738b_55233_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/hadoop/","title":"搭建Hadoop环境"},{"content":"17号 和zhj wy yrf zmz去猫咖，第一次去猫咖，体验不错，猫猫很可爱，wy去杭州实习了，考六级这次回来，晚上就去杭州了，一起吃了他们心心念念的千层面哈哈.\n忘了合照，可惜了。\n18号 不知道会怎么安排，下午还是有课的，早睡吧，早起多玩玩(by 17号的lihan) 翘了一下午的课，和zhj cwt lys zyx 去玩桌游，晚上吃了葫芦鸡陕菜。 生日过去了，还有9分钟。\n情感 发现自己甚至不能看斗罗大陆了，看几页就想起当年高中的时光，心脏真受不了。。。\n每次玩土豆兄弟时候，满脑子是自己干过的蠢事，和这个是不是有点像。\n","date":"2023-12-18T23:52:53+08:00","image":"/lihan3238.github.io/p/dream231218/avatar_huab4f7afdfad270ee93cc6c9958151aca_2665_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dream231218/","title":"过生日"},{"content":"下雪了 确实没想到有这么多南方的同学没有见过雪，朋友圈全是初雪好家伙。\n废物 还是一如既往废物，o都没学，还是一如既往的废物。\n怀旧 仙剑奇侠传三，真的好看，童年的经典：仙剑三、喜羊羊、果宝特攻、猪猪侠、铠甲勇士、洛洛历险记\u0026hellip;\u0026hellip;这些符号聚成了我这一代人的回忆，好家伙这不就可以大数据分析了确定年龄了。\n","date":"2023-12-12T20:12:53+08:00","image":"/lihan3238.github.io/p/dream231212/avatar_huab4f7afdfad270ee93cc6c9958151aca_2665_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dream231212/","title":"下雪了"},{"content":"后悔 看的太尴尬了，加上opcwt天天在我耳边说。。。\n废物 还是一如既往废物，周末就做了个PPT，编译原理 高级数据库，六级，蓝桥杯，o都没学，还是一如既往的废物。\n","date":"2023-12-10T20:58:53+08:00","image":"/lihan3238.github.io/p/dream231210/avatar_huab4f7afdfad270ee93cc6c9958151aca_2665_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dream231210/","title":"好的我现在就后悔了"},{"content":"密码学与信息安全 密码学(Cryptology)是什么 研究如何对己方信息及信息传递进行保护，如何对敌方信息进行破译的科学\n密码编码学(Cryptography)：研究如何对信息进行加密\n密码分析学(Cryptanalysis)：研究如何对加密信息进行解密\n密码学与信息安全 密码学是对于信息安全各方面(机密性、完整性、认证性和不可否认性)有关的数学技术的研究\n密码学是保障信息安全的核心，但密码学不是提供信息安全的唯一方式，是保护信息安全的主要手段之一\n信息安全是密码学研究与发展的目的\n密码学的发展 古典密码：密码学是一门艺术 1949年之前 密码体制：纸、笔或简单器械实现的 代换 及 置换\n典型密码：凯撒密码、单表密码、多表密码、维吉尼亚密码、Hill密码、Playfair密码、Enigma密码机等\n特点：加密速度慢，适合对少量数据进行加密\n传统密码(对称密码)：密码学是一门科学 1949年-1976年 1949年Shannon发表了《保密系统的信息理论》，提出信息论，密码学开始科学化。\n密码体制：对称密码体制\n典型密码：DES、AES、IDEA、RC4、RC5、RC6等\n特点：密钥长度短，加密速度快，适合对大量数据进行加密，密钥管理困难\n现代密码(公钥密码)：密码学是一门数学工程 1976年后 1976年，Diffie和Hellman发表《密码学的新方向》，标志着公钥密码体制的诞生（第二次质的飞跃）。 1978年，Rivest、Shamir和Adleman提出了RSA公钥密码体制。\n现代密码学基本原则 柯克霍夫原则：除了密钥之外，即使密码系统的一切均被公开，它仍然应当是安全的。 香农箴言：敌人了解系统 密码体制的安全性应该依赖于密钥而不是算法的保密\n密码体制：公钥密码体制\n典型密码：RSA、ElGamal、ECC、DSA、DH、MD5、SHA-1、SHA-2、SHA-3等\n特点：密钥长度长，加密速度慢，密钥管理方便\n密码体制的安全性 无条件安全：即使敌手拥有无限的计算能力，也不能破译密文或者推断出明文 实际安全： 可证明安全：破译密码的难度与数学上的某个难题的难度相同 计算安全：破译密码的代价大于破译所得的价值或者破译所需的时间大于信息的有效期 个人密码设计的三个前提 你的账号、密码大概率会忘记； 你的账号密码大概率即将(或已经)被泄露； 关于账号密码的记录大概率即将(或已经)丢失； 个人密码设计的三个要求 安全性 便利性 可重复现性 安全性 密码长度：当前一般的账号密码设置场景下，都会要求密码长度不低于8位；显然，密码长度越长，相对越安全，只不过这里要考虑密码长度过大带来的不便利性问题； 组成丰富：主流场景下，会要求字母大小写，数字，符号等多种组成； 避免弱密码：一般要求避免123456这类弱口令，类似个人手机号，身份证号，姓名拼音等个人基本信息也需要尽量避免； 差异性：要避免不同账号命名的雷同，更要避免不同密码之间的雷同，否则泄露了一个账号密码，就是\u0026quot;全军覆没\u0026quot;的下场了 ； 可迭代性：单一密码使用时间越长相对越不安全，加上突发意外的密码泄露事件，密码的可更新的特点，具有充分的必要性； 便利性 可标识性：即通过密码的部分要素可以快速对应出密码的类别，等级等信息以及该密码对应的账号的部分信息； 有规律性：对于大量要管理的密码而言，要想保证不同密码之间的差异性，显然需要有规律的来开发和管理方法，才能达到目的； 可重复现性 云同步：密码的管理可采用本地纸质化、电子化管理和线性的云同步来协同管理，可有效避免密码的丢失； 丢失找回：想要在密码丢失后还能找回，实际上也是回到了\u0026quot;密码的规律性\u0026quot;问题，即密码的设置有一套可重现性的规律，通过账号信息，即可”计算“出对应的密码； 个人密码管理 基于以上的前提和要求，在设计个人密码时，我们需要思考的是，如何实现密码的分级管理、差异化要求和规律性要求，并且要在“安全性”与“便利性”之间寻求一个平衡点。\n列举三种常见的密码管理方案：\n大脑记忆 最常见的密码管理方式\n安全性：一般比较高，但是如果为了记忆方便，密码组成简单，或多账号密码雷同，安全性会大打折扣 便利性：一般比较高，但是如果密码过多，记忆负担会比较大 可重复现性：密码越安全(复杂),越容易忘记，可重复现性越差 记事本记录 无论记录在纸上还是电脑记事本里，这种方式也很常见。\n安全性：较低，即使加密或上锁，也很难保证安全 便利性：一般比较高，但是如果密码过多，查找起来确实不方便 可重复现性：风险在于记录的丢失，需要注意备份 密码管理工具(Keepass) 常见的密码管理工具有：Keepass，1Password，LastPass，Dashlane等，这里以Keepass为例。 KeePass 是一款开源的密码管理工具，使用一个加密的数据库保存所有的密码，不仅可以加密保存账号密码，利用自带功能及插件，还可以方便的生成强密码、便捷安全地输入密码等。但外观较为粗糙。\n安全性：高，数据库主密码只要不泄露，即使数据库文件泄露，也不会造成密码泄露 便利性：高，利用插件可以方便地多端同步及自动填充密码 可重复现性：风险在于记录的丢失，需要注意备份 ","date":"2023-12-08T23:33:00+08:00","image":"/lihan3238.github.io/p/cryptologyppt/keepass_hu9fb86fb8c7cc6fd949bc41fdad1e1d43_130840_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/cryptologyppt/","title":"密码与信息安全"},{"content":"决定 管他呢，情绪总需要一个宣泄口，不想发说说朋友圈，就在这里吧。 一年后的我看这些会觉得尴尬，那跟现在的我什么关系呢，管他呢！\n废物 每天早上没课就睡到11.，然后刷手机到1.，一边刷一边忏悔要早睡早起，不能刷了，被sb短视频和帖子吸引，一边思考今天要开始好好学习了。 然后洗漱吃中餐，回来就打开电脑打游戏看视频电影。激烈的思想斗争后装模做样学几分钟，然后奖励自己玩到晚饭，我靠这么快，刚吃完午餐! 吃完回来再玩，我靠10.了，学几分钟，奖励自己或者履行早睡，躺在床上看手机到2.，然后傻逼睡了。 早上有课，7.20醒来关掉闹铃，然后睡到7.40，可能直接决定翘课，或者强行爬起来，上课带着电脑，说学习，还是刷手机，到晚上回宿舍又是同样的虚度时间。 洗澡时候想着未来的规划，明天要好好学习，然后睡觉，然后明天又是同样的一天。\n我透，最傻逼的是你这个傻逼哪怕稍微努力一点点，或者做出一丝丝成果，就能得到极大的满足感，同时又很容易在美食、游戏等上面腻。\n纯废物，就这还想着永生、马克思、区块链、考研！废物！傻逼！dinner！弱智！下水道里的老鼠至少会打洞！臭水沟里的蛆还能变成苍蝇飞！你这个废物真的找不到更废物的了！\n想法1 想过的文艺点，听听音乐，好好学习，好好生活，开始也许打扮下自己吧！\n想法2 shit！我心脏是受不了了，自四年前开始，我再也不能享受伤感的快感了，唉\u0026hellip;\n","date":"2023-12-08T22:54:53+08:00","image":"/lihan3238.github.io/p/dream231208/avatar_huab4f7afdfad270ee93cc6c9958151aca_2665_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dream231208/","title":"管他呢这里就是爷的空间了"},{"content":"问题 如上图，使用畅课(TronClass)平台时，老师可能有意无意未开放课件等资料的下载权限，导致无法下载。\n解决方案 使用浏览器的开发者工具，查看网页源代码，找到课件下载。\n在待下载的资料页面打开浏览器的开发者工具，一般快捷键是f12，选择网络页面，如下图所示： 点开资料，图例中为pdf课件，在网络的筛选条件中输入pdf，找到对应的网络资源，如下图所示： 右键后点击新建标签页打开，即可下载。 如图，下载成功。 ","date":"2023-11-27T16:20:00+08:00","image":"/lihan3238.github.io/p/point_6/tronclass_hu85133593f559546f760ca2ca7f175da2_21937_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_6/","title":"畅课平台课件资料无权限下载"},{"content":"前言 考虑到考研难度比高考多，加上还想学点别的，女娲补天计划2.0需要比高考的女娲补天计划提前开始(更别说这次是真从零开始)。\n注意事项 考研是主线任务和核心 目标 学习考研笔试内容 学习考研加分内容 学习计算机技术 学习英语 进行流汗黄豆计划 目标内容 学习考研笔试内容 目标任务 数学\n高数 线代 专业课\n数据结构 计算机组成原理 操作系统 计算机网络 政治\n英语\n目标时间\n目标进度\n学习考研加分内容 目标任务 深度学习 目标时间\n目标进度\n学习计算机技术 目标任务 区块链 前端 目标时间\n目标进度\n学习英语 目标任务 雅思 托福 目标时间\n目标进度\n进行流汗黄豆计划 目标任务 任务流程 组织活动 目标时间\n目标进度\n计划安排 打卡记录 ","date":"2023-11-21T23:30:00+08:00","image":"/lihan3238.github.io/p/save_lihan_again/cuc_huc0543863ee7ccbbdd76d4d6fb45d875f_648485_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/save_lihan_again/","title":"女娲补天计划2.0"},{"content":"欢迎大家支持小寒！ 这样就有钱买服务器、吃好吃的、买游戏、买我以为有用的东西了！嘿嘿！ 支持方式 Bitcoin: 1 bc1qv2hudf6u2ch8dgpuj938u2pt2n78t9tg3887sk Kaspa: 1 kaspa:qp8nq7eq0pktzv87md579d7c6kcj5v8d7jq9v67hcyne82tf62e4wf42rm2v8 ","date":"2023-11-21T16:40:53+08:00","image":"/lihan3238.github.io/p/support_lihan/coin_huf97679e9da2578f85978728031d2da58_23526_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/support_lihan/","title":"支持小寒"},{"content":"思考 高中才正式接触互联网，感觉现在才逐渐了解到一些事情。\n之前不能理解朋友圈仅三天可见，以为只是隐私和生人勿近。\n现在明白了，其实是不需要互联网上展示自己给别人，以及最重要的，随着年龄增长，之前的言论很可能显得幼稚可笑。\n仅三天可见是一种避免黑历史的很好的手段。\n研究 因此我也得想办法解决我的博客上的这个问题。\n本来单另出来一个页面作为我的赛博日记，但是感觉会成为黑历史，但又想搞。\n总之需求是，有一个方便我随时记录查看的日记本，只给我和我亲近的人(或想让看的人)看。\n暂时就先撤下来这个页面了，想到好办法再说。\n","date":"2023-11-19T20:54:53+08:00","image":"/lihan3238.github.io/p/dream231119/avatar_huab4f7afdfad270ee93cc6c9958151aca_2665_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dream231119/","title":"关于成长与朋友圈三天可见"},{"content":"1. 在dockerhub上创建一个repository 登录dockerhub网站后，点击上图圈处创建新仓库。\n2. 给本地镜像打上tag 1 2 3 4 # tag格式 docker tag \u0026lt;本地镜像名\u0026gt; \u0026lt;dockerhub用户名\u0026gt;/\u0026lt;仓库名\u0026gt;:\u0026lt;tag\u0026gt; # 有一个名为`lihan_ndbmgm:1.0`的镜像 docker tag lihan_ndbmgm:1.0 lihan3238/mysql_ndb_cluster-ubuntu:lihan_ndbmgm` tips 此时本地出现两个tag指向同一个镜像，分别是原来的lihan_ndbmgm:1.0和新的lihan3238/mysql_ndb_cluster-ubuntu:lihan_ndbmgm。 使用docker rmi命令任意删除一个tag不会影响镜像的使用。\n3. push镜像 1 2 3 4 # 命令行登录docker docker login -u lalalalal --password-stdin balabala docker.io # push镜像 docker push lihan3238/mysql_ndb_cluster-ubuntu:lihan_ndbmgm ","date":"2023-11-15T08:15:00+08:00","image":"/lihan3238.github.io/p/dockerhubpush/dockerhub_hu7e9b4a210e23f4c8d826c858bc37c46c_123625_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dockerhubpush/","title":"在Dockerhub上push镜像"},{"content":"问题 在Ubuntu等Linux系统下，使用apt或dpkg安装包时，可能会出现缺少依赖的情况。\n解决方案 使用apt --fix-broken install命令即可解决。\n","date":"2023-11-11T15:20:00+08:00","image":"/lihan3238.github.io/p/point_5/apt_hube484aa6e3b2c2b96f0b92c74e03cddc_24911_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_5/","title":"Ubuntu下安装包时缺少依赖的快速解决方法"},{"content":"环境 windows11上的ubuntu22.04的wsl2 ubuntu20.04 mysql-cluster_8.0.35-1ubuntu20.04_amd64 配置环境 sql0 192.168.50.100 管理节点 sql1 192.168.50.128 数据节点[11] sql节点 sql2 192.168.50.129 数据节点[12] sql节点 成品镜像 lihan_ndbmgm 管理节点 docker pull lihan3238/mysql_ndb_cluster-ubuntu:lihan_ndbmgm\nlihan_ndbd_sql 数据节点 sql节点 docker pull lihan3238/mysql_ndb_cluster-ubuntu:lihan_ndbd_sql\ndocker容器配置 windows11上的ubuntu22.04的wsl2 下载镜像 1 2 docker pull ubuntu:20.04 docker pull jrei/systemd-ubuntu:20.04 创建网络 1 docker network create --driver bridge --subnet 192.168.50.0/24 --gateway 192.168.50.1 mysqlBridge 创建容器 1 2 # sql0 docker run -di --name sql0 -v /home/lihan/sqlStudy:/home/shareFiles --net mysqlBridge --ip 192.168.50.100 ubuntu:20.04 下载mysql-cluster-community-server安装包 /mysql-cluster_8.0.35-1ubuntu20.04_amd64.deb-bundle.tar 将下载好的安装包放在宿主机挂载的目录下\n安装mysql-cluster-community-server sql0 1 2 3 4 5 6 7 8 9 10 11 12 # 进入容器 docker exec -it sql0 /bin/bash # 创建mysql用户 adduser mysql # 密码123456 usermod -aG sudo mysql # 解压文件到install目录 mkdir install tar -xvf /home/shareFiles/mysql-cluster_8.0.35-1ubuntu20.04_amd64.deb-bundle.tar -C install/ cd install 缺少依赖libssl1.1 libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64 1 2 3 4 5 6 7 8 # 下载依赖包`libssl1.1`后，复制到宿主机挂载目录下 dpkg -i /home/shareFiles/libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb # 更新修复`libssl1.1` apt update apt upgrade 制作镜像并创建sql1和sql2容器 sql0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 下点需要的东西 apt install vim sudo dialog net-tools iputils-ping # 退出容器 exit docker stop sql0 docker commit sql0 lihansql:1.0 docker start sql0 # (可选)镜像保存为文件 docker save -o lihansql_1.0.tar lihansql:1.0 # 根据镜像创建容器sql1 sql2 # sql1 docker run -di --name sql1 -v /home/lihan/sqlStudy:/home/shareFiles --net mysqlBridge --ip 192.168.50.128 lihansql:1.0 # sql2 docker run -di --name sql2 -v /home/lihan/sqlStudy:/home/shareFiles --net mysqlBridge --ip 192.168.50.129 lihansql:1.0 配置集群管理器(Cluster Manager服务器) sql0 192.168.50.100 安装ndb_mgmd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 解压安装install目录下的依赖包 dpkg -i install/mysql-cluster-community-management-server_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-common_8.0.35-1ubuntu16.04_amd64.deb dpkg -i install/mysql-cluster-community-client-plugins_8.0.35-1ubuntu20.04_amd64.deb # 安装提示缺少依赖`libgssapi-krb5-2` `libkrb5-3` `libsasl2-2` apt --fix-broken install # 继续安装 dpkg -i install/mysql-cluster-community-client-plugins_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-client-core_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-client_8.0.35-1ubuntu20.04_amd64.deb 配置ndb_mgmd 1 2 3 # 创建配置文件 mkdir /var/lib/mysql-cluster vim /var/lib/mysql-cluster/config.ini config.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [ndbd default] # Options affecting ndbd processes on all data nodes: NoOfReplicas=2 # Number of replicas [ndb_mgmd] # Management process options: hostname=192.168.50.100 # Hostname of the manager datadir=/var/lib/mysql-cluster # Directory for the log files [ndbd] hostname=192.168.50.128 # Hostname/IP of the first data node NodeId=11 # Node ID for this data node datadir=/usr/local/mysql/data # Remote directory for the data files [ndbd] hostname=192.168.50.129 # Hostname/IP of the second data node NodeId=12 # Node ID for this data node datadir=/usr/local/mysql/data # Remote directory for the data files [mysqld] # SQL node options: hostname=192.168.50.128 # MySQL server/client i manager [mysqld] # SQL node options: hostname=192.168.50.129 # MySQL server/client i manager 启动ndb_mgmd 1 ndb_mgmd -f /var/lib/mysql-cluster/config.ini 显示以下信息\n1 2 3 MySQL Cluster Management Server mysql-8.0.35 ndb-8.0.35 2023-11-07 08:24:08 [MgmtSrvr] INFO -- The default config directory \u0026#39;/usr/mysql-cluster\u0026#39; does not exist. Trying to create it... 2023-11-07 08:24:08 [MgmtSrvr] INFO -- Sucessfully created config directory (非必须)配置ndb_mgmd开机启动 docker的官方Ubuntu20.04镜像不带init，不支持systemd，因此跳过这个开机启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 杀死进程 pkill -f ndb_mgmd # 创建启动脚本 vim /etc/systemd/system/ndb_mgmd.service # 编辑ndb_mgmd.service [Unit] Description=MySQL NDB Cluster Management Server After=network.target auditd.service [Service] Type=forking ExecStart=/usr/sbin/ndb_mgmd -f /var/lib/mysql-cluster/config.ini ExecReload=/bin/kill -HUP $MAINPID KillMode=process Restart=on-failure [Install] WantedBy=multi-user.target # 采用daemon-reload重新加载配置 systemctl daemon-reload # 启动ndb_mgmd开机运行 systemctl enable ndb_mgmd # 启动ndb_mgmd systemctl start ndb_mgmd # 验证ndb_mgmd是否正在执行 systemctl status ndb_mgmd # 应该输出类似信息 ndb_mgmd.service - MySQL NDB Cluster Management Server Loaded: loaded (/etc/systemd/system/ndb_mgmd.service, enabled) Active: active (running) 管理ndb_mgmd 1 2 3 4 5 # 设置允许其他MySQL Cluster节点接入，如无`ufw`等防火墙，可以跳过这一步 ufw allow from 192.168.50.100 ufw allow from 192.168.50.128 ufw allow from 192.168.50.129 配置数据节点(Data Nodes) sql1 192.168.50.128 安装ndbd 1 2 3 4 5 6 # 安装依赖 sudo apt-get -f install sudo apt install libclass-methodmaker-perl # 安装ndbd dpkg -i install/mysql-cluster-community-data-node_8.0.35-1ubuntu20.04_amd64.deb 创建并配置 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 # 创建配置文件 vim /etc/my.cnf # 编辑my.cnf [mysql_cluster] # Options for NDB Cluster processes: ndb-connectstring=192.168.50.100 # location of cluster manager # 创建数据目录 mkdir -p /usr/local/mysql/data 启动ndbd 1 2 3 4 5 6 7 8 9 10 11 # 启动 ndbd # 输出类似信息 2023-11-08 00:47:06 [ndbd] INFO -- Angel connected to \u0026#39;192.168.50.100:1186\u0026#39; 2023-11-08 00:47:07 [ndbd] INFO -- Angel allocated nodeid: 11 # 如果出现连接问题，请打开防火墙 ufw allow from 192.168.50.100 ufw allow from 192.168.50.128 ufw allow from 192.168.50.129 (非必须)配置ndbd开机启动 docker的官方Ubuntu20.04镜像不带init，不支持systemd，因此跳过这个开机启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # 杀死进程 pkill -f ndbd # 创建启动脚本 vim /etc/systemd/system/ndbd.service # 编辑ndbd.service [Unit] Description=MySQL NDB Data Node Daemon After=network.target auditd.service [Service] Type=forking ExecStart=/usr/sbin/ndbd ExecReload=/bin/kill -HUP $MAINPID KillMode=process Restart=on-failure [Install] WantedBy=multi-user.target # 采用daemon-reload重新加载配置 systemctl daemon-reload # 启动ndb_mgmd开机运行 systemctl enable ndbd # 启动ndb_mgmd systemctl start ndbd # 验证ndb_mgmd是否正在执行 systemctl status ndbd # 应该输出类似信息 ndbd.service - MySQL NDB Data Node Daemon Loaded: loaded (/etc/systemd/system/ndbd.service, enabled) Active: active (running) 配置SQL节点(配置并运行MySQL Server 和 Client) sql1 标准的MySQL server不支持 MySQL Cluster 引擎 NDB. 这意味着我们需要安装含有定制的SQL服务器 MySQL Cluster软件. 安装依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 安装联网依赖 apt update apt install libaio1 libmecab2 # 解压安装install目录下的依赖包 dpkg -i install/mysql-common_8.0.35-1ubuntu16.04_amd64.deb dpkg -i install/mysql-cluster-community-client-plugins_8.0.35-1ubuntu20.04_amd64.deb # 安装提示缺少依赖`libgssapi-krb5-2` `libkrb5-3` `libsasl2-2` apt --fix-broken install # 继续安装 dpkg -i install/mysql-cluster-community-client-plugins_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-client-core_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-client_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-client_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-server-core_8.0.35-1ubuntu20.04_amd64.deb # 安装提示缺少依赖`libnuma1` apt --fix-broken install # 继续安装 dpkg -i install/mysql-cluster-community-server-core_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-cluster-community-server_8.0.35-1ubuntu20.04_amd64.deb # 安装提示缺少依赖`libnuma1` apt --fix-broken install # 继续安装 dpkg -i install/mysql-cluster-community-server_8.0.35-1ubuntu20.04_amd64.deb #提示设置root密码 123456 # 重新安装 dpkg -i install/mysql-cluster-community-server_8.0.35-1ubuntu20.04_amd64.deb dpkg -i install/mysql-server_8.0.35-1ubuntu20.04_amd64.deb 配置MySQL server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # MySQL Server 配置文件默认为 /etc/mysql/my.cnf vim /etc/mysql/my.cnf # 编辑my.cnf [mysqld] # Options for mysqld process: ndbcluster # run NDB storage engine ndb-connectstring=192.168.50.100 # default engine default_storage_engine=ndbcluster [mysql_cluster] # Options for NDB Cluster processes: ndb-connectstring=192.168.50.100 # location of management server # 重启 #systemctl restart mysql # 开机启动 #systemctl enable mysql 启动MySQL server 1 2 3 4 5 # 启动mysql数据库 mysqld --user=root \u0026amp; # 进入mysql数据库 mysql --socket=/run/mysqld/mysqld.sock -u root -p # 小tips：这里用了sudo 记得可能第一遍输入电脑的root密码，第二次输入mysql密码 验证MySQL Cluster安装 sql0 192.168.50.100 启动ndb_mgmd\n1 2 3 ndb_mgmd -f /var/lib/mysql-cluster/config.ini sql1 192.168.50.128 启动ndbd\n1 ndbd 连接MySQL Server 1 mysql -u root -p 报错1：\n运行service mysql(d) start，报错unrecognized service 运行mysql，报错Connection error: Can't connect to local MySQL server through ***.sock 解决1：\nmysqld是用来启动mysql数据库的命令，mysql是打开并执行sql语句的命令。mysql.sock是随每一次 mysql server启动生成的。因此在未启动服务的情况下，直接运行mysql命令，会报错找不到*.sock\n1 2 3 4 5 # mysqld启动mysql数据库 --user=mysql 指定mysql用户 \u0026amp; 后台运行 mysqld --user=root \u0026amp; # 关闭mysql数据库 mysqladmin -u root -p shutdown 报错2：\n[ERROR] Fatal error: Please read “Security” section of the manual to find out how to run mysqld as root 解决2：\n一般情况下，mysql禁止root用户登陆数据库\n以其他用户登陆mysql\n在命令行上添加参数--user=root，这样每次都要添加，有点麻烦\n编辑/etc/my.cnf，对对应标签（[mysql]/[mysqld]）添加user=root的设置\n报错3：\nmysql -u root -p输入密码后，卡死或提示权限问题 解决3：\n权限问题，使用sudo mysql -u root -p，输入密码后，可以正常登陆\n报错3：\nmysql -u root -p输入密码后，报错Connection error: Can't connect to local MySQL server through ***.sock 解决3：\nfind / -name *.sock查找.sock文件，启动时添加参数--socket=/run/mysqld/mysqld.sock，根据查找到的路径指定.sock文件\nmysql --socket=/run/mysqld/mysqld.sock -u root -p 查看NDB引擎的相关信息 1 SHOW ENGINES NDB STATUS \\G 输出类似信息 1 quit 集群管理器控制台上查看集群信息 sql0 192.168.50.100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ndb_mgm # 进入ndb_mgm控制台 SHOW # 查看集群信息 # 显示如下信息 Cluster Configuration --------------------- [ndbd(NDB)] 2 node(s) id=11 @192.168.50.128 (mysql-8.0.35 ndb-8.0.35, starting, Nodegroup: 0) id=12 (not connected, accepting connect from 192.168.50.129) [ndb_mgmd(MGM)] 1 node(s) id=1 @192.168.50.100 (mysql-8.0.35 ndb-8.0.35) [mysqld(API)] 2 node(s) id=13 (not connected, accepting connect from 192.168.50.128) id=14 (not connected, accepting connect from 192.168.50.129) 问题1 发现ndbd正常连接，但是mysql无法连接\n解决1 不知道为什么，一定要将集群的所有其他节点配置连接好后，才能连接上mysql节点。 吧sql2的ndbd配置好后，sql1和sql2的mysql就可以连接上了。\n制作镜像并创建sql2容器 sql1 192.168.50.128 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 退出容器 exit docker stop sql1 docker commit sql1 lihan_ndbd_sql:1.0 docker start sql1 # (可选)镜像保存为文件 docker save -o lihan_ndbd_sql.tar lihan_ndbd_sql:1.0 # 根据镜像创建容器sql1 sql2 # sql2 docker run -di --name sql2 -v /home/lihan/sqlStudy:/home/shareFiles --net mysqlBridge --ip 192.168.50.129 lihan_ndbd_sql:1.0 docker exec -it sql2 /bin/bash ndbd mysqld --user=root \u0026amp; 验证连接 sql0 192.168.50.100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ndb_mgm # 进入ndb_mgm控制台 SHOW # 查看集群信息 # 显示如下信息 Cluster Configuration --------------------- [ndbd(NDB)] 2 node(s) id=11 @192.168.50.128 (mysql-8.0.35 ndb-8.0.35, Nodegroup: 0, *) id=12 @192.168.50.129 (mysql-8.0.35 ndb-8.0.35, Nodegroup: 0) [ndb_mgmd(MGM)] 1 node(s) id=1 @192.168.50.100 (mysql-8.0.35 ndb-8.0.35) [mysqld(API)] 2 node(s) id=13 @192.168.50.128 (mysql-8.0.35 ndb-8.0.35) id=14 @192.168.50.129 (mysql-8.0.35 ndb-8.0.35) 向MySQL集群插入数据 注意为了使用集群功能, 必须使用NDB数据库引擎. 如果使用InnoDB (default)或其他引擎,将不能使用集群. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- 首先, 在一个sql节点创建数据库clustertest: CREATE DATABASE clustertest; -- 其次转到新数据库: USE clustertest; -- 再次，创建表test_table: CREATE TABLE test_table (name VARCHAR(20), value VARCHAR(20)) ENGINE=ndbcluster; -- 如果`my.cnf`中没有设置，这里需要显式规定ndbcluster引擎. -- 现在可以插入数据了: INSERT INTO test_table (name,value) VALUES(\u0026#39;some_name\u0026#39;,\u0026#39;some_value\u0026#39;); -- 最后在另一个sql节点验证数据插入： SELECT * FROM test_table; 思考：在本例中，数据被插入到了哪个机器？\n问题：\n1 通过实验，你对一个分布式数据库系统有何理解？分布式数据库系统预计有何优越性？ 2 你能设计一个方案验证集群系统在可靠性上优于集中式数据库系统吗？ 3 同样是插入数据，你觉得MySQL Cluster和myCAT 在实体完整性保持方面是否可能会有不同？为什么？ ","date":"2023-11-07T10:30:00+08:00","image":"/lihan3238.github.io/p/mysqlcluster/mysql_hu07b159bcfc8e2c4da17d54f1731b5ada_39031_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/mysqlcluster/","title":"搭建MySQLCluster集群环境"},{"content":"commit message格式 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;commit类型\u0026gt;(影响范围): 具体描述\n具体描述举例 fix(DAO): fixed invalid user table indexes.\n解释 type type指明git commit的类别，应该使用以下类型，也可根据团队自行增减\n『feat』: 新增功能 『fix』: 修复 bug 『docs』: 仅仅修改了文档，比如 README, CHANGELOG等等 『test』: 增加/修改测试用例，包括单元测试、集成测试等 『style』: 修改了空行、缩进格式、引用包排序等等（不改变代码逻辑） 『perf』: 优化相关内容，比如提升性能、体验、算法等 『refactor』: 代码重构，「没有新功能或者bug修复」 『chore』: 改变构建流程、或者增加依赖库、工具等 『revert』: 回滚到上一个版本 『merge』: 代码合并scope（可选） scope\n用于说明 commit 影响的范围，根据不同项目有不同层次描述。若没有特殊规定，也可以描述影响的哪些功能等。\nsubject subject是commit目的的简短描述，不超过50/80个字符，一般git提交的时候会有颜色提示。\n若英文用不惯，那么推荐使用中文若是开源代码，一律推荐统一英文， 英文不行可以翻译软件用起来 若是开源代码，可以再附加对应的issue地址 结尾不加标点符号 oh-my-zsh git commit示例 这里给出常用的oh-my-zsh的git commit的截图，采用的就是上述规范：\n","date":"2023-10-29T21:59:00+08:00","image":"/lihan3238.github.io/p/git_commit_info/git_hu128d69c0d61aa850686d75427db95755_2383_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/git_commit_info/","title":"gitcommit规范"},{"content":"问题 在使用github仓库时，会出现有意或无意commit甚至push了包含隐私信息(密码、身份信息等)的文件。\n原因 使用github action``github pages时，workflow等可能需要依赖token或密码等。 此外，即使删除了文件，但是仓库中的commit历史记录中仍然会存在，也需要进行处理。\n解决方案 github action secret加密隐私信息 利用github提供的github action secret功能，将token等信息保存在secret中，然后在workflow中调用secret中的信息。\n实际上，通过在workflow中增加临时修改文件的操作，也可以实现对所有文件中的隐私信息替换，而不仅是workflow目录下的文件中的隐私信息替换 。 以我的个人博客为例，由于个人博客中的gitalk评论区插件需要依赖github outh app，因此需要在workflow中调用github action secret中的token信息。\n相关数据保存在config/_default/params.toml文件中。\n1 2 3 4 5 6 7 8 ... repo = \u0026#34;lihan3238.github.io\u0026#34; clientID = \u0026#34;1eda156wa\u0026#34; clientSecret = \u0026#34;5168165\u0026#34; ... 注意到，文件中的隐私信息是明文保存的，任何访问者都能直接看到，很危险。 首先将原文替换为特定字符串\n1 2 3 repo = \u0026#34;lihan3238.github.io\u0026#34; clientID = \u0026#34;id\u0026#34; clientSecret = \u0026#34;cs\u0026#34; 打开https://[仓库地址]/settings/secrets/actions(例如) 添加secret，并将token等信息保存在secret中。\n然后在workflow中添加进行替换的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 jobs: # Update config file job update_config_file: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Modify config file run: | CLIENT_ID_SECRET=${{ secrets.CLIENT_ID_SECRET }} CLIENT_SECRET_SECRET=${{ secrets.CLIENT_SECRET_SECRET }} sed -i \u0026#34;s/clientID = \\\u0026#34;id\\\u0026#34;/clientID = \\\u0026#34;$CLIENT_ID_SECRET\\\u0026#34;/\u0026#34; ${{ github.workspace }}/config/_default/params.toml sed -i \u0026#34;s/clientSecret = \\\u0026#34;cs\\\u0026#34;/clientSecret = \\\u0026#34;$CLIENT_SECRET_SECRET\\\u0026#34;/\u0026#34; ${{ github.workspace }}/config/_default/params.toml build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.114.0 # ！！！！！！！！！记得给之后的步骤添加依赖needs，不然谁知道先执行哪个！！！！！！！！ # !!!!!!!!!要在同一个jobs里，不同步骤，好像不在一个job可能有问题 needs: update_config_file steps: ··· bfg删除历史commit中的隐私信息 bfg是一个用于清除git仓库中大文件的工具，可以用于清除历史commit中的隐私信息。\n前往官网,下载bfg工具的jar包，然后在本地仓库目录下命令行中运行命令\n1 2 3 java -jar [bfg.jar的绝对路径] --delete-files [要删除记录的文件名(不用地址)] # 强制更新远程仓库 git push --force ","date":"2023-10-29T02:30:00+08:00","image":"/lihan3238.github.io/p/point_4/github_hu4ef90462b16b46de427cbb17719e0382_3797_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_4/","title":"github仓库中的隐私信息处理"},{"content":"问题 在使用命令行进行Git push的时候，发现无法push,出现报错。\n1 2 3 4 5 `.git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 原因 git配置私钥出了问题\n解决方案 检查C:\\Users\\[用户名]\\.ssh目录下是否有github的公私钥及config文件是否配置正确： 私钥格式问题 私钥文件的格式必须是id_rsa，而不能是id_rsa.ppk，否则会出现报错。\n1 2 invalid format git@github.com: Permission denied (publickey). 解决：\n1 2 3 4 5 6 7 8 9 10 11 打开 PuTTY Key Generator（PuTTYgen）。 在 PuTTYgen 中，点击 \u0026#34;Load\u0026#34; 按钮，并选择你的 PPK 格式的私钥文件。 PuTTYgen 会提示你输入私钥文件的密码，如果设置了密码的话，请输入。 密钥文件加载后，点击 \u0026#34;Conversions\u0026#34; 菜单，然后选择 \u0026#34;Export OpenSSH Key\u0026#34;。 选择一个目标文件名和目录来保存转换后的 OpenSSH 格式的私钥。确保文件没有扩展名（例如，保存为 github_test_private）。 保存私钥文件后，你就可以在 Git 中使用它了。 config文件配置问题 1 2 3 4 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 验证 1 ssh -T git@github.com ","date":"2023-10-29T02:29:00+08:00","image":"/lihan3238.github.io/p/point_3/git_hu128d69c0d61aa850686d75427db95755_2383_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_3/","title":"gitpush失败问题2"},{"content":"基于 Scapy 编写端口扫描器 实验目的 掌握网络扫描之端口状态探测的基本原理 实验环境 kali python 3.11.4 scapy 2.5.0 实验要求 禁止探测互联网上的 IP ，严格遵守网络安全相关法律法规 完成以下扫描技术的编程实现 TCP connect scan / TCP stealth scan TCP Xmas scan / TCP fin scan / TCP null scan UDP scan 上述每种扫描技术的实现测试均需要测试端口状态为：开放、关闭 和 过滤 状态时的程序执行结果 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因； 在实验报告中详细说明实验网络环境拓扑、被测试 IP 的端口状态是如何模拟的 实验内容 实验网络环境拓扑 如图所示网络中的节点基本信息如下： 攻击者主机(lihanAttackerKaliChap4) mac地址：08:00:27:ef:46:19/eth0 ip地址：172.16.111.135 受害者主机(lihanVictimKali1) mac地址：08:00:27:93:2e:67/eth0 ip地址：172.16.111.102 网关(lihanGatewayDebian) mac地址：08:00:27:63:cd:72/enp0s9 ip地址：172.16.111.1 实验过程 扫描技术的编程实现 测试端口状态为：开放、关闭 和 过滤 状态时的程序执行结果\n关闭状态：对应端口没有开启监听, 防火墙没有开启。 1 ufw disable 开启状态：对应端口开启监听: apache2基于TCP, 在80端口提供服务;防火墙ufw处于关闭状态。 1 systemctl start apache2 # port 80 过滤状态：对应端口开启监听, 防火墙开启。 1 ufw enable \u0026amp;\u0026amp; ufw deny 80/tcp TCP connect scan / TCP stealth scan TCP connect scan 这种扫描方式可以使用 Connect()调用，使用最基本的 TCP 三次握手链接建立机制，建立一个链接到目标主机的特定端口上。 首先发送一个 SYN 数据包到目标主机的特定端口上，接着我们可以通过接收包的情况对端口的状态进行判断：\n如果接收到的是一个 SYN/ACK 数据包，则说明端口是开放状态的； 如果接收到的是一个 RST/ACK 数据包，通常意味着端口是关闭的并且链接将会被重置； 如果目标主机没有任何响应则意味着目标主机的端口处于过滤状态。\n若接收到 SYN/ACK 数据包（即检测到端口是开启的），便发送一个 ACK 确认包到目标主机，这样便完成了三次握手连接机制。成功后再终止连接。如图所示：\n1 2 3 4 5 6 7 8 9 10 11 def tcp_connect_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[tcp_connect_scan]\\033[0m {target_port}...\\n\u0026#34;) response = sr1(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;S\u0026#34;), timeout=2) if response and response.haslayer(TCP): if response[TCP].flags == 0x12: send(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;R\u0026#34;)) print(f\u0026#34;Port {target_port} is open\\n\u0026#34;) elif response[TCP].flags == 0x14: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is filtered\\n\u0026#34;) TCP stealth scan 在TCP connect scan基础上，收到目标主机的数据包后，不进行回应，从而不打成三次握手连接，这使得目标主机难以确定是否正在进行扫描。\n1 2 3 4 5 6 7 8 9 10 11 def tcp_stealth_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[tcp_stealth_scan]\\033[0m {target_port}...\\n\u0026#34;) response = sr1(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;S\u0026#34;), timeout=2) if response and response.haslayer(TCP): if response[TCP].flags == 0x12: send(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;R\u0026#34;)) print(f\u0026#34;Port {target_port} is open\\n\u0026#34;) elif response[TCP].flags == 0x14: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is filtered\\n\u0026#34;) TCP Xmas scan / TCP fin scan / TCP null scan TCP Xmas scan Xmas 发送一个 TCP 包，并对 TCP 报文头 FIN、URG 和 PUSH 标记进行设置。若是关闭的端口则响应 RST 报文；开放或过滤状态下的端口则无任何响应。如图所示。优点是隐蔽性好，缺点是需要自己构造数据包，要求拥有超级用户或者授权用户权限。\n1 2 3 4 5 6 7 8 def tcp_xmas_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[tcp_xmas_scan]\\033[0m {target_port}...\\n\u0026#34;) response = sr1(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;FPU\u0026#34;), timeout=2) if response and response.haslayer(TCP): if response[TCP].flags == 0x14: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is filtered or opened\\n\u0026#34;) TCP fin scan 仅发送 FIN 包，它可以直接通过防火墙，如果端口是关闭的就会回复一个 RST 包，如果端口是开放或过滤状态则对 FIN 包没有任何响应。如图所示。 其优点是 FIN 数据包能够通过只监测 SYN 包的包过滤器，且隐蔽性高于 SYN 扫描。缺点和 SYN 扫描类似，需要自己构造数据包，要求由超级用户或者授权用户访问专门的系统调用。\n1 2 3 4 5 6 7 8 def tcp_fin_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[tcp_fin_scan]\\033[0m {target_port}...\\n\u0026#34;) response = sr1(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;F\u0026#34;), timeout=2) if response and response.haslayer(TCP): if response[TCP].flags == 0x14: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is filtered or opened\\n\u0026#34;) TCP null scan 发送一个 TCP 数据包，关闭所有 TCP 报文头标记。只有关闭的端口会发送 RST 响应。其优点和 Xmas 一样是隐蔽性好，缺点也是需要自己构造数据包，要求拥有超级用户或者授权用户权限。\n1 2 3 4 5 6 7 8 def tcp_null_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[tcp_null_scan]\\033[0m {target_port}...\\n\u0026#34;) response = sr1(IP(dst=target_ip)/TCP(dport=target_port, flags=\u0026#34;\u0026#34;), timeout=2) if response and response.haslayer(TCP): if response[TCP].flags == 0x14: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is filtered or opened\\n\u0026#34;) UDP scan UDP 是一个无链接的协议，当我们向目标主机的 UDP 端口发送数据,我们并不能收到一个开放端口的确认信息，或是关闭端口的错误信息。可是，在大多数情况下，当向一个未开放的 UDP 端口发送数据时,其主机就会返回一个 ICMP 不可到达(ICMP_PORT_UNREACHABLE)的错误，因此大多数 UDP 端口扫描的方法就是向各个被扫描的 UDP 端口发送零字节的 UDP 数据包，如果收到一个 ICMP 不可到达的回应，那么则认为这个端口是关闭的,对于没有回应的端口则认为是开放的，但是如果目标主机安装有防火墙或其它可以过滤数据包的软硬件,那我们发出 UDP 数据包后,将可能得不到任何回应,我们将会见到所有的被扫描端口都是开放的。如图所示： 其缺点是，UDP 是不可靠的，UDP 数据包和 ICMP 错误报文都不保证到达；且 ICMP 错误消息发送效率是有限的，故而扫描缓慢；还有就是非超级用户无法直接读取端口访问错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def udp_scan(target_ip, target_port): print(f\u0026#34;\\033[31m[udp_scan]\\033[0m {target_port}...\\n\u0026#34;) # 发送一个零字节的UDP数据包到目标端口 udp_packet = IP(dst=target_ip)/UDP(dport=target_port) response = sr1(udp_packet, timeout=2, verbose=0) if response is None: # 没有回应，通常认为端口是开放的 print(f\u0026#34;Port {target_port} is open or filtered\\n\u0026#34;) else: if response.haslayer(ICMP): # 收到ICMP错误消息 if int(response.getlayer(ICMP).type) == 3 and int(response.getlayer(ICMP).code) in [3, 13, 14]: print(f\u0026#34;Port {target_port} is closed\\n\u0026#34;) else: print(f\u0026#34;Port {target_port} is open or filtered\\n\u0026#34;) 上述每种扫描技术的实现测试均需要测试端口状态为：开放、关闭 和 过滤 状态时的程序执行结果 代码\nclose\nopen filter 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因 close open filter 实验问题 python报错 在windows编写完代码后传到kali 虚拟机运行时报错SyntaxError: Non-ASCII character '\\xe7' in file test.py on line 3, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details\n解决方法：在文件开头加入# -*- coding: utf-8 -*-\n","date":"2023-10-20T15:33:00+08:00","image":"/lihan3238.github.io/p/nschap0x05/assets/imgs/gitlab_hu378db0d1931d06fb22fd8d9b0c1037db_591_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/nschap0x05/","title":"2023网络安全作业chap0x05"},{"content":"在Nginx服务器安装证书 在Nginx独立服务器、Nginx虚拟主机上安装证书的操作不同，请根据您的实际环境，选择对应的安装步骤。\n在Nginx独立服务器上安装证书 执行以下命令，在Nginx的conf目录下创建一个用于存放证书的目录。 1 2 cd /usr/local/nginx/conf #进入Nginx默认配置文件目录。该目录为手动编译安装Nginx时的默认目录，如果您修改过默认安装目录或使用其他方式安装，请根据实际配置调整。 mkdir cert #创建证书目录，命名为cert。 将证书文件和私钥文件上传到Nginx服务器的证书目录（/usr/local/nginx/conf/cert）。 编辑Nginx配置文件nginx.conf，修改与证书相关的配置。 执行以下命令，打开配置文件。 1 vim /usr/local/nginx/conf/nginx.conf 在nginx.conf中定位到server属性配置。 根据如下内容进行修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 server { #HTTPS的默认访问端口443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 listen 443 ssl; #填写证书绑定的域名 server_name \u0026lt;yourdomain\u0026gt;; #填写证书文件名称 ssl_certificate cert/\u0026lt;cert-file-name\u0026gt;.pem; #填写证书私钥文件名称 ssl_certificate_key cert/\u0026lt;cert-file-name\u0026gt;.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #自定义设置使用的TLS协议的类型以及加密套件（以下为配置示例，请您自行评估是否需要配置） #TLS协议版本越高，HTTPS通信的安全性越高，但是相较于低版本TLS协议，高版本TLS协议对浏览器的兼容性较差。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示优先使用服务端加密套件。默认开启 ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; } } ","date":"2023-10-18T22:13:00+08:00","image":"/lihan3238.github.io/p/nginxssl/SSL_hu8c168ed275f07c03ee28283ed0280321_7831_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/nginxssl/","title":"在Nginx服务器安装SSL证书"},{"content":"新手自学前端路线图速览 第一阶段：前端入门网页基础 html5+css3 ➾ 页面布局实战\n第二阶段：前端入门开发内功 javascript(基础+进阶)➾ ES6 ➾ Ajax ➾ Promise ➾ Git ➾ node.js ➾ PC端全栈开发实战\n第三阶段：前端高级框架技术 vue2+vue3 ➾ vue实战项目 ➾ Pinia ➾ React ➾ React实战项目\n第四阶段，混合应用开发技术 微信公众号 ➾ 微信小程序 ➾ 微信小程序实战项目 ➾ uni-app ➾ uni-app实战项目\n第五阶段：大前端的架构技术 webpack5 ➾ Vite2 ➾ typescript架构 ➾ HarmonyOS app\n","date":"2023-10-18T16:25:00+08:00","image":"/lihan3238.github.io/p/front-enddevelopmentroadmap/frontEnd_huf87b7343f62d83eced1d03348d028354_377948_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/front-enddevelopmentroadmap/","title":"前端学习路线"},{"content":"云服务器上线网站 购买域名 域名购买网站：Godaddy 购买方式略，这就不用教了吧。\n使用的话\n云服务器 Microsoft_Azure_Education免费云服务器 注册认证学生计划 在Github教育上完成学生认证(百度教程，大概就是上传学信网的英文翻译版学历认证.pdf，能不开魔法就不开，学校教育邮箱认证)后，登录azure,绑定github，不行就在azure重新认证一下学生，就好了，自己研究一下，他这个有点小bug。主要就是这俩按钮:\n创建VPS 在哪里创建虚拟机 进入azure个人仪表盘,点击免费服务-浏览所有，根据需要选择创建的虚拟机: 配置虚拟机 网上搜了搜，好像现版本答案(2023.10.16)是Debian,Centos是上个版本答案，那就先选Debian了。\n虚拟机名称：lihanDebian11AzureVPS\n区域：(US) East US\n系统：Debian 11 (Bullseye) - x64 Gen2\n大小：Standard B1s - 1 vcpu, 1 GiB memory\n管理员账户SSH\n用户名：lihan3238 SSH公钥源：生成新的密钥对 密钥对名称：lihanDebian11AzureVPS_key 入站端口规则\n入站端口：SSH(22) 创建虚拟机后，会下载一个私钥lihanDebian11AzureVPS_key.pem，这个私钥是用来连接虚拟机的，所以要保存好，不然就要重新生成密钥对了。\n连接虚拟机 进入VPS页面，点击连接，选择本机SSH,根据提示SSH连接。 以Windows11的命令行Windows Powershell进行SSH连接为例:\n将私钥lihanDebian11AzureVPS_key.pem放到C:\\Users\\[用户名]\\.ssh\\目录下，并在C:\\Users\\[用户名]\\.ssh\\config文件中添加如下内容:\n1 2 3 4 Host [VPS公共ip] HostName [VPS公共ip] IdentityFile ~/.ssh/lihanDebian11AzureVPS_key.pem User lihan3238 # 这里是你创建VPS时设置的用户名 然后在Windows Powershell中输入ssh lihan3238@[VPS公共ip]即可连接VPS。\n配置VPS 本地虚拟机测试docker Gin 1 2 3 4 5 6 docker pull golang # web1目录下放置gin框架搭建的网站 # 不知道为什么，这里的web1目录不能加`/home/` docker run -di --name lihanGinServer -v /home/lihan/VPStest/gin/web1:/go/web1 golang # 运行gin网站 sudo docker exec -di lihanGinServer /bin/bash -c \u0026#34;cd web1/;go run main.go\u0026#34; Nginx 1 2 3 docker pull nginx # 在宿主机上创建/home/lihan/VPStest/nginx目录，目录下创建www、conf、logs目录，conf目录下创建nginx.conf文件，分别挂载到容器中 docker run -di -p 9091:80 --name lihanNginxServer -v /home/lihan/VPStest/nginx/www:/usr/share/nginx/html -v /home/lihan/VPStest/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/lihan/VPStest/nginx/logs:/var/log/nginx nginx nginx配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include /etc/nginx/conf.d/*.conf; upstream gin { server 172.17.0.2:8080; } server { listen 80; location / { proxy_pass http://gin; #Proxy Settings proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Proto $proxy_add_x_forwarded_for; } } } MySQL 1 docker pull mysql 暂无\n云服务器上线网站 制作docker镜像 1 2 3 4 5 6 7 8 # 容器打包成镜像 docker commit lihanGinServer lihangin docker commit lihanNginxServer lihannginx # 镜像保存为tar文件 docker save -o lihangin.tar lihangin docker save -o lihannginx.tar lihannginx # 上传到VPS VPS上配置容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Debian11安装docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh # 设置开机自启动 sudo systemctl start docker sudo systemctl enable docker # 导入镜像 docker load -i lihangin.tar docker load -i lihannginx.tar # 创建文件夹 mkdir -p /home/lihan3238/VPStest/nginx/www mkdir -p /home/lihan3238/VPStest/nginx/conf mkdir -p /home/lihan3238/VPStest/nginx/logs mkdir -p /home/lihan3238/VPStest/gin/web1 mkdir -p /home/lihan3238/VPStest/mysql # 在/home/lihan3238/VPStest/nginx/conf下创建nginx.conf文件 # 运行gin容器 docker run -di --name lihanGinServer -v /home/lihan3238/VPStest/gin/web1:/go/web1 lihangin sudo docker exec -di lihanGinServer /bin/bash -c \u0026#34;cd web1/;go run main.go\u0026#34; # 运行nginx容器 docker run -di -p 9091:80 --name lihanNginxServer -v /home/lihan3238/VPStest/nginx/www:/usr/share/nginx/html -v /home/lihan3238/VPStest/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/lihan3238/VPStest/nginx/logs:/var/log/nginx lihannginx # 运行mysql容器 略 # 每次重启 sudo docker start lihanGinServer sudo docker start lihanNginxServer sudo docker exec -di lihanGinServer /bin/bash -c \u0026#34;cd web1/;go run main.go\u0026#34; 外网访问 此时服务器只开放了用于SSH连接的22端口，没有开放网站的9091端口。\n进入VPS配置界面，点击网络-入站端口规则-添加，添加9091端口，保存。 稍等后即可通过公网ip访问网站啦。 问题 docker debug docker logs lihanNginxServer\ndocker0的bridge网络地址分配问题 有时候启动后发现访问不了网站，原因是每次重启容器，都会重新分配容器内ip地址，虽然大部分情况下不变，但偶尔还是会变的，所以要在nginx.conf中重新配置upstream的ip地址。\nNginx的80端口占用\n检查一下/etc/nginx/conf.d/default.conf文件，看看是不是有server{listen 80;}这样的配置，如果有，就把它删掉，然后重启nginx服务就可以了。 因为/etc/nginx/nginx.conf中有include /etc/nginx/conf.d/*.conf;这样的配置，所以default.conf中的配置也会生效，所以要把default.conf中的配置删掉，或者把default.conf文件删掉，或者把default.conf文件名改成default.conf.bak这样的，这样nginx就不会加载default.conf文件了。\nAzure免费额度 Azure免费额度账单 Azure虚拟机免费金额100$,保质期366天，但是虚拟机只有一共750h使用时间，也就是31.25天，所以不用时候记得关机。 然后有很多乱七八糟小号免费金额的杂项，比如静态公共ip就要收费，所以少要、用静态公共ip，用动态公共ip就行了。\n动态公网ip与FQDN\n使用动态公网ip后，可以在Azure仪表盘设置FQDN，这样就可以通过域名访问网站了。 如填写op，那么可以访问op.eastus.cloudapp.azure.com访问 (用这个顺便把ssh的config改了，免得折腾)\n上传文件失败问题 nginx默认允许上传文件大小为1MB，在配置中修改client_max_body_size 50M;\n1 2 3 4 5 6 7 8 9 10 11 12 13 server { listen 80; location / { proxy_pass http://gin; # 修改文件传输大小限制 client_max_body_size 50M; #Proxy Settings proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Proto $proxy_add_x_forwarded_for; } } ","date":"2023-10-16T10:10:00+08:00","image":"/lihan3238.github.io/p/cloudserveronlinewebsite/cloudServer_hua85d743ff9f3f207e944ce0f34e37f93_6300_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/cloudserveronlinewebsite/","title":"云服务器上线网站"},{"content":"问题 在使用TortoiseGit进行Git push的时候，发现无法push,出现报错。\n原因 不知道什么原因，TortoiseGit的Pageant出现了问题，丢失了私钥privateKey。\n解决方案 打开Pageant，添加私钥privateKey，即可。\n","date":"2023-10-15T22:29:00+08:00","image":"/lihan3238.github.io/p/point_2/git_hu128d69c0d61aa850686d75427db95755_2383_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_2/","title":"gitpush失败问题"},{"content":"问题 在使用VirtualBox的时候，发现无法启动所有虚拟机时报错。\n原因 安装了Docker，Docker开发环境会强制开启Hyper-V，导致VirtualBox无法启动。\n解决方案 打开\u0026quot;开始\u0026quot;菜单，搜索\u0026quot;程序和功能\u0026quot;,选择\u0026quot;启用或关闭 Windows功能\u0026quot;，在列表中找到\u0026quot;Hyper-V\u0026quot;把前面的勾选取消并确定。 这个时候已经开始卸载，卸载完毕重启电脑即可。\n如果还是不行那就用命令行再进行关闭。 以管理员身份运行命令提示符 执行命令\n1 bcdedit /set hypervisorlaunchtype off 重启，运行Virtual Box即可\n恢复 如果想要恢复hyper启动，\n1 bcdedit / set hypervisorlaunchtype autok 一劳永逸 windows上安装docker时，选择wsl2 instead of HyperV，装在wsl2上就完了\n","date":"2023-10-15T22:13:00+08:00","image":"/lihan3238.github.io/p/point_1/DockerVbox_hub853fb83ee7f814d0d5c0439da7f79c0_58899_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/point_1/","title":"Docker和Virtualbox的冲突"},{"content":"网络监听实验 实验环境 网络拓扑 使用第一次实验中的internalNetwork1的lihanGatewayDebian、lihanVictimKali1以及新配置的lihanAttackerKaliChap4\n如图所示网络中的节点基本信息如下： 攻击者主机(lihanAttackerKaliChap4) mac地址：08:00:27:ef:46:19/eth0 ip地址：172.16.111.135 受害者主机(lihanVictimKali1) mac地址：08:00:27:93:2e:67/eth0 ip地址：172.16.111.102 网关(lihanGatewayDebian) mac地址：08:00:27:63:cd:72/enp0s9 ip地址：172.16.111.1 实验要求 实验一：检测局域网中的异常终端 实验二：手工单步“毒化”目标主机的 ARP 缓存 实验过程 实验准备 确定在攻击者主机上提前安装好 scapy 并更新\n1 pip3 install scapy[complete] 实验一：检测局域网中的异常终端 注意，启动虚拟机前 要在虚拟机的网络配置处，允许开启混杂模式。 在受害者主机上检查网卡的「混杂模式」是否启用 1 ip link show eth0 输出结果里没有出现PROMISC字符串,未开启混杂模式\n在攻击者主机上使用 scapy 发送 ARP 请求包，获取局域网中的主机信息 1 2 sudo scapy pkt = promiscping(\u0026#34;172.16.111.102\u0026#34;) 开启该网卡的「混杂模式」 1 sudo ip link set eth0 promisc on 此时会发现输出结果里多出来了 PROMISC\n再次使用 scapy 发送 ARP 请求包，获取局域网中的主机信息 1 pkt = promiscping(\u0026#34;172.16.111.102\u0026#34;) 关闭该网卡的「混杂模式」 1 sudo ip link set eth0 promisc off 总结 混杂模式 接收所有经过网卡的数据包，包括不是发给本机的包，不验证MAC地址 普通模式 网卡只接收发给本机的包 使用wireshark分析：\npromiscping命令会发送ARP who-has 请求,且没有指定目的主机的MAC地址，只有受害者主机开启混杂模式后，才能收到该请求包。\n实验二：手工单步“毒化”目标主机的 ARP 缓存 获取当前局域网的网关 MAC 地址 构造一个 ARP 请求 1 2 3 arpbroadcast = Ether(dst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;)/ARP(op=1,pdst=\u0026#34;172.16.111.1\u0026#34;) # 查看构造好的 ARP 请求报文详情 arpbroadcast.show() 发送 ARP 请求 1 recved = srp(arpbroadcast, timeout=2) 查看网关 MAC 地址 1 2 gw_mac = recved[0][0][1].hwsrc gw_mac 伪造网关的 ARP 响应包 发送给受害者主机 192.168.0.102,ARP 响应的目的 MAC 地址设置为攻击者主机的 MAC 地址 1 2 3 arpspoofed=Ether()/ARP(op=2, psrc=\u0026#34;172.16.111.1\u0026#34;, pdst=\u0026#34;172.16.111.102\u0026#34;, hwdst=\u0026#34;08:00:27:ef:48:19\u0026#34;) arpspoofed.show() 发送 ARP 响应包 1 sendp(arpspoofed) 在受害者主机上查看 ARP 缓存 发现网关的 MAC 地址已被「替换」为攻击者主机的 MAC 地址\n恢复受害者主机的 ARP 缓存 伪装网关给受害者发送 ARP 响应 1 2 3 restorepkt1 = Ether()/ARP(op=2, psrc=\u0026#34;172.16.111.1\u0026#34;, hwsrc=\u0026#34;08:00:27:63:cd:72\u0026#34;, pdst=\u0026#34;172.16.111.102\u0026#34;, hwdst=\u0026#34;08:00:27:93:2e:67\u0026#34;) sendp(restorepkt1, count=100, inter=0.2) 伪装受害者给网关发送 ARP 响应 1 2 3 restorepkt2 = Ether()/ARP(op=2, pdst=\u0026#34;172.16.111.1\u0026#34;, hwdst=\u0026#34;08:00:27:63:cd:72\u0026#34;, psrc=\u0026#34;172.16.111.102\u0026#34;, hwsrc=\u0026#34;08:00:27:93:2e:67\u0026#34;) sendp(restorepkt2, count=100, inter=0.2) 在受害者主机上准备“刷新”网关 ARP 记录 1 2 3 ping 192.168.0.1 ip neigh 实验问题 实验环境配置 配置实验环境时候，产生了一个疑问，网络拓扑中的switch如何实现。之前只配置过vbox中的几种网络模式，没有专门选择switch或者hub。 解决 在联网搜索及浏览上次实验时的笔记后，了解到，Vbox中不需要专门配置switch或者hub，多种网络模式分别对应着不同的网络拓扑结构，虚拟出了switch等，根据需要选择即可。实验中需要的网络拓扑，选择Internal Network(内部网络)即可。\n网卡配置 配置攻击主机lihanAttackerKaliChap4的网卡时，发现不能获取ip地址。 解决 发现是因为自己没有开机Gateway主机，开机后，攻击主机可以获取到ip地址。\n参考 网络安全-第四章 网络监听 黄老师的畅课视频回放 VirtualBox虚拟机几种网络的区别 ","date":"2023-10-11T00:33:00+08:00","image":"/lihan3238.github.io/p/nschap0x04/assets/imgs/gitlab_hu378db0d1931d06fb22fd8d9b0c1037db_591_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/nschap0x04/","title":"2023网络安全作业chap0x04"},{"content":"Docker\u0026amp;\u0026amp;K8s学习笔记 Docker 官网 官方文档 Docker安装（Ubuntu22.04.3） 不同平台有差异，建议百度 1 2 3 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo service docker start 1. 卸载旧版本 1 for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done 2. 安装依赖并添加GPG密钥 1 2 3 4 5 sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg 3. 添加Docker软件源仓库 1 2 3 4 5 echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update 4. 安装Docker Engine 1 2 3 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin # 验证安装 sudo docker run hello-world 5. 卸载Docker Engine 1 2 3 4 5 #卸载软件包 sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras #删除所有镜像、容器和卷 sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 6. 设置ustc镜像源 1 2 3 4 #在/etc/docker/daemon.json中写入 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } Docker常用命令 docker --help：查看docker帮助 1. 启动docker服务 1 2 3 4 5 6 7 8 9 10 #启动docker服务 sudo systemctl start docker #查看docker服务状态 sudo systemctl status docker #停止docker服务 sudo systemctl stop docker #重启docker服务 sudo systemctl restart docker #开机自启动docker服务 sudo systemctl enable docker 2. 镜像相关 2.1 查看镜像 1 2 3 4 5 6 7 docker images #REPOSITORY : 镜像名称 #TAG ：镜像标签 #IMAGE ID ：镜像ID #CREATED ：镜像创建时间 #SIZE ： 镜像大小 2.2 搜索镜像 1 2 3 4 5 6 7 docker search [镜像名称] #NAME ：镜像名称 #DESCRIPTION ：镜像描述 #STARS ：镜像评价 #OFFICIAL ：是否官方 #AUTOMATED ：是否自动构建，表示该镜像由DockerHub自动构建流程创建的 2.3 拉取镜像 1 2 docker pull [镜像名称]:[标签] #不加标签时，默认拉取latest标签 2.4 删除镜像 1 2 3 4 5 docker rmi [镜像ID] #删除镜像时，要求该镜像没有被容器使用 #删除所有镜像 docker rmi `docker images -q` 3. 容器相关 3.1 查看容器 1 2 3 4 5 6 7 8 9 10 11 #查看正在运行中的容器 docker ps #查看停止的容器 docker ps -f status=exited #查看所有容器 docker ps -a #查看最近一次创建的容器 docker ps -l 3.2 创建与启动容器 1 2 3 4 5 6 7 8 9 docker run #参数说明 #-i ：以交互模式运行容器，通常与 -t 同时使用； #-t ：启动后进入其命令行，即为容器重新分配一个伪输入终端，通常与 -i 同时使用； #--name ：为容器指定一个名称； #-v ：将本地目录挂载到容器中，前一个是宿主机目录，后一个是容器内部的挂载点； #-d ：后台运行守护式容器，创建容器后不会自动登陆容器。 #-p ：指定端口映射，前一个是宿主机端口，后一个是容器内部的映射端口，可用多个-p做多个端口映射。 (1) 交互式方式创建容器\n1 2 docker run -it --name=[容器名称] [镜像名称]:[标签] /bin/bash #创建即登录，退出即关闭 (2) 守护式方式创建容器\n1 2 3 4 5 docker run -di --name=[容器名称] [镜像名称]:[标签] /bin/bash #创建不登陆，退出不关闭 #登录容器 docker exec -it [容器名称] /bin/bash 3.3 启动与停止容器 1 2 docker start [容器名称] docker stop [容器名称] 3.4 文件拷贝 1 2 3 4 #从容器拷贝到主机 docker cp [容器名称]:[容器内路径] [主机路径] #从主机拷贝到容器 docker cp [主机路径] [容器名称]:[容器内路径] 3.5 目录挂载 目录挂载是将主机的目录挂载到容器中，容器中的文件会实时同步到主机中，主机中的文件也会实时同步到容器中(共享文件夹) 1 2 docker run -di --name=[容器名称] -v [主机目录]:[容器内目录] [镜像名称]:[标签] #似乎docker目录只能写相对路径，不能写绝对路径 3.6 查看容器ip 1 2 3 4 5 6 #查看容器全部信息 docker inspect [容器名称] #查看容器ip docker inspect --format=\u0026#39;{{.NetworkSettings.IPAddress}}\u0026#39; [容器名称] 3.7 删除容器 1 2 3 docker rm [容器名称] #删除所有容器 docker rm `docker ps -a -q` 3.8 容器日志 1 2 3 4 5 6 7 docker logs --help docker logs -tf \u0026lt;--tail [显示数量]\u0026gt; [容器名称] #示例 docker run -di --name=lihan_ubuntu ubuntu:22.04 /bin/sh -c \u0026#34;while true; do echo hello world; sleep 1; done\u0026#34; docker logs -tf --tail 10 lihan_ubuntu 3.9 查看容器中进程信息 ps 1 docker top [容器名称] 3.10 查看容器中元数据 1 docker inspect [容器名称] 4. 应用部署 4.1 MySQL 1 2 3 4 5 #拉取镜像 docker pull mysql:5.7 #创建容器 docker run -di --name=lihan_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=lihan mysql:5.7 使用MySQL Workbench连接数据库 用127.0.0.1连不上，突然想起来我用的是虚拟机。。。 导入sql文件 4.2 Tomcat 1 2 3 4 5 #拉取镜像 docker pull tomcat:7-jre7 #创建容器 docker run -di --name=lihan_tomcat -p 18080:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 将sample.war放在docker宿主机的/usr/local/webapps目录下，访问http://localhost:18080/sample即可测试 4.3 Nginx 1 2 3 4 5 #拉取镜像 docker pull nginx #创建容器 docker run -di --name=lihan_nginx -p 180:80 nginx testweb目录复制到docker中 docker exec -it lihan_nginx /bin/bash进入容器,进入:/etc/nginx/conf.d目录，查看default.conf文件，根据root /usr/share/nginx/html;,将testweb目录中的文件复制到/usr/share/nginx/html目录下，访问http//localhost:180即可测试 4.4 Redis部署 1 2 3 4 5 #拉取镜像 docker pull redis #创建容器 docker run -di --name=lihan_redis -p 6379:6379 redis 略，没学过，先不测试了\n5.迁移与备份 5.1 容器保存为镜像 1 2 3 4 docker commit [容器名称] [镜像名称]:[标签] #查看镜像 docker images 5.2 镜像保存为文件(.tar) 1 docker save -o [文件名].tar [镜像名称]:[标签] 5.3 文件(.tar)导入为镜像 1 docker load -i [文件名].tar 6. Dockerfile 6.1 Dockerfile介绍 Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像\n对于开发人员:可以为开发团队提供一个完全一致的开发环境; 对于测试人员:可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作 对于运维人员:在部署时，可以实现应用的无缝移植。 6.2 Dockerfile指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #指定基础镜像 FROM [镜像名称]:[标签] #维护者信息 MAINTAINER [维护者姓名] #设置环境变量 ENV [key] [value] #镜像操作指令 RUN [shell命令] #拷贝文件 COPY [源路径] [目标路径] #COPY并解压压缩包 ADD [源路径] [目标路径] #设置工作目录 WORKDIR [工作目录] #设置容器启动时执行的命令 ENTRYPOINT [shell命令] 6.3 Dockerfile构建镜像 jdk8镜像构建为例\njdk-8u371-linux-x64.tar.gz\n1 2 3 4 5 6 7 8 9 10 11 # 将jdk-8u371-linux-x64.tar.gz放在宿主机的/usr/local/dockerjdk目录下 # 创建`Dockerfile`文件 FROM ubuntu:18.04 MAINTAINER lihan RUN mkdir /usr/local/java ADD jdk-8u371-linux-x64.tar.gz /usr/local/java/ # jdk-8u371-linux-x64.tar.gz 解压后为 jdk1.8.0_371 ENV JAVA_HOME /usr/local/java/jdk1.8.0_371 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH 1 2 3 # 构建镜像 # . 表示当前目录下的Dockerfile文件 docker build -t lihanjdk1.8 . 7. Docker私有仓库 7.1 搭建与配置私有仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 拉取私有仓库镜像 docker pull registry # 创建私有仓库容器 docker run -di --name=lihan_registry -p 5000:5000 registry # 打开浏览器，访问http://\u0026lt;ip\u0026gt;:5000/v2/_catalog，看到`{\u0026#34;repositories\u0026#34;:[]}`表示私有仓库搭建成功 # 修改docker配置文件，添加私有仓库地址，使本地可以上传镜像到私有仓库 在`/etc/docker/daemon.json`中添加 { \u0026#34;insecure-registries\u0026#34;: [\u0026#34;\u0026lt;ip\u0026gt;:5000\u0026#34;] } # 重启服务 systemctl restart docker 7.2 上传和下载镜像到私有仓库 1 2 3 4 5 6 7 8 9 # tag镜像,为镜像创建一个新的标签 docker tag [镜像名称]:[标签] [私有仓库地址]/[镜像名称]:[标签] # 上传镜像，确保registry是运行的 docker start [registry镜像容器名] docker push [私有仓库地址]/[镜像名称]:[标签] # 下载镜像 docker pull [私有仓库地址]/[镜像名称]:[标签] Docker网络(Docker0) Docker网络详解\n查看容器IP：\ndocker inspect --format='{{.NetworkSettings.IPAddress}}' [容器名称]\ndocker inspect [容器名称] | grep IPAddress\n实现原理 Docker在安装时会创建一个名为docker0的虚拟网桥，当创建一个容器时，会为其分配一个IP地址，称为Container-IP，同时将容器加入到docker0网桥中，这样容器就可以和docker0网桥中的其他容器通信，也可以和宿主机通信，从而实现容器之间的通信。\n四种网络模式 当你安装Docker时，它会自动创建三个网络。bridge（创建容器默认连接到此网络）、 none 、host。你可以使用以下docker network ls命令列出这些网络:\nbridge网络代表docker0，所有Docker安装中存在的网络。除非你使用docker run --network=选项指定，否则Docker守护程序默认将容器连接到此网络\n使用docker run创建Docker容器时，可以用--net选项指定容器的网络模式，Docker可以有以下4种网络模式：\nhost模式：使用--net=host指定。 none模式：使用--net=none指定。 bridge模式：使用--net=bridge指定，默认设置。 container模式：使用--net=container:NAME_or_ID指定 Docker网络模式 配置 说明 host模式 --net=host 容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 container模式 --net=container:NAME_or_ID 容器和另外一个容器共享Network namespace。创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围 bridge模式 --net=bridge 默认为该模式 此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 none模式 --net=none 容器使用自己的网络，容器与主机不共享网络，容器之间不能互相通信 host模式 使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。\n使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。\ncontainer模式 指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\nnone模式 Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。\n这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过\u0026ndash;network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。\nbridge模式 当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。\n从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。\nbridge模式是docker的默认网络模式，不写\u0026ndash;net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。\n自定义网络 建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零或多个网络。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。\n自定义bridge网络 1 2 3 4 5 6 7 8 9 10 11 # 创建自定义bridge网络 my_bridge docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 my_bridge # 使用自定义网络创建容器并指定ip docker run -di --name=lihan_tomcat -p 18080:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps --net my_bridge --ip 192.168.0.2 tomcat:7-jre7 # 查看自定义网络 docker network inspect my_bridge # docker0和自定义网络之间网络不通 Macvlan Macvlan是一个新的尝试，是真正的网络虚拟化技术的转折点。Linux实现非常轻量级，因为与传统的Linux Bridge隔离相比，它们只是简单地与一个Linux以太网接口或子接口相关联，以实现网络之间的分离和与物理网络的连接。\nMacvlan提供了许多独特的功能，并有充足的空间进一步创新与各种模式。这些方法的两个高级优点是绕过Linux网桥的正面性能以及移动部件少的简单性。删除传统上驻留在Docker主机NIC和容器接口之间的网桥留下了一个非常简单的设置，包括容器接口，直接连接到Docker主机接口。由于在这些情况下没有端口映射，因此可以轻松访问外部服务。\noverlay网络 overlay网络用于连接不同机器上的docker容器，允许不同机器上的容器相互通信，同时支持对消息进行加密，当我们初始化一个swarm或是加入到一个swarm中时，在docker主机上会出现两种网络： 1、称为ingress的overlay网络，用于传递集群服务的控制或是数据消息，若在创建swarm服务时没有指定连接用户自定义的overlay网络，将会加入到默认的ingress网络\n2、名为docker_gwbridge桥接网络会连接swarm中所有独立的docker系统进程\n可以使用docker network create创建自定义的overlay网络，容器以及服务可以加入多个网络，只有同一网络中的容器可以相互交换信息，可以将单一容器或是swarm服务连接到overlay网络中，但是两者在overlay网络中的行为会有所不同.\nKubernetes(K8s) Kubernetes安装 ","date":"2023-10-03T15:41:00+08:00","image":"/lihan3238.github.io/p/dockerstudy/docker_hud9ce6195fcd94ce3696edad083f5ae1b_2474_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/dockerstudy/","title":"Docker\u0026\u0026K8s学习笔记"},{"content":"前言 本来在搭建了个人博客后觉得实用性更重要,几次准备学习如何装音乐组件又放弃了,但今天突然想到顺便妥善保存自己喜欢的音乐,就整了一个基于Aplayer和GitHub仓库的音乐组件,哈哈,github真成云盘了.\n本文以Hugo|Stack主题为例 链接 Aplayer官方中文文档 基于github的自动化音乐仓库 博客导入Aplayer music.html 在博客仓库\\layouts\\partials(如果没有就新建)目录下新建music.html文件,复制以下代码(可根据官网文档修改) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- require APlayer --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- require MetingJS --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;player1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var ap = new APlayer ({ element: document.getElementById(\u0026#39;player1\u0026#39;), fixed: true, autoplay: false, mini: true, theme: \u0026#39;#f8f4fc\u0026#39;, loop: \u0026#39;all\u0026#39;, order: \u0026#39;random\u0026#39;, preload: \u0026#39;auto\u0026#39;, volume: 0.4, mutex: true, listFolded: true, listMaxHeight: \u0026#39;500px\u0026#39;, lrcType: 0, music: [ { name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: \u0026#39;url.mp3\u0026#39;, cover: \u0026#39;cover.jpg\u0026#39; } ] }); //ap.init(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; custom.html 在博客仓库\\layouts\\partials\\footer\\custom.html文件中插入(新建)以下代码 1 {{ partial \u0026#34;music\u0026#34; . }} 配置 详见官网文档 常见参数: 名称 默认值 描述 container document.querySelector(\u0026rsquo;.aplayer') 播放器容器元素 fixed false 开启吸底模式, 详情 mini false 开启迷你模式, 详情 autoplay false 音频自动播放 theme \u0026lsquo;#b7daff\u0026rsquo; 主题色 loop \u0026lsquo;all\u0026rsquo; 音频循环播放, 可选值: \u0026lsquo;all\u0026rsquo;, \u0026lsquo;one\u0026rsquo;, \u0026rsquo;none\u0026rsquo; order \u0026rsquo;list\u0026rsquo; 音频循环顺序, 可选值: \u0026rsquo;list\u0026rsquo;, \u0026lsquo;random\u0026rsquo; preload \u0026lsquo;auto\u0026rsquo; 预加载，可选值: \u0026rsquo;none\u0026rsquo;, \u0026lsquo;metadata\u0026rsquo;, \u0026lsquo;auto\u0026rsquo; volume 0.7 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 audio - 音频信息, 应该是一个对象或对象数组 audio.name - 音频名称 audio.artist - 音频艺术家 audio.url - 音频链接 audio.cover - 音频封面 audio.lrc - 详情 audio.theme - 切换到此音频时的主题色，比上面的 theme 优先级高 audio.type \u0026lsquo;auto\u0026rsquo; 可选值: \u0026lsquo;auto\u0026rsquo;, \u0026lsquo;hls\u0026rsquo;, \u0026rsquo;normal\u0026rsquo; 或其他自定义类型, 详情 customAudioType - 自定义类型，详情 mutex true 互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 lrcType 0 详情 listFolded false 列表默认折叠 listMaxHeight - 列表最大高度 storageName \u0026lsquo;aplayer-setting\u0026rsquo; 存储播放器设置的 localStorage key 基于Github仓库的音乐链接 由于播放器需要在线音乐链接,我选择了将音乐上传到GitHub仓库,然后获取链接,顺便还储存了自己喜欢的音乐. 可以浏览 基于github的自动化音乐仓库 ,学习如何上传音乐到GitHub仓库. 最方便的是这个仓库中直接将音乐生成了符合格式的代码,可以直接复制粘贴到music.html中的music参数中使用.\n本博客参考了山茶花舍-给 Hugo 加一点好玩的功能 ","date":"2023-09-23T22:31:00+08:00","image":"/lihan3238.github.io/p/hugomusic/Aplayer_hu569969981562d7baf962e9ca50ca4f09_18760_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/hugomusic/","title":"hugo博客音乐组件"},{"content":"1. 人民币汇率 目前国内经济低迷，出现了资本主义经济危机的典型特征：巨量的过剩生产和低迷的消费需求。 由于货币政策与国际金融的愿意，很难看出长期是通胀还是通缩，但是在美联储加息的情况下以及国内不断刺激经济防水情况下， 短期内人民币对美元一定是贬值的，因此短期内捣鼓rmb-usdt应该有油水。长期来看，经济下行导致通缩可能被货币政策抵消甚至超过，但无论如何，还是要备点存粮避免大萧条没饭吃。\n2. btc 2024年btc会再次减半，基于政治经济学原理，btc的交换价值来源于生产过程中消耗的电量、矿机成本、维护运营成本。在btc总数基本不变，情况下，btc价格一定是向上的，再加上2024的减半，预计2024第三季度第四季度，btc会迎来有一次高峰，此时是入手的最佳时机。btc堪比黄金，但距离真正的区块链货币还差很远。\n3. 黄金 货币天然是金银而金银天然不是货币，金银的开采成本应该不会出现巨大变动，因此黄金是最好的一般等价物，想保证货币不贬值，避免通胀最好方法就是买黄金。\n4. 股票 宏观上就是骗多数人的钱到少数人手上，反正我不碰。\n","date":"2023-09-22T11:01:00+08:00","image":"/lihan3238.github.io/p/determine_1/btc_hu6613aed77420b4349a6e8eaf74697949_36521_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/determine_1/","title":"投资判断_1"},{"content":"基于 VirtualBox 的网络攻防基础环境搭建 实验目的 掌握 VirtualBox 虚拟机的安装与使用； 掌握 VirtualBox 的虚拟网络类型和按需配置； 掌握 VirtualBox 的虚拟硬盘多重加载； 实验环境 以下是本次实验需要使用的网络节点说明和主要软件举例：\nVirtualBox 虚拟机 攻击者主机（Attacker）：Kali-linux-2023.3-virtalbox-amd64 网关（Gateway, GW）：Debian Buster 靶机（Victim）：From Sqli to shell / xp-sp3 / Kali 实验要求 虚拟硬盘配置成多重加载，效果如下图所示； 搭建满足如下拓扑图所示的虚拟机网络拓扑； 根据实验宿主机的性能条件，可以适度精简靶机数量\n完成以下网络连通性测试； 靶机可以直接访问攻击者主机 攻击者主机无法直接访问靶机 网关可以直接访问攻击者主机和靶机 靶机的所有对外上下行流量必须经过网关 所有节点均可以访问互联网 实验过程 配置虚拟机与虚拟硬盘 从中传云盘下载黄老师的.vdi文件，并解压到本地目录\n在VirtualBox中注册三个虚拟硬盘 创建虚拟机： 创建虚拟机，选择Use an Existing Virtual Hard Disk File 设置多重加载 如果直接在虚拟硬盘界面设置多重加载，会出现报错显示版本过低，如图: 解决方法：先进行步骤3.，点开运行虚拟机后退出，再进行步骤4.，即可成功设置多重加载。 这个方法是偶然间发现的，个人猜测原因是启动虚拟机后，VirtualBox会自动更新虚拟机的版本，从而解决了版本过低的问题。\n重复步骤3.和步骤4.，创建6个虚拟机，分别命名为Attacker-kali、Gateway-Debian、Victim-XP-1、Victim-XP-2、Victim-Kali-1、Victim-Debian-2，并设置虚拟硬盘为多重加载，简单分了个组，如图： 配置虚拟机网络、搭建网络拓扑 创建Host-Only网络 创建网卡VirtualBox Host-Only Ethernet Adapter #2 配置地址为192.168.74.1 子网掩码为255.255.255.0 启用DHCP服务器，配置服务器地址为192.168.74.100 子网掩码为255.255.255.0 地址范围为192.168.74.101~254 配置虚拟机及网络 Gateway-Debian 网卡1：NAT网络地址转换 ip:10.0.2.15/24 网卡2：仅主机(Host-Only)网络 选择VirtualBox Host-Only Ethernet Adapter #2 ip:192.168.74.101/24 网卡3：内部网络(InternalNetwork) 命名为InternalNetwork1 ip:172.16.111.1/24 网卡4：内部网络(InternalNetwork) 命名为InternalNetwork2 ip:172.16.222.1/24 开机后发现需要输入账号密码，浏览网络及尝试后得知，Debian的root账号密码为: 账号： root 密码： toor 重置了cuc账户的密码为cuc，方便使用。 检查网卡配置文件发现老师给的镜像中网卡配置已经配置好了。 突然意识到还有5个虚拟机，重新改了一下hostname为lihanGatewayDebian Victim-XP-1/2 以Victim-XP-1为例，另一个同理。 网卡1：内部网络(InternalNetwork) 命名为InternalNetwork1 ip:172.16.111.112 网关:172.16.111.1 开机验证： Victim-XP-2 - 网卡1：内部网络(InternalNetwork) 命名为InternalNetwork2 ip:172.16.222.114 网关:172.16.222.1\nVictim-kali-1 开机后发现需要输入账号密码，浏览网络及尝试后得知，Debian的root账号密码为: 账号： kali 密码： kali 网卡1：内部网络(InternalNetwork) 命名为InternalNetwork1 ip:172.16.111.102 网关:172.16.111.1 开机验证： Victim-Debian-2\n网卡1：内部网络(InternalNetwork) 命名为InternalNetwork2 ip:172.16.222.143 网关:172.16.222.1 开机验证： Attacker-kali 创建NAT网络,并修改Gateway-Debian的网卡1为NAT网络: 网卡1：NAT网络 ip: 10.0.2.4 开机验证： 进行尚未进行过的网络连通性验证 靶机-攻击机\n靶机可以直接访问攻击者主机 攻击者主机无法直接访问靶机 靶机的所有对外上下行流量必须经过网关 总览 实验问题 修改Debian的主机名后，使用sudo命令时会出现如下报错： 1 sudo: unable to resolve host lihanDebian: No address associated with hostname 应该是修改了主机名后一些程序调用的仍然是原来的主机名，好在不影响使用，但总卡几秒钟并且需要重复输入密码很烦人。\n解决方法：\n1 sudo vim /etc/hosts 参考 VirtualBox虚拟机几种网络的区别 Debian 修改主机名的方法 Ubuntu / Debian: sudo 出现 unable to resolve host 错误解决办法 linux虚拟机安装与配置/ssh免密登录 黄老师的畅课视频回放 ","date":"2023-09-22T00:31:00+08:00","image":"/lihan3238.github.io/p/nschap0x01/assets/imgs/gitlab_hu378db0d1931d06fb22fd8d9b0c1037db_591_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/nschap0x01/","title":"2023网络安全作业chap0x01"},{"content":"前言 配置VirtualBox虚拟机网络时，有几种网络模式，这里做一个总结。 网络模式 网络地址转换NAT 在VirtualBox中，当使用NAT模式时，多个虚拟机的IP地址相同。如果您将2个或多个虚拟机的网络适配器配置为使用NAT模式，每个虚拟机将在一个隔离网络的虚拟NAT设备后获得一个10.0.2.15的IP地址。每个虚拟机的默认网关是10.0.2.2。 VirtualBox网络使用NAT网络模式的时候，虚拟机上的操作系统也可以访问外部网络，包括互联网；宿主机或其所在局域网的其他服务器不能直接访问虚拟机。\nNAT网络 NAT网络模式，不能从宿主机访问客机（除非你在全局VirtualBox网络设置中配置了端口转发）。一个内置的VirtualBox NAT路由器使用VirtualBox主机的物理网络接口控制器作为外部网络接口（和NAT模式一样）。 如果你对多个虚拟机使用NAT网络模式，它们可以通过网络相互通信。虚拟机可以访问物理网络中的其他主机，也可以访问外部网络，包括互联网。任何来自外部网络的机器以及宿主机所连接的物理局域网的机器都不能访问被配置为使用NAT网络模式的虚拟机。\nNAT网络的默认地址是10.0.2.0/24。默认的网关IP地址是10.0.2.1（x.x.x.1的ip模版通常被用于设置默认网关IP），比如，如果你在virtualbox中配置了基于NAT网络模式的虚拟网络，设置了192.168.22.0/24的网络地址，则这个网络的网关地址会是192.168.22.1。\n在NAT网络模式下，你不能改变网关的IP地址，也不能改变由DHCP服务器分配的IP地址范围。类似的，DHCP服务器的IP地址默认是10.0.2.3（使用x.x.x.3的模版）。 桥接网卡(桥接适配器) 将虚拟机的虚拟网络适配器与VirtualBox主机的物理网络适配器相连。虚拟机的虚拟网络适配器使用主机网络接口进行网络连接。简单地说，虚拟网络适配器直接发送或接收网络数据包，不使用额外的路由。 宿主机所在的物理本地局域网的服务器都能独立对等地访问跑在虚拟机上的服务器。桥接模式下运行的虚拟网络适配器的默认网关与主机的默认网关相同. 你可以从虚拟机访问宿主机、宿主机所在物理网络的其他主机以及外部网络，包括互联网。虚拟机也可以被同一物理局域网中的宿主机以及其他主机（或虚拟机）所访问。如果你在宿主机上有多个物理网络适配器，你应该在VirtualBox网络设置中选择正确的适配器。\n混杂模式这种模式允许网络适配器中转所有接收到的流量，无论流量是寻址哪个适配器的。在正常模式下，网络适配器只接收包括该特定网络适配器的MAC地址作为目标地址的帧。在正常模式下，被寻址到与所选适配卡的MAC地址不同的MAC地址的帧（当流量不是广播时）会被丢弃。混杂模式使一个物理网络适配器有多个MAC地址成为可能，允许所有传入的流量通过主机的物理网络适配器，到达虚拟机的虚拟网络适配器，该虚拟机有自己的MAC地址，并被认为是宿主机物理适配器上的另一个mac地址，即使该流量并不是寻址该特定虚拟机的虚拟网络适配器。 使用混杂模式有三个选项：\n1、Deny。\n任何不以虚拟机的虚拟网卡为目的地的流量都将被屏蔽。这个选项是默认设置。\n2、Allow VMs。\n除了去向或来自于虚拟机的流量，其他流量都将被屏蔽。\n3、Allow ALL。\n这一模式下没有限制，虚拟机的网卡可以看到所有进来、出去的流量。混杂模式不仅可以用于桥接网络模式，也可以用于NAT网络模式，Internal网络模式和Host-only适配器模式。\n内部网络(Internal Network) VirtualBox中的虚拟机网卡被配置成Internal network模式的时候，他们会被接入一个隔离的虚拟网络。在这个隔离的虚拟网络中，虚拟机之间可以互相通信，但是他们不能和Virtualbox中的宿主机通信，不能和宿主机所在的局域网中的其他主机通信，也不能外部网络通信。宿主机或其他设备可以访问接入到Internal Network中的虚拟机。Virtualbox中的Internal network可以用来模拟真实网络。\nHost-Only仅主机网络 这种网络模式用于在宿主机和虚拟机之间进行通信。一个虚拟机可以与连接到host-only网络的其他虚拟机通信，也可以与宿主机通信。VirtualBox宿主机可以访问所有连接到host-only网络的虚拟机。 虚拟机的虚拟网络适配器在其IP配置中没有网关，因为host-only模式不允许你连接到host-only网络以外的任何设备。\n端口转发(Port Forward) 端口转发是将寻址向某个IP地址和端口的流量转发到另一个不同的IP地址和端口的处理操作。服务器和其他路由设备上可以使用专门应用程序来实现端口转发。端口转发最常用的一个应用场景是为隐藏在NAT后边的特定的网络设备提供外部网络访问入口。\n配置完端口转发规则后，客户端可以通过连接路由器（或主机）外部IP地址和专用端口来访问特定的服务。网络包会首先被路由器上的一个应用程序所截获，然后这个应用程序会读取网络包头中的目的IP地址和端口号（IP包头，含有TCP或UDP段的包头）。如果包头中目的IP地址和端口号的组合能与端口转发规则集合中的某个条件匹配上，路由器程序就会重写包头中的信息（IP地址和/或端口号），并根据端口转发规则将包/段发送给另一个网络接口。\n默认情况下，VirtualBox宿主机和其他局域网中的主机不能访问网络适配器被设置成NAT或NAT Network模式-的VirtualBox虚拟机，但是VirutalBox提供了内置的端口转发特性支持了这种类型的访问。\n总结 ","date":"2023-09-20T16:57:00+08:00","image":"/lihan3238.github.io/p/virtualnetwork/netWork_hu2e58201f5858249f2f359c113ecfc733_13243_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/virtualnetwork/","title":"VirtualBox虚拟机几种网络的区别"},{"content":"项目简介\n根据中华人民共和国《网络安全法》相关政策规定，本文章只做学习测试，不被允许通过本文章技术手段进行非法行为，使用技术的风险由您自行承担(The author does not assume any legal responsibility.) https://github.com/euphrat1ca/security_w1k1 信息收集、攻击尝试获得权限、持久性控制、权限提升、网络信息收集、横向移动、数据分析（此基础上做持久化控制）、扫尾。 几千行的项目有点过于庞大，于是在第两百次更新的时候，选择把一些较为频繁的持续更新内容分到其它文件内。 分类标签：mywiki;intro;工具手册;通讯技术工具;威胁情报;恶意样本;自服务应用;研究技术;漏洞利用;web安全; 导航标签：一个人的安全部;awesome系列;类似于于**架构; 类型标签：模拟测试;* kali系统类;* ATT\u0026amp;CK矩阵类;作者拼音;Github:\\Web:\\Page:\\Connect;常见缩写; 状态标签：simple;noupdate;商业版;社区版; 测评标签：testjob;welljob;goodjob;greatjob;\n安全相关资源列表 https://arxiv.org //康奈尔大学（Cornell University）开放文档 https://github.com/sindresorhus/awesome //awesome系列 https://github.com/k4m4/movies-for-hackers //安全相关电影 http://www.owasp.org.cn/owasp-project/owasp-things //OWASP项目 https://github.com/Hack-with-Github/Awesome-Hacking //GitHub万星推荐：黑客成长技术清单 https://github.com/SecWiki/sec-chart //安全思维导图集合 https://github.com/Mayter/sec-charts //在sec-wiki的思维导图加上作者收藏 https://github.com/Ascotbe/Osmographic-brain-mapping //安全思维脑图。ctf/web/二进制/ai/区块链/业务/主机/社工/移动/无线/运维/风控 https://github.com/tom0li/collection-document //安全部/攻防/内网/Web/apt/漏洞预警/开发/Bug Bounty/SDL/SRC https://github.com/secure-data-analysis-data-sharing/data-analysis 资料分为安全态势、攻防对抗、数据分析、威胁情报、应急响应、物联网安全、企业安全建设、其他书籍八部分 https://github.com/hongriSec/AI-Machine-Learning-Security //机器学习算法、AI模型、渗透测试工具 https://github.com/bt3gl/Pentesting-Toolkit //CTF、逆向、移动端、网络安全、web安全、工具使用。welljob。 安全建设方案 https://www.nist.gov/topics/cybersecurity //美国国家标准与技术研究院。NVD漏洞库 https://www.mitre.org/publications/all //mitre安全机构。CVE漏洞库 https://www.alibabacloud.com/blog //阿里安全建设 https://security.tencent.com/index.php/blog/msg/139 //腾讯安全建设。网络空间安全时代的红蓝对抗建设 https://github.com/baidu-security //百度安全建设 https://ai.google/research/pubs/?area=SecurityPrivacyandAbusePrevention //谷歌安全建设 https://aws.amazon.com/cn/blogs/security/ //亚马逊安全建设 https://code.fb.com/category/security/ //Facebook安全建设 http://www.freebuf.com/articles/ics-articles/178822.html //浅析煤炭企业如何进行工控安全建设 https://www.sec-un.org/金融业企业安全建设之路/ //金融业企业安全建设之路。niejun https://blogs.cisco.com/tag/ios-security //思科网络设备操作维护系统IOS（互联网操作系统Internetwork Operating System） 安全实验室中心建设 https://www.freebuf.com/articles/es/211571.html //安全实验室的发展及展望 公众号：开篇|猪八戒安全建设漫谈 安全体系建设分享01期|目标、团队、考核 // https://bbs.ichunqiu.com/thread-53927-1-1.html //奇安信「实战攻防三部曲」要点总结。实战攻防之红蓝紫队 https://github.com/Leezj9671/offensiveinterview //安全/渗透测试/红队面试题.G:WebBreacher/offensiveinterview; 安全运营中心(SOC)建设 https://www.secrss.com/articles/8051 //谈一谈如何建设体系化的安全运营中心(SOC) http://www.freebuf.com/articles/network/169632.html //开源软件创建SOC的一份清单 http://paper.tuisec.win/detail/34ab12018f71e71 //个人总结的漏洞管理流程分享 https://www.secrss.com/articles/4088 //安全资产管理中容易被忽视的几点。niejun 公众号：评估一个新的安全数据源的有效性: Windows Defender 漏洞利用防护（上、下） 安全风控建设 https://github.com/threathunterX/nebula //LUA/PERL.威胁猎人开源\u0026quot;星云\u0026quot;业务风控系统 https://github.com/momosecurity/aswan //PY.陌陌风控系统静态规则引擎，零基础简易便捷的配置多种复杂规则，实时高效管控用户异常行为。 https://github.com/xdite/internet-security //互联网金融企业安全与风控的实战手册。资安风控 安全开发 https://github.com/FallibleInc/security-guide-for-developers //安全开发规范 https://www.securitypaper.org/ //SDL建设文档。开发安全生命周期管理 https://github.com/Hygieia/Hygieia //JS.Capitalone银行开源的DevOps利器 产品设计原型 https://www.fireeye.com/cyber-map/threat-map.html //FireEye公司“网络威胁地图” https://cybermap.kaspersky.com/ //卡巴斯基(Kaspersky)的“网络实时地图” http://www.digitalattackmap.com/ //Arbor networks的由全球270个ISPs匿名分享流量的“数字攻击地图” https://hubble.nexusguard.com //Nexusguard Hubble攻击地图 https://echarts.baidu.com/examples/index.html#chart-type-globe //Echart图 https://book.yunzhan365.com/dksd/oyru/mobile/index.html //基于攻击链的网络威胁捕猎架构设计 http://www.colasoft.com.cn/download/network-defense-map-2018.pdf //科来网络攻击与防范图谱 https://www.anquanke.com/post/id/178339 //漏扫动态爬虫实践。pyppeteer https://www.jianshu.com/p/852e0fbe2f4c //安全产品厂商分类 https://github.com/xianlimei/yiwei.github.io/wiki //私有云、区块链安全研究，rasp、waf、主机安全产品介绍 产品设计文档 https://www.freebuf.com/sectool/135032.html/ //构建一个高交互型的难以发现的蜜罐 https://bloodzer0.github.io/ossa/ //OSSA，利用开源文件进行开源安全架构.主机、扫描器、端口、日志、防护设备等 https://github.com/dvf/blockchain //用Python从零开始创建区块链 https://github.com/chryzsh/DarthSidious //从0开始你的域渗透之旅，包括搭建到渗透测试域环境。G:crazywa1ker/DarthSidious-Chinese; https://paper.seebug.org/772/ //如何使用 KittyFuzzer 结合 ISF 中的工控协议组件对工控协议进行 Fuzz https://paper.seebug.org/913/ //如何打造自己的PoC框架-Pocsuite3-框架篇。simple 安全基础科普培训 https://book.yunzhan365.com/umta/rtnp/mobile/index.html //网络安全科普小册子 https://book.yunzhan365.com/ybab/exnz/mobile/index.html //FP50 优秀网络安全解决方案 白皮书 http://sec.cuc.edu.cn/huangwei/textbook/ns/ //网络安全电子版教材。中传信安课程网站 https://space.bilibili.com/37422870 //入门安全视频 https://space.bilibili.com/406898187/channel/detail?cid=85655 //安全帮内网高级加固课程 https://ilearningx.huawei.com/portal/#/portal/EBG/26 //华为e学云。安全科普 https://github.com/tiancode/learn-hacking //网络安全入门文章集 https://keenlab.tencent.com/zh/index.html //腾讯科恩实验室 https://www.freebuf.com/articles/neopoints/190895.html //入门介绍。fuzz/漏挖/脚本 https://github.com/ym2011/SecurityManagement //分享安全管理体系、ISO27001、等级保护、安全评审的经验 https://null-byte.wonderhowto.com //msf/fb/wifi/pass/取证/social/信息收集 安全博客论坛 https://www.malwareanalysis.cn/ //安全分析与研究 专注于全球恶意样本的分析与研究 bbs.125.la/ 精易求精;52pojie.cn/ //吾爱破解 lcx.cc：NuclearAtk核总，文章/工具；blog.orange.tw：橘子出品必属精品 // https://github.com/DropsOfZut/awesome-security-weixin-official-accounts //网络安全类公众号推荐 https://www.lshack.cn //工控安全入门 安全大会资料 https://www.hackinn.com/search/?keyword= //资料站 https://www.hackinn.com/index.php/archives/492/ //HackingDay 2019 (中国杭州) http://www.irongeek.com/i.php?page=security/hackingillustrated //国内外安全大会相关视频与文档 https://github.com/knownsec/KCon //KCon大会文章PPT https://github.com/knownsec/RD_Checklist //知道创宇技能列表 https://github.com/ChrisLinn/greyhame-2017 //灰袍技能书2017版本 安全工具使用手册指导介绍 https://github.com/HarmJ0y/CheatSheets //多个项目的速查手册（Beacon / Cobalt Strike，PowerView，PowerUp，Empire和PowerSploit） https://www.cnblogs.com/backlion/p/10616308.html //Coablt strike官方教程中文译版本 https://github.com/aleenzz/Cobalt_Strike_wiki //Cobalt Strike系列教程。0.5k。 https://wizardforcel.gitbooks.io/kali-linux-web-pentest-cookbook/content/ //Kali Linux Web渗透测试秘籍 中文版 https://github.com/louchaooo/kali-tools-zh //kali下工具使用介绍手册 https://www.offensive-security.com/metasploit-unleashed/ //kali出的metasploit指导笔记 http://www.hackingarticles.in/comprehensive-guide-on-hydra-a-brute-forcing-tool/ hydra使用手册 https://www.gitbook.com/book/t0data/burpsuite/details //burpsuite实战指南 https://zhuanlan.zhihu.com/p/26618074 //Nmap扩展脚本使用方法 https://github.com/hardenedlinux/linux-exploit-development-tutorial //Linux exploit 开发入门 https://wizardforcel.gitbooks.io/asani/content //浅入浅出Android安全 中文版 https://wizardforcel.gitbooks.io/lpad/content //Android 渗透测试学习手册 中文版 Offensive Security全家桶 https://github.com/b1n4ry4rms/RedTeam-Pentest-Cheatsheets/ //常见工具命令 OSCP渗透测试 https://github.com/anandkumar11u/OSCP-60days //OSCP All Tools https://github.com/neal1991/OSCP_learing //oscp learning。tools、command https://github.com/foobarto/redteam-notebook //OSCP-EXAM 红队标准渗透测试流程+常用命令 https://github.com/gajos112/OSCP //OSCP-EXAM https://github.com/RustyShackleford221/OSCP-Prep //OSCP-EXAM https://github.com/lsh4ck/oscp //oscp历程。lshack.cn备战 https://0xdarkvortex.dev/index.php/2018/04/17/31-days-of-oscp-experience/ //31 days of OSCP Experience OSCE漏洞挖掘 https://www.freebuf.com/news/206041.html //中文首发丨OSCE（Offensive Security Certified Expert）考证全攻略 https://github.com/ihack4falafel/OSCE // https://github.com/dhn/OSCE // https://github.com/73696e65/windows-exploits // 安全运维 https://github.com/aqzt/kjyw //快捷运维，代号kjyw，项目基于shell、python，运维脚本工具库，收集各类运维常用工具脚本，实现快速安装、快速配置策略等。安全专题 https://github.com/aqzt/sso //服务器安全运维规范（Server security operation） https://github.com/imthenachoman/How-To-Secure-A-Linux-Server //Linux服务器保护。9k https://github.com/SwiftOnSecurity/sysmon-config //sysmon配置文件安装 https://github.com/trimstray/nginx-admins-handbook //nginx操作手册。8k https://github.com/valentinxxx/nginxconfig.io/ //在线nginx配置文件生成，demo网址https://nginxconfig.io 系统安全检查基线配置 https://www.open-scap.org/ //安全基线评估工具集 https://www.cisecurity.org/cis-benchmarks/ //CIS总结的140多种配置基准 https://github.com/Jsitech/JShielder //linux下服务器一键加固脚本 https://github.com/trimstray/linux-hardening-checklist //Linux服务器加固基线 https://github.com/a13xp0p0v/kconfig-hardened-check //用于检查 Linux 内核配置中的安全加固选项的脚本 https://github.com/wstart/DB_BaseLine //数据库基线检查工具 https://github.com/drduh/macOS-Security-and-Privacy-Guide //PY.MacOS安全性基线 安全服务checklist https://github.com/juliocesarfort/public-pentesting-reports //由几家咨询公司和学术安全组织发布的公共渗透测试报告的列表。 http://pentestmonkey.net/category/cheat-sheet //渗透测试常见条目 https://github.com/arunmagesh/hw_hacking_cheatsheet 硬件hardware测试条目 https://mp.weixin.qq.com/s/O36e0gl4cs0ErQPsb5L68Q //区块链，以太坊智能合约审计 CheckList https://github.com/slowmist/eos-bp-nodes-security-checklist //区块链，EOS bp nodes security checklist（EOS超级节点安全执行指南） https://github.com/0xRadi/OWASP-Web-Checklist //owasp网站检查条目 https://github.com/GitGuardian/APISecurityBestPractices //api接口测试checklist https://github.com/shieldfy/API-Security-Checklist //api开发核对清单。12k。 https://github.com/theLSA/CS-checklist //CS客户端安全检查checklist https://xz.aliyun.com/t/2089 //金融科技SDL安全设计checklist 汽车安全测试Checklist //水滴安全实验室 应急响应溯源 https://security.tencent.com/opensource/detail/19 腾讯开源的xSRC应急响应中心cms https://www.secrss.com/articles/10986 //一次攻防实战演习复盘总结。奇安信 https://github.com/Bypass007/Emergency-Response-Notes //应急响应实战笔记。应急响应/日志分析/僵木蠕分析。1.1k。 https://github.com/tide-emergency/yingji //PY2.查看主机状态/启动项/历史命令/用户特权/文件修改/异常IP等 https://github.com/trimstray/iptables-essentials //IP table常见防火墙规则与命令 https://github.com/ppabc/cc_iptables //收集处理DDOS、CC攻击各类脚本，包括NGINX日志中的CC攻击IP处理。 日志分析可视化 https://github.com/grafana/grafana //TypeScript,GO.用于可视化大型测量数据的开源程序，提供创建、共享、浏览数据方法与众多功能插件。greatjob。29.5k。 https://github.com/Cyb3rWard0g/HELK //Jupyter Notebooks.基于ELK(Elasticsearch, Logstash, Kibana)的日志威胁分析。1.5K。 https://github.com/JeffXue/web-log-parser //PY.web日志分析工具 https://github.com/JPCERTCC/LogonTracer //JS,PY.根据win登陆记录日志来分析并用图形化展示恶意登陆行为 https://github.com/jpcertcc/sysmonsearch //JS.将Sysmon的日志结果可视化 https://github.com/olafhartong/sysmon-cheatsheet //Sysmon操作手册，各id属性含义 https://github.com/baronpan/SysmonHunter //JS.针对att\u0026amp;ck对sysmon日志进行分析展示 https://github.com/zhanghaoyil/Hawk-I //PY.基于无监督机器学习算法从Web日志中自动提取攻击Payload https://github.com/JPCERTCC/LogonTracer //PY.日本计算机应急团队开源的关于Windows下登录日志的追踪溯源，网络信息格式化展示。Github:Releasel0ck/NetTracer;。 勒索病毒 https://github.com/jiansiting/Decryption-Tools //勒索病毒解决方案汇总 https://www.nomoreransom.org //在线勒索病毒解决方案 开源情报数据源分析 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_osint.md/ //开源情报数据源分析.mywiki 攻防技术资源 https://attack.mitre.org //mitre科技机构对攻击技术的总结wiki，攻击矩阵模型。 https://github.com/infosecn1nja/awesome-mitre-attack //Mitre ATT\u0026amp;CK™框架资源收集。Web:huntingday.github.io;G:lengjibo/ATT-CK-CN //att\u0026amp;ck实操实验记录;W:vulhub.org.cn/attack //att\u0026amp;ck汉化; https://github.com/Micropoor/Micro8 //Microporor高级攻防100课。goodjob。PHP安全新闻早8点课程 https://github.com/meitar/awesome-cybersecurity-blueteam // A curated collection of awesome resources, tools, and other shiny things for cybersecurity blue teams. https://bitvijays.github.io //infosec知识总结。goodjob。 https://github.com/Mel0day/RedTeam-BCS //BCS（北京网络安全大会）2019 红队行动会议重点内容，详细步骤。goodjob。 https://github.com/Snowming04/The-Hacker-Playbook-3-Translation //[译] 渗透测试实战第三版(红队版)The Hacker Playbook 3 https://github.com/OWASP/OWASP-Testing-Guide-v5 //OWASP 发布的渗透测试指南文档 https://github.com/jeansgit/RedTeam //RedTeam资料收集整理。红蓝对抗资料分享，红蓝对抗相关图片，内网安全渗透总结 https://github.com/yeyintminthuhtut/Awesome-Red-Teaming //优秀红队资源列表 https://github.com/Kinimiwar/Penetration-Testing //渗透测试方向优秀资源收集 https://github.com/jshaw87/Cheatsheets //渗透测试/安全秘籍/笔记 http://www.pentest-standard.org/index.php/Pre-engagement //渗透测试标准-渗透项目实施前的互动。项目实施前 https://github.com/r35tart/Penetration_Testing_Case //攻防测试案例 社工综合利用 https://www.freebuf.com/articles/102500.html //黑客讲述渗透Hacking Team全过程（详细解说） https://github.com/myselfexplorer/hackingLibrary //社工大佬的笔记手册 https://payloads.online/archivers/2019-05-21/1 //鱼叉攻击-尝试。qingxuan https://github.com/shegongbook/shegonganli //社工案例 Web漏洞攻防 https://portswigger.net/web-security //burpsuite官方web安全材料与实验室。testjob。 https://wizardforcel.gitbooks.io/web-hacking-101/content //Web Hacking 101 中文版 https://websec.readthedocs.io/zh/latest/ //Web安全学习笔记 https://techvomit.net/web-application-penetration-testing-notes/ //web渗透测试笔记 https://github.com/qazbnm456/awesome-web-security //Web安全资料和资源列表 https://www.lynda.com/JavaScript-tutorials/What-server-side-JavaScript-injection-SSJI/797717/5025838-4.html //SSJI服务的JavaScript注入 https://www.imperva.com/blog/nosql-ssji-authentication-bypass/ //SSJI服务的JavaScript注入 内网安全后渗透 https://attack.mitre.org/wiki/Lateral_Movement //mitre机构对横向移动的总结 https://github.com/l3m0n/pentest_study //从零开始内网渗透学习。G:Ridter/Intranet_Penetration_Tips;. https://github.com/uknowsec/Active-Directory-Pentest-Notes //个人域渗透学习笔记。配合域环境。goodjob。 公众号：域渗透 | Kerberos攻击速查表 // https://github.com/infosecn1nja/AD-Attack-Defense //AD活动目录攻击链与防御 https://github.com/nccgroup //国外安全咨询团队，burp插件的编写、内网利用工具、app安全工具 https://adsecurity.org //Active Directory安全攻防 https://3gstudent.github.io //AD域渗透/DNS/可信目录/横向移动。G:klionsec.github.io;。 https://daiker.gitbook.io/windows-protocol //本系列文章将针对内网渗透的常见协议(如kerbeos,ntlm,smb,ldap等)进行协议分析，相关漏洞分析以及漏洞工具分析利用。Windows凭证利用。W:彻底理解Windows认证 - 议题解读;。 https://www.anquanke.com/post/id/87976 //Powershell攻击指南黑客后渗透之道系列——基础篇\\进阶利用\\实战篇 漏洞挖掘复现分析 https://googleprojectzero.blogspot.com //谷歌Google Project Zero博客 https://github.com/ngalongc/bug-bounty-reference 漏洞挖掘write-up https://github.com/1hack0/bug-bounty-101 //挖洞技术手册 https://github.com/writeups/ios //ios漏洞writeup笔记 https://github.com/userlandkernel/plataoplomo //Sem Voigtländer 公开其发现的 iOS 中各种漏洞，包括（Writeup/POC/Exploit） https://github.com/Ivan1ee/NET-Deserialize //.Net反序列化漏洞 https://github.com/SCUBSRGroup/Automatic-Exploit-Generation //自动化软件漏洞发掘 https://github.com/offensive-security/exploitdb //美国Offensive Security的exploit-db.com漏洞库。kali团队，包含插件、漏洞环境等。 https://bugreader.com //国外知名厂商公开漏洞详情 https://blog.intigriti.com //intigriti公司bug bounty文章和公开漏洞详情 https://hackerone.com/hacktivity //HACKER ONE公开漏洞详情 https://dvpnet.io/lddt //DVP去中心化漏洞平台公开漏洞详情 https://sec.ly.com/bugs //同程安全公开漏洞详情 https://zeroday.hitcon.org/vulnerability/ //台湾公开漏洞库 常用漏洞库/SRC/BugBounty https://sploitus.com //公开漏洞搜索引擎。gOODjob。 twitter搜索“#exploit”、“#0day”、“CVE RCE” // https://github.com/raminfp/linux_exploit_development //linux漏洞利用开发手册 https://shuimugan.com //2016/06/24 13:25之前，乌云Drops文章，公开漏洞详情 https://0day.life //漏洞研究文章 https://blog.ripstech.com/filter/vulnerabilities/ //Bitbucket是Atlassian开发的版本控制软件与漏洞挖掘教程 http://ics.cnvd.org.cn //中国国家工控漏洞库 https://ics-cert.us-cert.gov/advisories //美国国家工控漏洞库 http://www.nsfocus.net/index.php?act=sec_bug //绿盟漏洞库，含工控 http://ivd.winicssec.com/ //威努特工控漏洞库 http://cve.scap.org.cn/view/ics //CVE中文工控漏洞库 https://cve.mitre.org/cve/search_cve_list.html //美国MITRE公司负责维护的CVE漏洞库 https://nvd.nist.gov/vuln/search //美国国家信息安全漏洞库 https://exchange.xforce.ibmcloud.com //IBM exchange漏洞库 https://www.zerodayinitiative.com/ //设备（firmware）漏洞市场 http://www.zerodium.com/ //灰色漏洞交易平台0day市场 https://0day.today //漏洞市场 BugBounty文章 https://github.com/xiangpasama/JDSRC-Small-Classroom //京东SRC小课堂系列文章 漏洞复现 https://github.com/vulhub/vulhub //Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，执行两条命令即可编译、运行一个完整的漏洞靶场镜像.4k。goodjob。 http://vulnstack.qiyuanxuetang.net/ //红日安全红队演练环境。P:从外网到域控（vulnstack靶机实战）; https://github.com/Medicean/VulApps //收集各种漏洞环境，为方便使用，统一采用 Dockerfile 形式。同时也收集了安全工具环境。 https://github.com/c0ny1/vulstudy //使用docker快速搭建dvwa等各大漏洞学习平台 https://github.com/bingohuang/docker-labs //制作在线docker平台 离线靶场学习 https://www.soteria-int.com/ //西班牙游戏竞技模拟平台CYWARIA安全靶场，商业。 https://www.vulnhub.com //实验室、靶场、ctf靶机汇总，离线真实环境 https://github.com/WebGoat/WebGoat //JAVA.一键jar包web安全实验靶场 https://github.com/Audi-1/sqli-labs //PHP.基于SQLite的sql注入学习靶场 https://github.com/lcamry/sqli-labs //INTRO.通过sqli-labs演示mysql相关的注入手法 https://github.com/virusdefender/ssrf-app //PY.服务端请求伪造ssrf靶场实例 https://github.com/c0ny1/upload-labs //PHP.一个帮你总结所有类型的上传漏洞的靶场 https://github.com/LandGrey/upload-labs-writeup //INTRO.upload-labs指导手册 https://github.com/c0ny1/xxe-lab //一个包含php，JAVA.python，C#等各种语言版本的XXE漏洞Demo https://github.com/Go0s/LFIboomCTF //本地文件包含漏洞\u0026amp;\u0026amp;PHP利用协议\u0026amp;\u0026amp;实践源码 https://github.com/incredibleindishell/CORS-vulnerable-Lab //PHP.与COSR配置错误相关的漏洞代码靶场 https://in.security/lin-security-practise-your-linux-privilege-escalation-foo/ //一个虚拟机文件用于linux提权练习 https://github.com/secvulture/dvta //CS客户端靶场 https://github.com/OWASP/igoat //适用于ios应用程序测试和安全性的学习工具 https://github.com/prateek147/DVIA-v2 //适用于ios应用程序测试和安全性的学习工具 https://github.com/abhi-r3v0/EVABS //C++.Android靶场联系 https://github.com/ethicalhack3r/DVWA //web安全实验靶场。新手指南：DVWA-1.9全级别教程 http://www.itsecgames.com //bWAPP,bee-box。包含owasp10，心脏滴血hearbleed等环境。noupdate https://github.com/bkimminich/juice-shop //常见web安全实验靶场市场 https://github.com/78778443/permeate //php.常见漏洞靶场 https://github.com/gh0stkey/DoraBox //php.常见漏洞靶场 https://github.com/stamparm/DSVW //PY2.常见漏洞靶场 https://github.com/amolnaik4/bodhi //PY.常见漏洞靶场 https://github.com/Safflower/Solve-Me //php.韩国一个偏代码审计的ctf靶场源码 https://github.com/rapid7/metasploitable3 //metasploit练习系统 https://github.com/rapid7/metasploit-vulnerability-emulator //perl.metasploit模拟环境，练习操作 在线靶场学习 https://www.hackthebox.eu //欧洲HTB靶场，在线真实环境 https://www.root-me.org //俄罗斯root me靶场。在线。社区版 https://lab.pentestit.ru //俄罗斯靶场，真实环境。在线。商业版。 https://www.offensive-security.com/information-security-certifications/ //kali攻防技术认证。商业版。 https://www.pentesteracademy.com //教程+视频+实验室+认证培训一套。商业版。 https://www.cybrary.it //网络安全工程师认证。CTF/Labs https://www.wechall.net //世界知名ctf汇总交流网站 https://www.ichunqiu.com/experiment/direction //i春秋实验室。Web/主机/应用/pwn教程 https://www.mozhe.cn/bug //墨者学院在线靶场。Web/主机/数据库/取证 https://www.xssgame.com //谷歌XSS挑战 http://xss.tv //在线靶场。;ctf.bugku.com;adworld.xctf.org.cn Fuzzer模糊测试 工控模糊测试Wurldtech Achilles阿基里斯国际认证 http://www.freebuf.com/articles/rookie/169413.html //一系列用于Fuzzing学习的资源汇总 https://github.com/secfigo/Awesome-Fuzzing //Fuzzing模糊测试相关学习资料 https://github.com/fuzzdb-project/fuzzdb //fuzz资料数据库 https://github.com/googleprojectzero/winafl //C.Google Project Zero 基于Windows AFL开发的模糊测试框架。原创技术分析-AFL漏洞挖掘技术漫谈 http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/ //intro.AFL使用指南 https://github.com/mxmssh/drAFL //C.Linux模糊测试。G:atrosinenko/kbdysch;G:google/oss-fuzz; https://github.com/zyw-200/FirmAFL //C.针对iot固件IoT firmware灰盒模糊测试 https://github.com/MozillaSecurity/peach //PY3.MozPeach是Peach v2.7的一个分支，由Mozilla Security维护。网络协议、web接口、文件格式模糊测试。W:peach.tech;G:TideSec/Peach_Fuzzing; https://github.com/cisco-sas/kitty //PY.针对TCP/IP的模糊测试框架。goodjob https://github.com/cisco-sas/katnip //PY.kitty框架的拓展库 https://github.com/jtpereyda/boofuzz //PY.基于OpenRCE/sulley框架二次开发的网络协议fuzz测试。 https://github.com/k0keoyo/kDriver-Fuzzer //C.基于ioctlbf框架编写的驱动漏洞挖掘工具kDriver Fuzzer https://github.com/google/honggfuzz //C.具有反馈驱动（Feedback-Driven）的持续性软件代码测试。2k。 https://github.com/bunzen/pySSDeep //PY.一个基于模糊哈希（Fuzzy Hashing）算法的工具。G:glaslos/ssdeep;G:ssdeep-project/ssdeep https://github.com/xmendez/wfuzz //PY.Web安全模糊测试工具，模块化可处理burp所抓请求和响应报文。goodjob,2k。 https://github.com/1N3/BlackWidow //PY.利用爬虫收集目标网站的情报信息并对 OWASP 漏洞进行模糊测试 https://bbs.ichunqiu.com/thread-24898-1-1.html //Test404 -HTTP Fuzzer V3.0 http://blog.topsec.com.cn/alphafuzzer/ //启明星辰阿尔法实验室以文件格式为主的漏洞挖掘工具 二进制学习pwn利用 https://www.52pojie.cn/thread-709699-1-1.html //160个CrackMe，附破解方法 https://github.com/euphrat1ca/0day-security-software-vulnerability-analysis-technology //0day安全：软件漏洞分析技术（第2版） 漏洞战争：软件漏洞分析精要 // 加密与解密（第4版） // modern windows exploit // cnit的二进制教程 // awesome windows exploit // https://www.youtube.com/channel/UC_PU5Tk6AkDnhQgl5gARObA //pwn学习三部曲学习 https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/page/4/ //exploit编写系列教程,10篇,后续在corelan网站上 https://www.fuzzysecurity.com/tutorials.html //fuzzysecurity教程。*egghunter http://www.securitysift.com/windows-exploit-development-part-1-basics // http://security.cs.rpi.edu/courses/binexp-spring2015/ //家用路由器0day https://github.com/timip/OSEE // https://www.youtube.com/watch?v=8zBpqc3HkSE\u0026list=PLhx7-txsG6t6n_E2LgDGqgvJtCHPL7UFu //windbg教程 https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg //windbg https://rootkits.xyz/blog/ //windows内核系列 https://github.com/saaramar/35C3_Modern_Windows_Userspace_Exploitation // https://pwnrip.com/windows-kernel-exploitation-part-1-stack-buffer-overflows/ //windows kernel exploit https://github.com/yeyintminthuhtut/Awesome-Advanced-Windows-Exploitation-References // https://github.com/ExpLife0011/awesome-windows-kernel-security-development //一些较新的win exploit资料 https://www.abatchy.com/tutorials //windows kernel exploit https://blahcat.github.io/tutorials/ //windows kernel exploit https://b3n7s.github.io/2017/11/01/windows-kernel-debugging-under-vmware-fusion.html //windows kernel debugging under vm fusion http://samdb.xyz/ //intro to kernel exploit https://github.com/hanc00l/rop_linux_kernel_pwn // https://github.com/xairy/linux-kernel-exploitation // https://azeria-labs.com/ //arm 溢出 https://github.com/Ma3k4H3d/Papers //AI/二进制逆向 技术手段利用方式工具集合 https://github.com/infosecn1nja/Red-Teaming-Toolkit //红队开源和商业工具。goodjob。 https://github.com/redcanaryco/atomic-red-team //Atomic Red Team团队关于win、linux、mac等多方面apt利用手段、技术与工具集。2k。 https://github.com/blaCCkHatHacEEkr/PENTESTING-BIBLE //红队工具、攻击手段 https://github.com/toolswatch/blackhat-arsenal-tools //blackhat工具集 https://github.com/demonsec666/Security-Toolkit //渗透攻击链中常用工具及使用场景 https://github.com/n00py/ReadingList/blob/master/gunsafe.txt //安全工具集 https://github.com/k8gege/ //K8工具合集(内网渗透/提权工具/远程溢出/漏洞利用/扫描工具/密码破解/免杀工具/Exploit/APT/0day/Shellcode/Payload/priviledge/BypassUAC/OverFlow/WebShell/PenTest) Web GetShell Exploit(Struts2/Zimbra/Weblogic/Tomcat/Apache/Jboss/DotNetNuke/zabbix)。博客cnblogs.com/k8gege，常见解压密码Kk8team，Kk8gege。 https://www.parrotsec.org //鹦鹉安全操作系统。pentest kali系统类。 https://github.com/fireeye/commando-vm //FireEye开源CommandoVM，专为红队（pen-testing）定制的Windows。W:blackwin.ir,WINDOWS kali系统类; https://github.com/theLSA/hack-cs-tools //CS客户端测试工具，配合客户端checklist https://github.com/kabachook/k8s-security/ //bash/py.Kubernetes安全集合 https://github.com/microsoft/WindowsProtocolTestSuites //C#.针对Windows开发规范的Windows协议测试套件 https://github.com/ConsenSys/mythril-classic //用于以太坊智能协议的安全分析工具 https://github.com/lionsoul2014/ip2region //ip地址定位库，支持python3等多接口。类似于于geoip架构 https://github.com/ultrasecurity/webkiller //PY.渗透辅助。ip信息、端口服务指纹、蜜罐探测、bypass cloudflare https://github.com/medbenali/CyberScan //PY.渗透测试辅助工具。支持分析数据包、解码、端口扫描、IP地址分析等 https://github.com/opensec-cn/vtest //PY.用于辅助安全工程师漏洞挖掘、测试、复现，集合了mock、httplog、dns tools、xss，可用于测试各类无回显、无法直观判断或特定场景下的漏洞。 https://github.com/ismailtasdelen/hackertarget //PY.Use open source tools and network intelligence to help organizations with attack surface discovery and identification of security vulnerabilities. https://technitium.com/ //点对点加密聊天、mac地址修改、dns客户端与服务端、https https://github.com/feross/SpoofMAC //PY.跨平台mac修改 IPv6安全相关 https://github.com/sfan5/fi6s //ipv6端口快速扫描器 https://github.com/fgont/ipv6toolkit //C.si6networks.com组织的ipv6工具集 https://github.com/lavalamp-/ipv666 //GO.ipv6地址枚举扫描 https://github.com/christophetd/IPv6teal //PY.利用ipv6隐蔽隧道传输数据 信息保护隐匿流量洋葱路由 https://github.com/leitbogioro/Fuck_Aliyun //关闭阿里云监控服务 https://github.com/Nummer/Destroy-Windows-10-Spying //DWS用来关闭windows监控服务 https://github.com/JusticeRage/freedomfighting //日志清理、文件共享、反向shell https://github.com/Rizer0/Log-killer //日志清除，Windows/Linux 服务器中的所有 https://github.com/360-A-Team/EventCleaner //日志擦除工具 https://github.com/s-rah/onionscan //darkweb暗网爬虫 https://github.com/globaleaks/Tor2web //darkweb暗网代理服务器，将onion的服务变为普通的服务 https://github.com/milesrichardson/docker-onion-nmap //使用nmap扫描Tor网络上隐藏的\u0026quot;onion\u0026quot;服务 https://github.com/GouveaHeitor/nipe //一个使所有流量通过Tor网络发出的脚本 https://github.com/Edu4rdSHL/tor-router //bash.使用tor代理全部流量。dnsleaktest.com dns检测。 https://github.com/trimstray/multitor //bash.启用多个TorBrowser通道转发流量，并设置负载均衡 https://github.com/NullArray/NetSet //bash.终端多路复用器，其会话通过Tor路由，并通过自动安装和配置DNSCrypt-proxy来保护DNS流量。 容器安全 https://vulnerablecontainers.org //对公开docker容器镜像漏洞扫描，并标出CVE号 https://github.com/P3GLEG/WhaleTail //根据docker镜像生成成dockerfile https://github.com/cr0hn/dockerscan //docker扫描工具 https://github.com/knqyf263/trivy //GO.针对容器的漏洞扫描器.2K。 测试字典集 https://github.com/tarraschk/richelieu //.fr邮箱密码表 https://github.com/TheKingOfDuck/fuzzDicts/ //Web Pentesting Fuzz 字典。G:xmendez/wfuzz/tree/master/wordlist;G:We5ter/Scanners-Box;G:shack2/SNETCracker/dic; https://github.com/danielmiessler/SecLists //用户名，密码，URL，敏感数据模式，模糊测试负载，Web shell。G:7dog7/bottleneckOsmosis;G:Ridter/Pentest;。 https://github.com/alpha1e0/pentestdb //WEB渗透测试数据库。用于提供渗透测试的辅助工具(pentest-tool)、资源文件 https://github.com/brannondorsey/PassGAN //PY.深度学习，密码字典样本生成 https://github.com/Mebus/cupp //PY.根据用户习惯密码生成弱口令探测 https://github.com/Saferman/cupper //PY.根据用户习惯密码生成弱口令探测，楼上升级 https://github.com/LandGrey/pydictor //PY3.特定密码字典生成 https://github.com/HongLuDianXue/BaiLu-SED-Tool //pascal.白鹿社工字典生成器 程序功能模块库 https://github.com/Microsoft/SymCrypt Windows使用的核心功能加密库 https://github.com/unknownv2/CoreHook //C#.基于.NET Core运行时实现的Windows HOOK库 https://github.com/boy-hack/hack-requests //PY3.python包模块。burp数据包重放、线程安全、底层包日志分析 https://github.com/saghul/aiodns/ //PY.请求后无需关闭连接的情况下有效地进行多次调用的DNS解析器 相关工具拓展插件 菜刀相关工具 https://github.com/AntSword-Store/ //中国蚁剑插件市场 https://github.com/yzddmr6/as_webshell_venom //js.免杀webshell无限生成工具蚁剑版 https://github.com/Ch1ngg/CaidaoMitmProxy //PY3.基于HTTP代理中转菜刀过WAF,基于菜刀20160622版本修改和测试。 https://github.com/ekgg/Caidao-AES-Version //Burp插件.用AES算法透明加密菜刀的http数据流 burpsuit相关工具拓展插件 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_burpsuite.md/ //burpsuite插件收集.mywiki https://github.com/PortSwigger //burpsuite官方插件库。商业版。 CobaltStrike相关工具拓展插件 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_Cobaltstrike.md/ //cobaltstrike插件收集.mywiki https://www.cobaltstrike.com/aggressor-script/index.html //脱离MSF之后的Aggressor Script 成为了开源脚本引擎 Cortana 的接班人 https://github.com/verctor/CS_xor64 //JAVA.生成cobaltstrike破解版所需的xor64.bin https://github.com/Mr-Un1k0d3r/SCT-obfuscator //Cobalt Strike SCT有效载荷混淆器 https://github.com/dcsync/pycobalt //PY3.Python API for Cobalt Strike kali环境拓展插件 https://github.com/Manisso/fsociety //类似于于kali架构Linux下工具包一键安装工具 https://github.com/LionSec/katoolin //使用linux服务器自动安装kali工具包 https://github.com/TrustedSec/ptf/ //PY.基于Debian/Ubuntu/ArchLinux下的测试工具安装管理工具 https://github.com/koenbuyens/kalirouter 将kali设置为一个路由流量分析系统 https://github.com/secforce/sparta //PY.界面化，联动Nmap、Nikto、Hydra等工具 https://github.com/skavngr/rapidscan //PY2.simple，联动kali下工具，漏洞扫描工具 https://github.com/baguswiratmaadi/reverie //BASH.ParrotSecOs联动工具 Nessus相关工具拓展插件 https://github.com/se55i0n/Awvs_Nessus_Scanner_API //扫描器Awvs 11和Nessus 7 Api利用脚本 https://github.com/DanMcInerney/msf-autoshell //配合nessus扫描结果进行msf攻击 https://github.com/MooseDojo/apt2 //联动nmap、nessus等工具进行安全测试 awvs相关工具拓展插件 https://www.52pojie.cn/thread-214819-1-1.html //awvs10.5开发框架破解版。商业版。 https://github.com/fnmsd/awvs_script_decode //awvs10.5规则scripts解密版，SDK，开发手册 https://github.com/NS-Sp4ce/AWVS11.X-Chinese-Version //JS.awvs11汉化包 https://github.com/l3m0n/awvs_190703137 //PY.Linux版awvs https://github.com/grayddq/PublicSecScan //PY.调用awvsAPI对WEB资产进行分布式WEB安全扫描，发现web环境下常规的一些安全漏洞 sqlmap相关工具拓展插件 https://github.com/codewatchorg/sqlipy //burp与sqlmap联动插件 https://github.com/RicterZ/websocket-injection //PY2.WebSocket 中转注入工具 https://github.com/Hood3dRob1n/SQLMAP-Web-GUI //PHP.sqlmap的web gui https://github.com/KINGSABRI/sqlmap-tamper-api //利用各种语言来编写sqlmapTamper https://github.com/0xbug/SQLiScanner //一款基于sqlmapapi和Charles（青花瓷）的被动SQL注入漏洞扫描工具 https://github.com/fengxuangit/Fox-scan //基于sqlmapapi的主动和被动资源发现的漏洞扫描工具 https://github.com/UltimateHackers/sqlmate //在sqlmap基础上增加了目录扫描、hash爆破等功能 https://github.com/ysrc/GourdScanV2 //ysrc出品的被动式漏洞扫描工具，基于sqlmapapi https://github.com/zt2/sqli-hunter //基于sqlmapapi，ruby编写的漏洞代理型检测工具 https://github.com/jesuiscamille/AutoSQLi //利用DorkNet，Googler， Ddgr， WhatWaf 和 sqlmap自动注入 nmap相关工具拓展插件 https://github.com/Ullaakut/nmap //GO.Nmap调用库go https://github.com/savon-noir/python-libnmap //PY.nmap调用库python https://github.com/johnnyxmas/scancannon //BASH.联动masscan和nmap https://github.com/cldrn/nmap-nse-scripts //NSE收集列表 https://github.com/vulnersCom/nmap-vulners //使用nmap扫描常见的服务漏洞 https://github.com/s4n7h0/Halcyon //Nmap Script (NSE)IDE编辑器 https://github.com/m4ll0k/AutoNSE //NSE自动化利用 https://github.com/vulnersCom/nmap-vulners //lua.NSE利用 Vulners.com API将相关漏洞信息评分返回 https://github.com/Rvn0xsy/nse_vuln //Nmap扫描漏洞利用脚本。tomcat任意文件上传漏洞CVE-2017-12615、weblogic、http（CVE-2017-12615/CNVD-C-2019-4814/CVE-2018-2894） https://github.com/Screetsec/Dracnmap //BASH.将Nmap复杂的命令进行一定程度的集成与简化，使新用户更加容易上手。 https://github.com/cldrn/rainmap-lite //DjanGO.Web版Nmap，可以建立新的扫描服务器，允许用户从他们的手机/平板电脑/网络浏览器启动Nmap扫描 https://github.com/trimstray/sandmap //BASH.linux下Nmap可配置形式的命令行操作台 https://github.com/scipag/vulscan //基于nmap的高级漏洞扫描器，命令行环境使用 https://github.com/Rev3rseSecurity/WebMap //将nmap的xml web展示器 https://github.com/m0nad/HellRaiser //基于nmap的扫描器，与cve漏洞关联 https://github.com/materaj/nmap-parser-xml-to-csv //PY.Nnmap结果xml转换到csv https://github.com/DanMcInerney/msf-autopwn //执行NMap扫描或读取扫描结果， 然后自动使用msf攻击包含常见漏洞的主机 https://github.com/rootlabs/nWatch //联动nmap，并对组织内网进行扫描 https://github.com/Yukinoshita47/Yuki-Chan-The-Auto-Pentest //集成子域名枚举、nmap、waf指纹识别等模块的web应用扫描器 https://github.com/ring04h/wyportmap //调用nmap目标端口扫描+系统服务指纹识别 https://github.com/cloudflare/flan //PY.cloudflare基于nmap开发的漏洞检测工具 metasploit相关工具拓展插件 https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit //结合机器学习与msf的全自动测试工具 https://github.com/r00t-3xp10it/Meterpreter_Paranoid_Mode-SSL //一个可以创建SSL/TLS shell连接的脚本 https://github.com/DanMcInerney/msf-netpwn //等待msf的session，并自动提为域管理 https://github.com/NullArray/AutoSploit //利用Shodan API搜索引擎收集目标， 并自动调用设定的msf模块对目标发动攻击 https://github.com/WazeHell/metateta //使用msf脚本，根据特定协议进行扫描 https://github.com/fbkcs/msf-elf-in-memory-execution //Metasploit模块， 用于在内存中执行ELF文件 https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit //metasploit双星攻击利用文件 https://github.com/darkoperator/Metasploit-Plugins //msf扩展资产搜集与帮助插件 https://github.com/D4Vinci/One-Lin3r //metasploit、payload辅助查询工具 https://github.com/shizzz477/msploitego //将msf数据库与maltego进行图形化展示 https://github.com/scriptjunkie/msfgui //metasploit的GUI界面，强化Windows下支持 https://github.com/Zerx0r/Kage //VueJS.图形化MSF的GUI界面，Session Handler控制。 Empire相关工具拓展插件 https://paper.tuisec.win/detail/f3dce68a0b4baaa //利用Empire获取域控权限 https://github.com/EmpireProject/Empire-GUI //empire的nodejs界面 https://github.com/interference-security/empire-web //empire的web界面 https://github.com/byt3bl33d3r/DeathStar //PY3.调用Empire RESTful API 自动化获取域管权限的 https://byt3bl33d3r.github.io/ //automating-the-empire-with-the-death-star-getting-domain-admin-with-a-push-of-a-button.html //DeathStar教程 https://github.com/infosecn1nja/e2modrewrite //用于将Empire配置文件转换为Apache modrewrite脚本 端口转发映射代理穿透 https://github.com/fatedier/frp //Golang.用于内网穿透的高性能的反向代理应用，多协议支持，支持点对点穿透，范围端口映射。greatjob,25k。 https://github.com/inconshreveable/ngrok //GO.端口转发，正反向代理，内网穿透.17K。 https://github.com/cnlh/nps //GO.内网穿透代理服务器。支持tcp、udp流量转发，支持内网http代理、内网socks5代理，同时支持snappy压缩、站点保护、加密传输、多路复用、header修改等。支持web图形化管理，集成多用户模式。 https://github.com/sensepost/reGeorg //PY.reDuh 的升级版，主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口（提供了php，asp，jsp脚本的正反向代理）。1K。G:nccgroup/ABPT 全加密; https://github.com/SECFORCE/Tunna //PY.将TCP协议通过HTTP封装传递，可以用于绕过防火墙环境中的网络限制。 https://github.com/vzex/dog-tunnel //GO.Linux下基于kcp的p2p端口映射工具，同时支持socks5代理。1.6k。 https://github.com/davrodpin/mole //GO.基于ssh的端口转发。 https://github.com/fbkcs/thunderdns //PY.将tcp流量通过DNS协议转发，不需要客户端和socket5支持。 https://github.com/securesocketfunneling/ssf //C++.TCP/UDP端口转发、socks代理、remote远程shell。 https://github.com/ls0f/gortcp //GO.内网穿透、远程文件上传下载、命令执行.Github:rtcp;Github:NATBypass; https://github.com/Dliv3/Venom //GO.类似于于Termite/EarthWorm架构的多节点连接跳板构建多级代理工具 https://github.com/decoder-it/psportfwd //PowerShell.无需admin权限进行端口转发 代理端口复用 https://nets.ec/Shellcode/Socket-reuse //C.套接字重用\nhttps://github.com/earthquake/UniversalDVC //C++.利用动态虚拟通道注册dll文件，进行rdp服务端口复用 https://github.com/cloudflare/mmproxy //C.在负载均衡HAProxy代理的基础上支持proxy-protocol协议，可以传递客户端TCP协议的真实IP。配合Netsh、Iptables实现端口复用。 https://github.com/BeetleChunks/redsails //PY/C++.利用WinDivert驱动程序与windows内核交互，不更改端口开放状态进行端口复用TCP流量到另一个主机，在目标主机上执行命令且无需创建任何事件日志以及网络连接，可使用powershell。testjob。 代理池 https://github.com/SpiderClub/haipproxy //PY3.Scrapy and Redis，高可用ip代理池 https://github.com/chenjiandongx/async-proxy-pool //py3.异步爬虫ip代理池 https://github.com/audibleblink/doxycannon //PY.使用一个openvpn代理池，为每一个生成docker，当连接某一个vpn后，其它的进行socks5转发做流量分发 Cross超越边界自组网 https://github.com/ToyoDAdoubi/doubi //各种常用一键脚本 https://github.com/teddysun/across //BASH.npv、bbr、kms等脚本 https://github.com/Nyr/openvpn-install //openvpn一键安装 https://github.com/quericy/one-key-ikev2-vpn //CentOS/Debian/Ubuntu一键安装IPSEC/IKEV2 VPN脚本 http://www.vpngate.net //日本国立筑波大学云局域网 https://github.com/zerotier //C++.网络虚拟化平台云自组网 https://github.com/bannedbook/fanqiang/wiki //cross汇总 https://www.wireguard.com/install/ //新一代npv协议 https://github.com/teddysun/shadowsocks_install //shadowsocks/shadowsocksr https://github.com/guyingbo/shadowproxy //ss/socks5/http//https等多种代理 https://github.com/shadowsocks/shadowsocks-manager //shadowsocks多用户管理 https://github.com/leitbogioro/SSR.Go //shadowsocksrr配置管理简化工具 https://github.com/Ehco1996/django-sspanel //基于Django的shadowsocks网络面板 https://github.com/ssrpanel/SSRPanel //ss\\ssr\\v2ray用户分布式管理 https://github.com/xuanhuan/ss-panel //ss用户分布式管理 https://github.com/Ahref-Group/SS-Panel-smarty-Edition //ss用户分布式管理，兑换码功能、商城系统，服务器信息 https://github.com/txthinking/brook //GO.支持Linux/MacOS/Windows/Android/iOS的代理与vpn https://github.com/Ccapton/brook-web //brook程序服务端Web后台管理服务器（Linux\\MacOS），基于python、flask、flask-restful https://github.com/Ccapton/brook-ok //bash.Brook一键安装脚本 https://github.com/v2ray //GO.多协议代理 https://github.com/gwuhaolin/lightsocks //轻量级网络混淆代理，基于 SOCKS5 协议，类SS https://github.com/Umbrellazc/BypassCampusNet //校园网防断网; UDP 53 免流上网 https://github.com/netchx/Netch //C#.类似于sockscap64通过进程选择代，通过虚拟网卡转为类VPN全局代理SSTAP，替代方案proxifier。 https://github.com/ntkernel/lantern //unlimited-landeng-for-win，无限流量蓝灯 https://www.psiphon3.com //开源赛风超越边界代理 https://hide.me //npv可试用 https://windscribe.com //npv可试用 https://mono.sh //飞机场 https://www.radmin-vpn.cn/ 花生壳蒲公英teamviewer内网穿透 https://ding-doc.dingtalk.com/doc#/kn6zg7/hb7000 //G:open-dingtalk/pierced 钉钉内网穿透 信息搜集OSINT http://www.scribd.com/document/72008744/OSINT-Cheat-Sheet //OSINT Cheat Sheet信息收集技巧 https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php //JAVA.多维度信息收集，支持扩展不同社交媒体插件。 https://github.com/smicallef/spiderfoot //PY.利用OSINT自动化找出对方信息，gui界面，插件化，在线SpiderFoot HX服务。2K。greatjob。 https://github.com/Nhoya/gOSINT //GO.利用OSINT自动化搜集信息 https://github.com/alienwithin/OWASP-mth3l3m3nt-framework //渗透辅助，php，exp搜寻、payload与shell生成、信息收集 https://github.com/yassineaboukir/Asnlookup //simple。利用ASN搜索特定组织拥有ip，联动nmap、masscan进行进一步信息扫描 https://github.com/super-l/superl-url //PY.根据关键词，对搜索引擎内容检索结果的网址内容进行采集 https://github.com/woj-ciech/Danger-zone //关联域名、IP 和电子邮件地址之间的数据并将其可视化输出 https://github.com/HurricaneLabs/machinae //PY.ip/url/file/email/dns/hash/domain多接口 https://github.com/gh0stkey/ahrid //py.利用jsonp等漏洞通过分析模块对黑客画像溯源 在线信息搜集网站 https://shodan.io //互联网感知引擎.W:https://www.zoomeye.org/;W:https://fofa.so/;W:https://censys.io/; https://www.oshadan.com //傻蛋联网设备搜索，湖南安数网络。NOupdate。 https://hackertarget.com/ip-tools/ //提供api、ip相关工具，在线扫描器，工具文章研究博客。W:http://tools.bugscaner.com/; https://safeweb.norton.com //诺顿网站安全检测 http://www.link114.cn/title/ //批量查询网站标题 https://www.whatweb.net/ //在线web指纹识别 http://www.webscan.cc/ //同IP网站查询，C段查询，IP反查域名，C段旁注，旁注工具.W:www.phpinfo.me/domain/; http://ceye.io //在线dns查询，http请求解析，日志记录 https://www.dnsdb.io //DNS查询，子域名查询，IP查询，A记录查询，域名解析，旁站查询 https://dnsdumpster.com/ //dns recon and research， find and lookup dns records http://ip.chaxun.la/ //ip反查域名\u0026mdash;查询啦 https://bgp.he.net //bgp/asn/isp在线搜集工具 https://www.virustotal.com/ //在线文件、网址、域名、IP检测。包含pdns。W:https://crt.sh/;W:https://spyse.com/;W:https://securitytrails.com/#search; PDNS(Passive DNS)收集系统 https://github.com/JustinAzoff/bro-pdns //GO.基于bro的pdns收集工具 https://www.circl.lu/services/passive-dns //pdns服务 https://community.riskiq.com //pdns服务 子域名C段 https://github.com/laramies/theHarvester //PY.企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts https://github.com/shmilylty/OneForAll //py3.子域收集工具，多接口，协程爆破。 https://github.com/michenriksen/aquatone //GO.子域名枚举、探测工具。可用于子域名接管漏洞探测 https://github.com/guelfoweb/knock //PY.通过爆破进行子域名获取，可用于查找子域名接管漏洞 https://github.com/blechschmidt/massdns //C.通过DNS高效子域发现工具 https://github.com/SpiderLabs/HostHunter //PY3.通过多接口，ssl证书进行hostname子域名查询。 https://github.com/caffix/amass //GO.通过DNS\\API接口、搜索引擎等进行子域名搜集，使用机器学习猜测子域名。owasp项目。3k。goodjob。 https://github.com/OJ/gobuster //Golang.根据dns查询子域名和web目录爆破的工具，自带字典。 https://github.com/euphrat1ca/LayerDomainFinder //C#.cnseay法师Layer子域名挖掘机 https://github.com/aboul3la/Sublist3r //PY.通过搜索引擎与爆破快速子域枚举工具 https://github.com/Ice3man543/subfinder //Golang.go实现的Sublist3r https://github.com/TheRook/subbrute //PY.扫描器中常用的子域名爆破API库 https://github.com/nahamsec/lazyrecon //BASH.侦查reconnaissance过程自动化脚本，可自动使用Sublist3r/certspotter获取子域名，调用nmap/dirsearch等 https://github.com/FeeiCN/ESD //PY3.爆破搜集子域名 https://github.com/guimaizi/get_domain //py.基于selenium的SRC域名收集与监测。G:LangziFun/LangSrcCurise SRC子域名收集; https://github.com/pentester-io/commonspeak //BASH.Linux下直接用 Google big query 查 alexa top 1M 的子域名 和 一些文件路径 (也有其他数据集) https://github.com/blark/aiodnsbrute/ //PY3.DNS异步爆破子域名 https://github.com/lijiejie/subDomainsBrute //PY.开发的一款使用广泛的子域名爆破枚举工具 https://github.com/ring04h/wydomain //PY.猪猪侠开发的一款域名子域名枚举工具 https://github.com/n4xh4ck5/N4xD0rk //PY.利用搜索引擎来搜集子域名，可以使用西班牙语搜集 https://github.com/vysec/DomLink //PY2.调用WHOXY.com，对邮箱和域名进行进一步的搜集 https://github.com/jonluca/Anubis //PY3.子域名爆破与信息收集 https://github.com/le4f/dnsmaper //PY.web界面，子域名枚举爆破工具以及地图位置标记 https://github.com/thewhiteh4t/seeker //PY.获取高精度地理信息和设备信息的工具 https://github.com/0xbug/orangescan //web界面，的在线子域名信息收集工具 https://github.com/We5ter/GSDF //PY.基于谷歌SSL透明证书的子域名查询脚本 https://github.com/mandatoryprogrammer/cloudflare_enum //PY.利用CloudFlare的dns进行子域名枚举 https://github.com/x0day/bannerscan //PY.C段/旁站查询与路径扫描 https://github.com/Xyntax/BingC //PY.基于Bing搜索引擎的C段/旁站查询，多线程 https://github.com/zer0h/httpscan //PY.网段Web主机发现小工具 https://github.com/s0md3v/ReconDog //PY.simple，侦查信息的瑞士军刀 https://github.com/chrismaddalena/ODIN //PY3.simple，信息收集与后期漏洞利用 https://github.com/exp-db/PythonPool/tree/master/Tools/DomainSeeker //多方式收集目标子域名信息 https://github.com/code-scan/BroDomain //子域名查询 https://github.com/chuhades/dnsbrute //GO.dns子域名爆破工具 https://github.com/evilsocket/dnssearch //GO.dns子域名爆破工具 https://github.com/reconned/domained //PY.可用于子域名收集的一款工具 https://github.com/bit4woo/Teemo //PY.多方式域名收集及枚举工具 https://github.com/swisskyrepo/Subdomino //PY.子域名枚举，端口扫描，服务存活确认 https://github.com/nmalcolm/Inventus //PY.通过爬虫实现的子域名收集工具 云安全相关 敏感信息泄露发现 https://github.com/donot-wong/sensinfor //JS.chrome敏感信息泄露插件，to find leak file and backup file https://github.com/boy-hack/wooyun-payload //burpsuite插件.基于乌云漏洞信息的敏感信息发现。 https://github.com/Yelp/detect-secrets //PY.防止代码中的密码等相关敏感信息被提交到代码库中，可以在保证安全性的同时不会给开发者的生产力带来任何影响 https://github.com/Acceis/leakScraper //处理和可视化大规模文本文件， 查找敏感信息， 例如证书 https://github.com/Raikia/CredNinja //多线程用户凭证验证脚本，比如验证dump的hash是否属于此机器，利用445端口进行协议验证 https://github.com/CERTCC/keyfinder //查找并分析私钥/公钥文件(文件系统中)，支持 Android APK 文件 https://github.com/Ice3man543/hawkeye //GO.cli端，文件系统分析工具，快速查找文件内包含的SSH密钥，日志文件，Sqlite数据库，密码文件等 https://github.com/D4Vinci/Cr3dOv3r //根据邮箱自动搜索泄漏的密码信息，也可测试账户密码在各大网站能否登录的工具 https://github.com/lijiejie/idea_exploit //PY.利用 IDE config folder (.idea) 进行文件下载 https://github.com/Graph-X/davscan //PY,BASH.用于扫描启用DAV网盘服务的Web服务器上的隐藏文件和文件夹 https://github.com/Threezh1/JSFinder //PY.用于发现网站js文件中的url与域名 https://github.com/eldraco/domain_analyzer //PY.DNS servers, mail servers, IP addresses, mails on Google, SPF information等，支持插件，可生成报告，支持爬虫启动搜集。 https://github.com/mhelwig/privdns //PY3.利用nameserver的错误配置，dns解析暴露其内网地址 https://github.com/gehaxelt/ds_store //GO.苹果电脑.Ds_Store文件解析。labs.internetwache.org/ds_store/。 https://github.com/shengqi158/svnhack //PY.文件夹*.svn*泄漏利用工具 https://www.waitalone.cn/seay-svn-poc-donw-20140505.html //Seay-Svn源代码泄露漏洞利用工具，2014-05-05版 亚马逊AWS安全相关 https://github.com/RhinoSecurityLabs/Cloud-Security-Research //PY.AWS云安全研究，工具集。 https://github.com/RhinoSecurityLabs/pacu //亚马逊AWS漏洞检测框架 https://github.com/stuhirst/awssecurity/blob/master/arsenal.md //AWS 安全检测相关的项目列表 https://github.com/toniblyx/my-arsenal-of-aws-security-tools //AWS安全工具集 https://github.com/sa7mon/S3Scanner //扫描amazon公开的S3 buckets和dump https://github.com/kromtech/s3-inspector //检测亚马逊AWS S3 bucket permissions https://github.com/jordanpotti/AWSBucketDump //枚举AWS S3 buckets以查找敏感机密的文件 https://github.com/Netflix/repokid //AWS 最低权限策略部署工具 https://github.com/dowjones/hammer //PY.AWS的多账户云安全工具，可识别不安全配置与资源中的敏感信息，良好的报告与修复功能。 Git安全相关 https://github.com/0xbug/Hawkeye //JS,PY.GitHub 泄露监控系统。G:Hell0W0rld0/Github-Hunter; https://github.com/neal1991/gshark //JS/GO.github信息泄露检测。G:FeeiCN/GSIL;G:repoog/GitPrey; https://github.com/VKSRC/Github-Monitor //JS.GitHub监控，代码信息泄露，分钟级监控，邮件预警 https://github.com/Furduhlutur/yar //GO.用于侦察Github上的存储库、用户和组织。Yar会克隆给定的用户/组织的存储库，并按照提交时间顺序遍历整个提交历史，搜索密钥、令牌及密码等。 https://github.com/UnkL4b/GitMiner //github敏感内容挖掘 https://github.com/dxa4481/truffleHog //GitHub敏感信息扫描工具，包括检测commit等 https://github.com/awslabs/git-secrets //防止将敏感数据提交到 git 仓库的工具 https://github.com/zricethezav/gitleaks //GO.检查git repo中的密码信息和密钥。Github:git-hound;G:metac0rtex/GitHarvester;。 https://github.com/internetwache/GitTools //SHELL\\PY3.查找、下载、提取 .git 。1.4k。 https://github.com/BugScanTeam/GitHack //PY.可还原历史版本， .git源代码泄漏利用工具 目录路径发现 https://www.owasp.org/index.php/Category:OWASP_DirBuster_Project //JAVA.目录路径枚举Fuzz爆破 https://github.com/ffuf/ffuf //GO.web网站路径、参数、子域名、数据模糊测试（fuzzing） https://github.com/7kbstorm/7kbscan-WebPathBrute //C#.目录路径爆破 https://github.com/TheM4hd1/PenCrawLer //C#.界面，web爬虫与目录路径爆破工具，除了常规扫描增加了递归爆破模式 https://github.com/maurosoria/dirsearch //经典目录路径扫描 https://github.com/Xyntax/DirBrute //目录路径爆破工具 https://github.com/abaykan/crawlbox //目录路径路径扫描器 https://github.com/deibit/cansina //目录路径路径扫描器 https://github.com/UltimateHackers/Breacher //多线程的后台路径扫描器，也可用于发现Execution After Redirect漏洞 https://github.com/fnk0c/cangibrina //通过字典穷举、google、robots.txt等途径的跨平台后台管理路径扫描器 https://github.com/Go0s/SitePathScan //基于协程的目录路径爆破工具，配合aiohttp扫描路径比之前快了三倍有余 https://github.com/0daysec/webscan_dir //PY.轻量级web目录扫描器，支持选择字典和过滤状态码 https://github.com/lijiejie/BBScan //PY.网站信息泄漏批量扫描脚本 https://github.com/jerrychan807/WSPIH //PY3.敏感文件路径扫描下载 https://github.com/aipengjie/sensitivefilescan //PY2.网站敏感文件扫描工具 https://github.com/Mosuan/FileScan //PY.网站敏感文件扫描 / 二次判断降低误报率 / 扫描内容规则化 / 多目录扫描 https://github.com/Xyntax/FileSensor //PY3.动态敏感文件探测工具 https://github.com/ring04h/weakfilescan //PY.多线程网站泄露信息检测工具 社工相关 https://github.com/mehulj94/Radium-Keylogger //py.键盘记录工具 https://github.com/threatexpress/domainhunter //检查过期域名，bluecoat分类和Archive.org历史记录，以确定最为适合于钓鱼和C2的域名 https://github.com/Mr-Un1k0d3r/CatMyPhish //收集目标类似于的尚未注册的域名 https://github.com/thinkst/canarytokens //PY.重要文件的追踪溯源，信标定位（https://canarytokens.org/generate#）服务端代码 https://github.com/ggerganov/kbd-audio //C++.linux下利用麦克风监控键盘输入测试输入值 https://github.com/Viralmaniar/I-See-You //bash.利用公网网站代理获取用户的真实地理信息。simple https://www.jianshu.com/p/147cf5414851 //聊聊那些常见的探侦类APP 企业人员信息搜集 https://hunter.io/ //企业邮箱搜集。商业版。 https://www.aihitdata.com/ //全球公司信息变更汇总（地址、所有人、联系方式）。可结合天眼查\\企查查 https://github.com/x0day/Multisearch-v2 //Bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息 https://github.com/vysec/MaiInt //公司雇员信息收集测试工具 https://github.com/jofpin/trape //PY.利用OSINT对人员进行追踪定位。4k。 https://www.truthfinder.com //美国公民信息查询。商业版。 https://infotracer.com //姓名、手机、邮件地址等信息track。商业版。 https://github.com/famavott/osint-scraper //输入人名或邮箱地址， 自动从互联网爬取关于此人的信息 https://github.com/n0tr00t/Sreg //PY.Sreg可对使用者通过输入email、phone、username的返回用户注册的所有互联网护照信息。 https://github.com/SpiderLabs/social_mapper //社交媒体枚举和关联工具， 通过人脸识别关联人物侧写 https://verify-email.org //邮件真实性验证 https://recruitin.net //Easily use Google to search profiles on LinkedIn https://github.com/xHak9x/fbi //PY2.facebook脸书信息收集工具 https://github.com/initstring/linkedin2username //通过Linkedin 领英获取相关公司员工列表 https://github.com/0x09AL/raven //linux下领英Linkedin information gathering tool https://github.com/Ridter/Mailget //通过脉脉用户猜测企业邮箱 https://github.com/haccer/tweep //使用twitter API进行信息爬取查询 https://github.com/MazenElzanaty/TwLocation //PY.获取Twitter用户发推的地址 https://github.com/vaguileradiaz/tinfoleak //web界面，对twitter账户进行全面的分析 http://picdeer.org/ //Instagram内容\\用户在线搜索。Web:pictame.com;Web:searchmy.bio，兴趣搜索; 网站克隆 http://www.httrack.com //网站克隆镜像 https://github.com/JonCooperWorks/judas //GO.克隆网站钓鱼 钓鱼框架 https://github.com/bhdresh/SocialEngineeringPayloads //负责收集用于证书盗窃和鱼叉式网络钓鱼攻击的社交工程技巧和payloads https://github.com/trustedsec/social-engineer-toolkit //PY.TrustedSec开发的专为社交工程设计的开源渗透测试框架,支持网站克隆、邮件伪造、反弹shell等 https://github.com/thelinuxchoice/blackeye //PY.拥有facebook、instagram等三十余个钓鱼模板的一键启用工具 https://github.com/M4cs/BlackEye-Python //PY.以blackeye为基础，增加子域名模拟伪造功能 https://github.com/gophish/gophish //GO.拥有在线模板设计、发送诱骗广告等功能的钓鱼系统 https://github.com/L4bF0x/PhishingPretexts //钓鱼模板 https://github.com/drk1wi/Modlishka //GO.网络钓鱼工具 https://github.com/azizaltuntas/Camelishing //PY3.界面化社会工程学攻击辅助工具 https://github.com/tatanus/SPF //PY2.deefcon上的钓鱼系统 https://github.com/MSG-maniac/mail_fishing //PHP.基于thinkphp的甲方邮件钓鱼系统 https://github.com/samyoyo/weeman //钓鱼的http服务器 https://github.com/Raikia/FiercePhish //可以管理所有钓鱼攻击的完整钓鱼框架，允许你跟踪单独的网络钓鱼活动，定时发送电子邮件等 https://github.com/securestate/king-phisher //可视化钓鱼活动工具包 https://github.com/fireeye/ReelPhish //实时双因素网络钓鱼工具 https://github.com/kgretzky/evilginx2/ //登录页面钓鱼，绕过双因素认证等 https://github.com/ustayready/CredSniper //使用Flask和Jinja2模板编写的网络钓鱼框架，支持捕获2FA令牌 https://github.com/n0pe-sled/Postfix-Server-Setup //自动化建立一个网络钓鱼服务器 https://github.com/fireeye/PwnAuth //OAuth滥用测试检测平台 https://github.com/jbtronics/CrookedStyleSheets //php.使用CSS实现网页追踪 / 分析，用户鼠标轨迹捕捉 邮件伪造 https://emkei.cz //在线邮件伪造。多功能模拟。 http://tool.chacuo.net/mailanonymous //在线邮件伪造 http://ns4gov.000webhostapp.com //在线邮件伪造 https://github.com/Dionach/PhEmail //PY2.钓鱼与邮件伪造 https://github.com/lunarca/SimpleEmailSpoofer //PY.域名伪造钓鱼邮件 https://www.jetmore.org/john/code/swaks/ //PERL.基于smtp的邮箱域名伪造测试工具 漏洞收集 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_vul.md/ //web漏洞、软件模板漏洞、数据库、中间件、CMS框架漏洞、MS\u0026amp;Linux等系统组件漏洞、IOT漏洞收集表单。myWiki 网站扫描器漏洞检测 https://www.acunetix.com/web-vulnerability-scanner/ //Acunetix WVS扫描器，AWVS支持win/Linux。商业版。 https://www.tenable.com/downloads/nessus //漏洞扫描器，系统漏洞检测功能突出。商业版。有Nessus无IP限制版虚拟机 https://www.ibm.com/us-en/marketplace/appscan-standard //IBM漏洞扫描器，重剑无锋。商业版。 https://github.com/andresriancho/w3af //PY.包含 200+ Web漏洞 https://github.com/gyoisamurai/GyoiThon //PY.使用深度学习的渗透测试工具，从每次扫描数据中学习，扫描越多，软件检测精准度越高 https://github.com/iSafeBlue/TrackRay //JAVA.溯光是一个开源的插件化渗透测试框架，框架自身实现了漏洞扫描功能，并集成了知名安全工具：Metasploit、Nmap、Sqlmap、AWVS 等，支持插件编写。 https://github.com/TideSec/WDScanner //PHP.TideSec开源分布式web漏洞扫描、客户管理、漏洞定期扫描、子域名枚举、端口扫描、网站爬虫、暗链检测、坏链检测、网站指纹搜集、专项漏洞检测、代理搜集及部署等功能。 https://www.52pojie.cn/thread-134667-1-1.html //Safe3 Web漏洞扫描系统企业版v10.1 破解版 Crack By Lkou[LCG].历史感。 https://github.com/euphrat1ca/polar-scan //易语言.北极熊扫描器。历史感。 https://github.com/euphrat1ca/yeezy-scan //椰树1.9扫描器。历史感。 https://github.com/euphrat1ca/WebCruiserWVS //C#.轻量扫描器，椰树前身 https://github.com/theInfectedDrake/TIDoS-Framework //覆盖从侦察到漏洞分析的所有内容 https://github.com/Tuhinshubhra/RED_HAWK //php.集成信息收集、漏洞扫描、指纹识别等的扫描工具 https://github.com/1N3/Sn1per //PHP.自动化中间件扫描以及设备指纹识别 https://github.com/m4ll0k/Spaghetti //web应用扫描器，支持指纹识别、文件目录爆破、SQL/XSS/RFI等漏洞扫描，也可直接用于struts、ShellShock等漏洞扫描 https://github.com/blackye/lalascan //集合owasp top10漏洞扫描和边界资产发现能力的分布式web漏洞扫描框架 https://github.com/Skycrab/leakScan //web界面，漏洞扫描 https://github.com/az0ne/AZScanner //web界面，自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测 https://github.com/MiniSafe/microweb //web界面，base bugscan，django https://github.com/taipan-scanner/Taipan //web界面，基于F#与C#的安全扫描器 https://github.com/zhangzhenfeng/AnyScan //web界面，python漏洞扫描器，NoUpdate https://github.com/Canbing007/wukong-agent //web界面，python漏洞扫描器 https://github.com/dermotblair/webvulscan //web界面，php，漏洞扫描器，支持输出pdf报告 https://github.com/0xInfection/TIDoS-Framework //PY.linux，网站扫描器 https://github.com/secdec/adapt //PY.linux，网站扫描器 https://github.com/sullo/nikto //PERL.linux下网站扫描器 https://github.com/Ekultek/Zeus-Scanner //PY.搜索引擎API/代理/路径爆破/sqli/xss/ByPass。simple，web扫描器 https://github.com/jeffzh3ng/InsectsAwake //PY.web界面，基于 Flask 应用框架的漏洞扫描系统，同时集成了渗透测试常用的端口扫描、子域名爆破等功能，后端漏洞扫描采用Pocsuite https://github.com/blackye/BkScanner //分布式、插件化web漏洞扫描器 https://github.com/tlkh/prowler //一款基于Raspberry Pi Cluster 的网络漏洞扫描工具 https://github.com/v3n0m-Scanner/V3n0M-Scanner //支持检测SQLi/XSS/LFI/RFI等漏洞的扫描器 https://github.com/RASSec/pentestEr_Fully-automatic-scanner //定向自动测试工具 https://github.com/Fireflyi/lcyscan //PY.插件化漏洞扫描器，支持生成报表 https://github.com/Arachni/arachni //Web应用漏洞扫描框架，支持REST、RPC等api调用 https://github.com/swisskyrepo/DamnWebScanner //基于chrome/opera插件的被动式漏洞扫描 https://github.com/0xsauby/yasuo //RUBY.扫描主机第三方web应用服务漏洞 https://github.com/yangbh/Hammer //Web应用漏洞扫描 https://github.com/viraintel/OWASP-Nettacker //自动化渗透测试框架 https://github.com/flipkart-incubator/watchdog //web扫描器与漏洞利用工具 https://github.com/m4ll0k/Galileo //PY2.网站扫描器 https://github.com/samhaxr/hackbox //PY2.simple，网站扫描器 https://github.com/secrary/EllaScanner //PY3.simple，被动式漏洞扫描，支持历史cve编号漏洞识别 https://github.com/m4ll0k/WAScan //PY.simple，扫描页面/链接/脚本/Form， 测试Payload等 https://github.com/jiangsir404/S7scan //PY.DONE，简单扫描工具 https://github.com/hatRiot/clusterd //PY.simple，web漏洞扫描利用 https://github.com/iceyhexman/onlinetools //PY3.simple，DONE，web界面，利用antsword漏洞插件 https://github.com/tulpar/tulpar //PY.支持多种web漏洞扫描.simple https://github.com/UltimateHackers/Striker //PY.信息收集、cms利用与漏扫，侦察绕过Cloudflare.SIMPLE https://github.com/0x4D31/salt-scanner //PY.基于Salt Open以及Vulners Linux Audit API的linux下扫描器，支持与JIRA项目管理、slack通讯框架结合使用 漏洞测试框架 https://github.com/euphrat1ca/exploitpack //OracleJava.exploitpack是一款漏洞利用框架，包含超过38，000+ exploits。商业版。Web:exploitpack.com; https://github.com/knownsec/pocsuite3 //PY3.知道创宇维护的一个规范化POC/EXP利用框架，类sqlmap.testjob,2K. https://github.com/dhondta/sploitkit //PY3.类msf漏洞利用框架。G:Fplyth0ner-Combie/Bug-Project-Framework;G:PowerScript/KatanaFramework;G:M4cs/BabySploit https://github.com/opensec-cn/kunpeng //GO.漏洞POC检测框架，可以动态链接库的形式提供各种语言调用 https://github.com/Lucifer1993/AngelSword //PY3.插件式漏洞识别，包含300+系统、Web、工控等漏洞poc。Github:POC-T;Github:btScan;Github:osprey;Github:pocscan;Github:TangScan;Github:Beebeeto-framework。 https://github.com/boy-hack/w9scan //PY.下内置1200+插件可对网站进行一次规模的检测 被动扫描代理抓包 https://github.com/zaproxy/zaproxy //JAVA.The OWASP ZAP core project出品的综合性渗透测试工具。支持流量代理、请求重放和可扩展性。greatjob。6k。 https://github.com/euphrat1ca/PRUBUnlimitedre //burpsuite 1.7.27/2.1Pro。Github:x-Ai/BurpUnlimitedre。 https://github.com/c0ny1/passive-scan-client //burp插件.被动扫描流量转发插件 https://github.com/chaitin/xray //GO.洞鉴扫描引擎社区版。主动扫描、被动代理，sql、命令注入、重定向、路径遍历，插件化配置。社区版 https://github.com/timwhitez/crawlergo_x_XRAY //PY.利用“xray”被动扫描与“0Kee-Team/crawlergo”爬虫联动，相同还可以使用awvs等。 https://github.com/w-digital-scanner/w13scan //PY3.boy-hack被动扫描器Passive Security Scanner，官网x.hacking8.com。G:netxfly/passive_scan; https://github.com/netxfly/Transparent-Proxy-Scanner //GO.基于vpn和透明代理的web漏洞扫描器,存储数据为mongodb https://github.com/cloudtracer/paskto //js.基于Nikto扫描规则的被动式路径扫描以及信息爬虫 https://www.telerik.com/fiddler //C#.Fiddler4 Free Web Debugging Proxy。W:charlesproxy.com 青花瓷;P:getpostman.com http调试工具。P:soft.125.la 精易助手;G:jakubroztocil/httpie https://github.com/MegatronKing/HttpCanary //JS.基于NetBare的安卓移动端抓包代理工具。welljob,1k. https://www.0daydown.com/03/33647.html //IEInspector HTTP Analyzer，可以注入进程进行SSL解密。 端口服务发现指纹识别 https://github.com/nmap/nmap //LUA.Nmap端口扫描器具有有强大的脚本引擎框架.greatjob. https://github.com/robertdavidgraham/masscan //C.无状态扫描器。10k。On Windows, or from VMs, it can do 300,000 packets/second. On Linux (no virtualization) it\u0026rsquo;ll do 1.6 million packets-per-second. https://github.com/nray-scanner/nray //GO.分布式扫描工具，支持ldap\\证书扫描。 https://github.com/zmap/zmap //C.无状态扫描，可使用用C编写扩展模块。censys基础件 https://github.com/zmap/zgrab2 //GO.配合zmap/ztag的指纹抓取工具 https://github.com/chichou/grab.js //JS.类似于 zgrab 的TCP指纹抓取解析工具。 https://github.com/zmap/zdns //GO.Fast CLI DNS Lookup Tool https://github.com/zmap/ztag //PY.对zmap\\zgrab产生的数据分析打标签。censys三件套 https://github.com/OffensivePython/Nscan //PY.类似于于Masscan和Zmap的端口服务扫描器 https://github.com/RASSec/RASscan //PY.基础端口服务扫描demo https://github.com/angryip/ipscan //JAVA.Angry IP Scanner。跨平台界面化端口扫描器,angryip.org。 http://www.advanced-ip-scanner.com //Advanced IP Scanner Portable端口扫描器。商业版。 https://github.com/AliasIO/Wappalyzer //JS.网站指纹识别。资产库，Chrome扩展。5k。 https://github.com/Lucifer1993/cmsprint //json格式CMS和中间件指纹库 https://github.com/HA71/WhatCMS //bash.CMS检测和漏洞利用脚本，基于Whatcms.org API https://github.com/urbanadventurer/whatweb //RUBY.web指纹识别。2k。goodjob。 https://github.com/l3m0n/whatweb //GO.网站指纹识别，Wappalyzer资产库。 https://github.com/Rvn0xsy/FastWhatWebSearch //whatweb工具结果搜索平台 https://github.com/boy-hack/gwhatweb //PY.CMS识别,gevent多线程实现 https://github.com/zerokeeper/WebEye //PY.快速识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架 https://github.com/n4xh4ck5/CMSsc4n //PY.CMS指纹识别 https://github.com/Ms0x0/Dayu //JAVA.指纹识别工具 https://github.com/0xbug/Howl //网络设备 web 服务指纹扫描与检索 https://github.com/jekyc/wig //web应用信息收集工具 https://github.com/tanjiti/FingerPrint //web应用指纹识别 https://github.com/nanshihui/Scan-T //网络爬虫式指纹识别 https://github.com/s0md3v/Arjun //PY3.HTTP参数信息挖掘工具。simple。 https://github.com/mozilla/ssh_scan //服务器ssh配置信息扫描 https://github.com/mozilla/cipherscan //目标主机服务ssl类型识别 https://github.com/rbsec/sslscan //ssl类型识别 https://github.com/ywolf/F-MiddlewareScan //中间件扫描服务识别 https://github.com/ggusoft/inforfinder //域名资产收集及指纹识别工具 https://github.com/EnableSecurity/wafw00f //WAF产品指纹识别 密码破解证书校验口令扫描 https://github.com/vanhauser-thc/thc-hydra //C.支持多种协议方式的破解与爆破 https://github.com/maaaaz/thc-hydra-windows //C.hydra的windows编译版本 https://github.com/galkan/crowbar //PY.支持openvpn、rdp、ssh、vnc破解 https://github.com/shack2/SNETCracker //C#.密码爆破工具，支持SSH、RDP、MySQL等常见协议.超级弱口令爆破工具 https://github.com/jmk-foofus/medusa //C.Linux下登录密码爆破工具 https://github.com/nmap/ncrack //C.支持多种协议的破解与爆破 https://github.com/lanjelot/patator //支持多种协议的爆破，采用模块化设计，使用灵活 https://github.com/euphrat1ca/F-Scrack //PY2.对各类服务用户名密码爆破的脚本.ysrc https://github.com/netxfly/crack_ssh //GO.协程版ssh\\redis\\mongodb弱口令破解 https://github.com/ztgrace/changeme //弱口令扫描器，不仅支持普通登录页，也支持ssh、mongodb等组件 https://github.com/ShawnDEvans/smbmap //py.利用smb服务传递哈希、增删改查、命令执行、ip段共享枚举等。G:m4ll0k/SMBrute; https://github.com/TunisianEagles/SocialBox //针对fb、gmail、ins、twitter的用户名密码爆破的脚本 https://github.com/Moham3dRiahi/XBruteForcer //WordPress、Joomla、DruPal、OpenCart、Magento等CMS用户密码爆破 https://github.com/lijiejie/htpwdScan //PY.simple，http暴力破解、撞库攻击脚本 https://github.com/galkan/crowbar //PY.利用key对ssh、rdp、openvpn、vnc爆破 https://github.com/scu-igroup/ssh-scanner //NMAP,HYDRA.ssh批量爆破 https://github.com/shengqi158/weak_password_detect //NMAP.Linux下多线程探测ssh弱口令 加解密保护密码学混淆 https://github.com/bugsafe/WeReport //PHP.WeReport报告助手，一键生成测试报告。 https://github.com/0Chencc/CTFCrackTools //kotlin与java.CTF工具框架，支持Crypto，Mis等。后期以编写python插件增强功能 https://www.wishingstarmoye.com/ctf/autokey //CTF在线工具集合。密码/隐写/二维码/哈希/编码/激战2？？？/ https://github.com/guyoung/CaptfEncoder //Nodejs.基于Electron。跨平台网络安全工具套件，提供网络安全相关编码转换、古典密码、密码学、特殊编码等工具，并聚合各类在线工具。 https://github.com/gchq/CyberChef //JS.反混淆，密码解密工具。 https://github.com/Wfzsec/awd_attack_framework //PHP.AWD(Attack With Defense,攻防兼备)常用脚本+不死马+crontab+防御方法 https://github.com/3summer/CTF-RSA-tool //PY2.ctf rsa套路 https://github.com/veracrypt/VeraCrypt //C.2K。官网veracrypt.fr,类似于BitLocker全盘加密，支持磁盘隐藏分区。G:FreeApophis/TrueCrypt; https://github.com/AlkenePan/KAP //GO.实现 ELF 文件保护 在线密码破解 https://www.cmd5.com/ //HASH密码在线破解。限制位数 https://hashkiller.co.uk/Cracker //密码破解。Google reCAPTCHA v3。 http://hashtoolkit.com //HASH密码在线破解。社区版 http://md5.my-addr.com/md5_decrypt-md5_cracker_online/md5_decoder_tool.php //md5密码破解。社区版。 https://md5.gromweb.com/?md5= //md5密码破解。社区版 http://www.chamd5.org //md5密码破解。需要登录 http://www.xmd5.org //md5密码破解。需要登录 http://pmd5.com //md5密码破解。需要验证码 https://www.onlinehashcrack.com //md5密码破解。需要验证码 密码破解还原 https://securityxploded.com/download.php/ //各种密码方向安全小工具 https://github.com/bdutro/ibm_pw_clear //IBM x3550/x3560 M3 bios密码清除重置工具 https://github.com/hashcat/hashcat //C.哈希破解 https://github.com/fireeye/gocrack //GO.基于hashcat 3.6.0+的分布式密码破解工具 https://github.com/s3inlc/hashtopolis //php.hashcat的分布式破解工具，支持C#与python客户端 https://github.com/chris408/known_hosts-hashcat //PY.利用hashcat破解ssh密码hash https://github.com/clr2of8/DPAT //PY.利用hashcat等工具域密码进行破解测试 https://github.com/testsecer/Md5Decrypt //C#.md5多接口查询基于网上web API的MD5搜索工具 https://github.com/s0md3v/Hash-Buster //能调用多个API进行hash破解查询的智能工具 https://github.com/magnumripper/JohnTheRipper //C.已知密文的情况下尝试破解出明文的破解密码软件 https://github.com/shinnok/johnny //C++.JohnTheRipper密码破解的GUI界面，理论兼容所有功能，有windows界面 https://www.52pojie.cn/thread-275945-1-1.html //ARCHPR Pro4.54绿色中文破解版。压缩包密码破解，利用“已知明文攻击”破解加密的压缩文件 https://github.com/thehappydinoa/iOSRestrictionBruteForce //PY.实现的 ios 访问限制密码破解工具 https://github.com/e-ago/bitcracker //C.首款开源的BitLocker密码破解工具 https://www.ru.nl/publish/pages/909282/draft-paper.pdf //INTRO.破解SSD下使用BitLocker加密 https://github.com/fox-it/adconnectdump //PY.Azure AD凭证导出工具 https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-password //Navicate数据库密码解密 https://github.com/TideSec/Decrypt_Weblogic_Password //JAVA.解密weblogic密文 https://github.com/MrSqar-Ye/wpCrack //wordpress hash破解 https://github.com/psypanda/hashID //PY.对超过220种hash识别。使用\u0026rsquo;hash' https://github.com/AnimeshShaw/Hash-Algorithm-Identifier //PY2.对超过160种hash识别。 web安全前端利用 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_websec.md/ //web安全测试利用、前端安全、数据库sql注入、xss跨站、上传漏洞、命令注入执行、webshell、https证书加密。myWiki 后渗透拓展 https://github.com/rapid7/metasploit-framework //RUBY.后渗透框架。greatjob,17k。 https://github.com/EmpireProject/Empire //PS.后渗透命令执行框架。支持自定义域名host头绕过安全设备。testjob,4.5k。noupdate。 https://git.coding.net/ssooking/cobaltstrike-cracked //OracleJava8.cobalt strike是一个APT协同工作平台，支持自定义域名host头绕过安全设备。greatjob。G:rsmudge/armitage CobaltStrike社区版，通过调用msf。G:RASSec/Cobalt-Strike;。 https://github.com/GhostPack //C#.SpecterOps公司关于PowerShell 功能的各种 C# 实现的集合，包括信息搜集\\权限提升\\密钥窃取等 https://github.com/samratashok/nishang //PS.测试脚本集与开发框架。Check-VM检查虚拟机;Copy-VSS利用Volume Shadow Copy 服务来复制出SAM文件（密码）;Invoke-CredentialsPhish欺骗用户输入账号密码信息;FireBuster FireListener对内网进行扫描;Get-Information信息收集。testjob,3k。 https://github.com/0xdea/tactical-exploitation //Python/PowerShell的测试脚本集 https://github.com/jmortega/python-pentesting //python-pentesting-tool，python安全工具相关 https://github.com/TheSecondSun/Bashark //Bash.后渗透框架。大鲨鱼 https://github.com/DarkSpiritz/DarkSpiritz //PY2.后渗透框架 https://github.com/xorrior/RemoteRecon //基于DotNetToJScript进行截图、key记录、token窃取、dll与恶意代码注入 https://github.com/0xwindows/VulScritp //内网渗透脚本，包括banner扫描、端口扫描;phpmyadmin、jenkins等通用漏洞利用等 https://github.com/zMarch/Orc //bash.Linux下后渗透命令集合 https://github.com/JoelGMSec/AutoRDPwn //PS4.远程桌面利用访问 https://github.com/JusticeRage/FFM //PY3.拥有下载、上传功能，生成可执行py脚本的后门的后渗透框架。 红队基础设施自动化部署建设 https://github.com/QAX-A-Team/LuWu //bash.红队基础设施自动化部署工具 公众号：红队攻防全流程解析 // 权限维持 https://mp.weixin.qq.com/s/SavldFETaFea3l7kVX2RyA //ATT\u0026amp;CK 之后门持久化 https://pentestlab.blog/2020/01/13/persistence-image-file-execution-options-injection/ //att\u0026amp;ck Image File Execution Options Injection 通过注册表图像文件执行选项将调试器附加到应用程序并启用“ GlobalFlag ”进行应用程序调试。 https://github.com/PowerShellMafia/PowerSploit //PS.测试脚本集与开发框架。AntivirusBypass寻找反病毒特征码，CodeExecution注入DLL脚本，Exfiltration隐私记录，Mayhem破坏，Persistence权限维持，Privesc提权，Recon信息收集，ScriptModification编码加密。Github:PowerView;Github:PowerUp;Github:PowerTools;Github:Shell-Suite;Github:Misc-Powershell-Scripts。5.4k。goodjob。 横向移动密码hash获取 http://www.oxid.it/cain.html //Cain \u0026amp; Abel。支持密码还原、arp攻击.NoUpdate。 https://github.com/gentilkiwi/mimikatz //C.Windows下进行凭证抓取横向移动.GREATJOB。 https://github.com/klsecservices/bat-armor //PY.bat文件混淆版mimikatz https://github.com/skelsec/pypykatz //PY3.使用python实现的mimikatz https://github.com/eladshamir/Internal-Monologue //C#.无需LSASS进程使用Mimikatz从LSASS进程内存中提取内容，从内存中提取明文密码，NTLM哈希，Kerberos ticket，以及执行pass-the-hash/pass-the-ticket攻击等 https://github.com/nccgroup/redsnarf //PS,PY.调用猕猴桃等程序窃取哈希，密码解密，rdp多方法利用，远程启动shell，清除痕迹。 https://github.com/aas-n/spraykatz //py3.Windows计算机和大型Active Directory环境中检索凭据的工具，对计算机进行“procdump（微软官方）”，并远程解析转储。 https://github.com/twelvesec/passcat //C.Windows 下密码抓取工具 https://github.com/huntergregal/mimipenguin //C.linux密码抓取 https://github.com/AlessandroZ/LaZagne //py3.跨平台密码抓取工具。在win下，V2.4相较于V2.3抓取到的内容会少一些。greatjob,4.7k。 https://github.com/AlessandroZ/LaZagneForensic //LaZagne密码破解升级版，利用DPAPI，目前缺陷是需要windows user密码 https://github.com/putterpanda/mimikittenz //PS.类似于lazagne可以获取用户级密码。利用\u0026quot;ReadProcessMemory()\u0026ldquo;方法从目标进程中提取纯文本密码。 https://github.com/quarkslab/quarkspwdump //quarkslab出品的密码抓取工具，不用注入任何进程 https://github.com/mthbernardes/sshLooter //从ssh服务中窃取用户名密码 https://github.com/nettitude/Invoke-PowerThIEf //利用IE进行后渗透，抓取密码、重定向等 https://github.com/GhostPack/Rubeus //C#.操作Kerberos的库， 实现了Kekeo的大部分功能 https://github.com/m8r0wn/ldap_search //PY.通过ldap（轻量目录访问协议）认证，列举win域信息，爆破登录 https://github.com/lgandx/Responder //PY.用于嗅探网络内所有的NTLM、NTLMv1/v2、Net-NTLMv1/v2包，对网络内主机进行欺骗获取用户hash。testjob,4k。 https://github.com/RhinoSecurityLabs/Security-Research/blob/master/tools/ms-office/subdoc-injector //PY.构造恶意office文件，配合responder窃取凭证哈希。Security-Research作者的工具库。noupdate。 https://blog.netspi.com/microsoft-word-unc-path-injection-image-linking/ //intro.Microsoft Word – UNC Path Injection with Image Linking，word利用图片和responder窃取ntlm哈希 https://github.com/chroblert/domainWeakPasswdCheck //ps.域账号弱口令审计 https://github.com/0x09AL/RdpThief //C++.RDP密码抓取明文。G:citronneur/rdpy; 横向移动哈希传递 https://github.com/SecureAuthCorp/impacket //Python工具包。Impacket是用于处理网络协议的，内网中可用以提权例如wmiexec.py、NMB，SMB1-3和MS-DCERPC提供对协议实现本身的低级别编程访问。testjob,4K。 https://github.com/maaaaz/impacket-examples-windows //Impacket打包exe版 https://github.com/byt3bl33d3r/CrackMapExec //PY/PS.CME利用AD内置功能/协议规避大多数终端防护/IDS/IPS.包含impacket、PowerSploit等多种模块.testjob,3K。 https://github.com/SpiderLabs/scavenger //CrackMapExec二次包装开发,内网敏感信息扫描 https://github.com/FortyNorthSecurity/WMImplant //PS.利用WMI横向移动。Github:FortyNorthSecurity/WMIOps;Github:secabstraction/WmiSploit。 https://github.com/Kevin-Robertson/Inveigh //PS.LLMNR/mDNS/NBNS欺骗器 https://github.com/poweradminllc/PAExec //C++.类PSEXEC远程$IPC控制。 https://github.com/byt3bl33d3r/pth-toolkit //PY.hash传递，wmi移动等。 后渗透白利用 https://github.com/securemode/DefenderKeys //枚举出被 Windows Defender 排除扫描的配置 https://github.com/lucasg/Dependencies //C#.基于\u0026quot;depends.exe\u0026quot;发现Windows exe dll文件依赖查询。goodjob。 https://github.com/jivoi/openssh-backdoor-kit //bash.openssh后门编译生成 https://www.4hou.com/technology/16713.html //通过模拟可信目录绕过UAC的利用分析\\模拟可信目录的利用技巧扩展 https://github.com/LOLBAS-Project/LOLBAS //Windows系统白利用工具集 https://github.com/g3rzi/Manifesto //C#.寻找系统中存在可执行权限的组件 https://github.com/ufrisk/MemProcFS //C.以访问文件系统的方式访问物理内存，可读写，有易于使用的接口. 当前支持Windows https://github.com/mdsecactivebreach/SharpPack //C#.绕过系统应用白名单执行DotNet and PowerShell tools https://payloads.online/archivers/2018-12-22/1 //INTRO.DLL Hijacking \u0026amp; COM Hijacking ByPass UAC - 议题解读。qingxuan。 https://github.com/sensepost/rattler //C++.自动化dll劫持注入。G:rootm0s/WinPwnage; https://github.com/stephenfewer/ReflectiveDLLInjection //C.一种库注入技术，让DLL自身不使用LoadLibraryA函数，将自身映射到目标进程内存中 https://github.com/mdsecactivebreach/RDPInception/ //BAT.rdp服务劫持，利用ps反弹shell https://github.com/gianlucaborello/libprocesshider //C.利用 LD_PRELOAD 来实现系统函数的劫持，在linux 下隐藏进程 https://github.com/lmacken/pyrasite //PY3.对运行中dpython进程注入，支持≥py2.4 签名提取伪造修改 https://github.com/threatexpress/metatwin //从一个文件中提取元数据，包括数字签名，并注入到另一个文件中 https://github.com/Mr-Un1k0d3r/Windows-SignedBinary //可以修改二进制文件的HASH，同时保留微软windows的签名 https://github.com/secretsquirrel/SigThief //PY.用于劫持合法的数字签名并绕过Windows的哈希验证机制的脚本工具 https://github.com/secretsquirrel/SigThi //PY3.伪造程序签名。 进程隐藏 https://www.cnblogs.com/mysgk/p/9602977.html //INTRO.linux 下隐藏进程的一种方法。利用libprocesshider https://github.com/M00nRise/ProcessHider //C++.Windows下隐藏进程 https://github.com/malcomvetter/UnstoppableService //C#.将自身安装为Windows服务且管理员无法停止/暂停服务的程序. 资产管理信息搜集 https://github.com/cea-sec/ivre //PY.网络资产指纹发现，bro/argus/nfdump/p0f/nmap/zmap/masscan/数据库mongoDB。Github:Scan-T;G:LangziFun/LangNetworkTopology3; https://github.com/w-digital-scanner/w12scan //py3.django + elasticsearch + redis(去重+web与client通信中间件)网络资产发现引擎，通过WEB API下发任务 https://github.com/w-digital-scanner/w12scan-client //PY.w12scan网络资产发现引擎client客户端。boy-hack开发 https://github.com/BloodHoundAD/BloodHound //PS.使用图论进行内网信息域内关系与细节整理，作为DEFCON 24的免费开源工具发布。通过脚本导出域内的session、computer、group、user等信息，入库后进行可视化分析域成员和用用户关系。testjob,3k。 https://www.4hou.com/penetration/5752.html //INTRO.域渗透提权分析工具 BloodHound 1.3 中的ACL攻击路- https://github.com/scallywag/nbtscan //C.NetBIOS协议主机设备发现。NetBScanner、nmap、msf都有此功能，这个比较轻。 https://github.com/royhills/arp-scan //C.ARP协议主机设备发现。 https://github.com/fdiskyou/hunter //C++.调用 Windows API 对内网信息进行搜集很全面 https://github.com/m8r0wn/nullinux //PY.用于Linux的内部渗透测试工具，可用于通过SMB枚举操作系统信息，域信息，共享，目录和用户。 https://github.com/grayddq/PubilcAssetInfo //PY3.主要目标是以甲方安全人员的视角，尽可能收集发现企业的域名和服务器公网IP资产。如百度云、阿里云、腾讯云等。一个人的安全部 https://github.com/grayddq/PublicMonitors //PY3.对公网IP列表进行端口服务扫描，发现周期内的端口服务变化情况和弱口令安全风险。一个人的安全部 径介绍 https://github.com/sowish/LNScan //详细的内部网络信息扫描器 https://github.com/dr0op/bufferfly //PY3.资产/域名存活验证，标题获取，语料提取，端口检测。 https://github.com/ywolf/F-NAScan //PY2.网络资产、端口服务搜集整理，生成报表显示。 https://github.com/flipkart-incubator/RTA //PY2.扫描公司内部所有在线设备，提供整体安全视图，标示所有安全异常。 https://docs.microsoft.com/en-us/sysinternals/downloads/sigcheck //可以查看 exe 的 manifest，在 manifest 中可以看到程序的权限。有 asInvoker highestAvailable requireAdministrator 资产管理风险测试 https://github.com/ysrc/xunfeng //PY.巡风采用web界面，由同程安全开发的网络资产识别引擎，漏洞检测引擎。goodjob。2k。 https://gobies.org/ //goby是白帽汇资产风险管理工具。端口、服务、截图、弱口令测试。W:rumble.run; https://github.com/jeffzh3ng/Fuxi-Scanner //PY2.资产管理，漏洞检测集成awvs、创宇Pocsuite、nmap、hydra https://github.com/lcatro/network_backdoor_scanner //C++.反向链接、内外网穿透、通信数据加密，http弱口令破解。 https://github.com/vletoux/pingcastle //PY.AD域信息威胁等级测试 https://github.com/0xbug/Biu-framework //PY.企业内网基础服务安全扫描框架 https://github.com/lawrenceamer/0xsp-Mongoose //PHP.CS架构资产安全检测工具，汇集多种redteam toolkit。 https://github.com/mitre/caldera //mitre公司apt攻击模拟测试，主要针对win。 https://github.com/guardicore/monkey //PY.C2架构，利用默认口令、exp、多种协议（wmi组件、ssh、smb等）方式进行攻击检测，恶意病毒传播模拟测试。guardicore.com/infectionmonkey。 https://github.com/NextronSystems/APTSimulator //bat.Windows下apt攻击模拟测试 https://github.com/alphasoc/flightsim //Golang.malicious恶意网路流量模拟测试 资产漏洞生命周期管理 https://github.com/infobyte/faraday //协作渗透测试和漏洞管理平台，集成多种 https://github.com/DefectDojo/django-DefectDojo //PY.基于django的漏洞资产管理平台 https://github.com/creditease-sec/insight //web界面。宜信安全部开发，集成应用系统资产管理、漏洞全生命周期管理、安全知识库管理三位一体的管理平台 https://github.com/RASSec/A_Scan_Framework //漏洞管理、资产管理、任务扫描系统 https://github.com/zhaoweiho/SecurityManageFramwork //PY3.SecurityManageFramwork-SeMF基于django2，包含资产管理，漏洞管理，账号管理，知识库管、安全扫描自动化功能模块，可用于企业内部的安全管理。goodjob。 MITM攻击流量劫持 https://github.com/bettercap/bettercap //GO.中间人欺骗，网络攻击以及监控的瑞士军刀。该工具支持多种模块，比如ARP/DNS欺骗、TCP以及数据包代理等.5K.GREATJOB. https://github.com/mitmproxy/mitmproxy //PY.中间人攻击，支持SSL拦截，进行https流量代理。greatjob。15k。 https://github.com/qiyeboy/BaseProxy //PY3.异步http/https代理，楼上简化版。可以作为中间人工具，比如说替换网址图片等 https://github.com/LionSec/xerosploit //中间人攻击测试工具包 https://github.com/infobyte/evilgrade //一个模块化的脚本框架，使攻击者在不知情的情况下将恶意更新注入到用户更新中 https://github.com/AlsidOfficial/WSUSpendu //可以自主创建恶意更新，并将其注入到WSUS服务器数据库中，然后随意的分发这些恶意更新 https://github.com/quickbreach/smbetray //专注于通过文件内容交换、lnk交换来攻击客户端，以及窃取任何以明文形式传输的数据 https://github.com/mrexodia/haxxmap //对IMAP服务器进行中间人攻击 https://github.com/SySS-Research/Seth //PY3/BASH。Linux下MitM RDP远程服务中间人攻击。G:citronneur/rdpy rdp远程服务模拟开启 http://ntwox.sourceforge.net //ntwow多协议伪造，网络测试工具集 https://github.com/Ekultek/suddensix //bash.SLAAC（无状态地址自动配置）攻击自动化脚本，可用于在IPv4基础架构上构建IPv6覆盖网络，以执行中间人攻击。 wifi中间人攻击 https://github.com/wifiphisher/wifiphisher //PY.中间人攻击，FakeAp恶意热点，WIFI钓鱼，凭证窃取。goodjob,7k。 https://github.com/1N3/PRISM-AP //自动部署RogueAP(恶意热点) MITM攻击框架 https://github.com/sensepost/mana //Wifi劫持工具，可以监听计算机或其他移动设备的Wifi通信，并能够模仿该设备 https://github.com/deltaxflux/fluxion //bash,PY.对使用wpa协议的无线网络进行MiTM攻击 https://github.com/DanMcInerney/LANs.py //PY.无线网络劫持ARP欺骗 硬件中间人攻击 https://github.com/tenable/router_badusb //利用路由器USE上网口和DHCP协议，使用树莓派连接VPN模拟流量转发进行中间人攻击 远程管理控制 https://labs.mwrinfosecurity.com/tools/c3/ //C++.红队C2通讯框架。Github:mwrlabs/C3;Github:cobbr/Covenant。 https://github.com/quasar/QuasarRAT //C#.多sessions，界面化。goodjob。2.4k。Github:NYAN-x-CAT/AsyncRAT-C-Sharp。 https://github.com/tiagorlampert/CHAOS //GO.win远控，自带upx。welljob。 https://github.com/zerosum0x0/koadic //PY3.大宝剑基于JScript/VBScript 进行控制，多版本系统支持在内存中运行shell.GOODJOB,1k。 https://github.com/BlackHacker511/BlackRAT //JAVA.跨平台rat。 https://github.com/Ne0nd0g/merlin //GO.c2通讯，多session。 https://github.com/Tiked/Client //GO.跨平台rat。 https://github.com/yuanyuanxiang/SimpleRemoter //C++/C.基于大灰狼gh0st的远程控制器。 https://github.com/xdnice/PCShare //C++.远程控制软件，可以监视目标机器屏幕、注册表、文件系统等。0.2k。 https://github.com/TheM4hd1/Vayne-RaT //C#.一对多，界面。 https://github.com/TheSph1nx/RT-101 //C#.一对多，界面。 https://github.com/DannyTheSloth/VanillaRat //C#.SIMPLE，界面。 https://github.com/brunull/pace //C#.SIMPLE，界面。 https://github.com/nettitude/PoshC2 //PowerShell/C#.远控工具，有win提权组件 https://github.com/peterpt/fuzzbunch //PY2.方程式NSA漏洞利用远控RAT，配有自动化安装脚本与gui界面。永恒之蓝、永恒浪漫、永恒冠军、双星脉冲 https://github.com/nathanlopez/Stitch //PY.Windows、Mac OSX、Linux跨平台。welljob,1k。 https://github.com/Mr-Un1k0d3r/ThunderShell //PY2.CLI与web端，内存加载，RC4加密HTTP传输 https://github.com/Ridter/MyJSRat //PY2.利用js后门，配合chm、hta可实现很多后门方式。evi1cg.me/archives/chm_backdoor.html。welljob。 https://github.com/Hood3dRob1n/JSRat-Py //PY.jsrat改进版。 https://github.com/its-a-feature/Apfell //PY3.macOS与linux下的利用js后门，web界面管理 https://github.com/neoneggplant/EggShell //PY.macos/osx远控，可生成HID代码，多session。testjob。noupdate。 https://github.com/Marten4n6/EvilOSX //PY.macos/osx远控，多session。testjob。noupdate。 https://github.com/vesche/basicRAT //PY3.simple远控，多session。 多姿态远控shell https://github.com/ZHacker13/ReverseTCPShell //PS.对tcp流量进行aes加密，增强版NC。G:sweetsoftware/Ares;G:5alt/ZeroRAT; https://blog.csdn.net/Fly_hps/article/list/8?/ //FLy_鹏程万里【基础篇】———— 隐匿攻击之，ICMP/DNS/DropBox/Office 365/mail/app/webSocketSiteKeywordDomainApi/PS/WindowsDomWmi/webDav/https/images/JS/Proxy等多协议 https://github.com/0nise/shell-plus //Java.基于 RMI 的一款服务器管工具，由服务端、注册中心、客户端进行组成。 https://github.com/inquisb/icmpsh //C.Simple reverse ICMP shell。Github:PiX-C2;Github:icmptunnel;。 https://github.com/iagox86/dnscat2 //RUBY/C.cs结构，利用DNS协议进行端对端传输。Github:yarrick/iodine;Github:lukebaggett/dnscat2-powershell;Github:ahhh/Reverse_DNS_Shell。2k。goodjob。 https://www.4hou.com/penetration/18447.html //域渗透——利用dnscmd在DNS服务器上实现远程加载Dll https://github.com/no0be/DNSlivery //PY3.基于scapy利用dns协议传输文件，条件简单。 https://github.com/Coalfire-Research/Slackor //GO,PY3.基于slack框架命令控制，利用dns隐匿信道传输。集成spookflare/impacket/pypykatz。simple。goodjob。 https://github.com/DamonMohammadbagher/NativePayload_ARP //C#.利用arp协议传输后门 https://github.com/byt3bl33d3r/gcat //PY2.使用 gmail 作为 C\u0026amp;C 服务器。Github:gdog;Github:Powershell-RAT。 https://github.com/mvrozanti/RAT-via-Telegram //PY3.Windows下利用telegram的远程控制工具。Github:Parat;Github:twittor;Github:补bt2(Blaze Telegram Backdoor Toolkit); https://github.com/0x09AL/Browser-C2 //GO.利用chrome以浏览器的形式连接C2服务器 https://github.com/peewpw/Invoke-PSImage //PS.将PS脚本隐藏进PNG像素中后上传到web服务器，通过命令加载隐藏在图片里的载荷。1k。NoUpdate。Github:et0x/C2。 https://github.com/Arno0x/WSC2 //PY.利用web套接字WebSockets进行数据传输 https://github.com/deepzec/Grok-backdoor //PY.利用ngrok的后门 https://github.com/trustedsec/trevorc2 //PY.搭建一个可浏览网站用于隐藏命令执行的客户端/服务器通信。Github:WebDAVC2; https://github.com/h0mbre/Dali //PY.利用图片像素进行C2服务器通讯，Image_Based_C2_PoC。 移动端远程协助 https://spynote.us //商业版。 http://droidjack.net/ //商业版。 https://github.com/AhMyth/AhMyth-Android-RAT //Smali.Android平台一对多带界面。goodjob。 https://github.com/The404Hacking/AndroRAT //JAVA.Android平台一对多带界面。 https://github.com/n1nj4sec/pupy //PY.Windows、Linux、OSX、Android跨平台，多session。testjob,5k。 https://github.com/home-assistant/home-assistant //PY.物联网管理集群控制平台 僵木蠕远程协助 https://github.com/panda-re/lava //批量恶意程序注入 https://github.com/malwaredllc/byob //僵尸网络生成框架 https://github.com/proxycannon/proxycannon-ng 构建僵尸网络 https://github.com/deadPix3l/CryptSky/ //勒索软件源码 https://github.com/jgamblin/Mirai-Source-Code //C.MIRAI蠕虫病毒源码.6K。 https://github.com/NYAN-x-CAT/Lime-RAT //VB.勒索病毒源码 https://github.com/mwsrc/njRAT //VB.源码 https://github.com/euphrat1ca/njRAT-v0.7d //vb.常见蠕虫远控，有很多变种，多session带界面 shell反弹rootkit生成 https://github.com/sysdream/chashell //Golang。利用dns反弹shell https://github.com/WangYihang/Platypus //GO.反弹shell管理工具 https://github.com/FlyfishSec/rsGen //BAT.Windows下远程反弹shell命令行工具 https://github.com/sensepost/DNS-Shell //PY.本地利用53端口nslookup传输加密的ps命令，回弹shell https://github.com/tokyoneon/Armor //bash.生成加密 Payload 在 macOS 上反弹 Shell https://github.com/GuestGuri/Rootkit //PY.反弹一个tcp连接，将进程id绑定到一个空文件夹 https://github.com/f0rb1dd3n/Reptile //C.LKM Linux rootkit。1k。 https://github.com/islamTaha12/Python-Rootkit //PY.windows下rootkit远控，反弹meterpreter https://github.com/mhaskar/Linux-Root-Kit //PY.simple。linux简单rootkit https://github.com/PinkP4nther/Sutekh //C.rootkit使普通用户获取root shell 后门生成与混淆免杀 https://github.com/TideSec/BypassAntiVirus //远控免杀系列 https://github.com/Veil-Framework/Veil //PY.Msf免杀。1.5K。 https://github.com/Screetsec/TheFatRat //JAVA.msf免杀，利用searchsploit快速搜索 https://github.com/Screetsec/Vegile //SHELL/C.msf免杀，程序注入 https://github.com/MohamedNourTN/Terminator //PY2.msf免杀 https://github.com/abedalqaderswedan1/aswcrypter //py,bash.msf免杀 https://github.com/pasahitz/zirikatu //msf免杀 https://github.com/govolution/avet //msf免杀 https://github.com/GreatSCT/GreatSCT //msf免杀 https://github.com/EgeBalci/HERCULES //msf免杀 https://github.com/trustedsec/nps_payload //msf免杀 https://github.com/hlldz/SpookFlare //PY.客户端与网络端策略绕过，msf/empire/koadic生成加载混淆免杀。goodjob。 https://github.com/n00py/Hwacha //linux下快速生成metepreter等多种payload https://github.com/4w4k3/Insanity-Framework //PY.生成免杀payload，识别虚拟机，钓鱼，内存注入等 https://github.com/trustedsec/unicorn //PY.一键生成多种后门 https://github.com/Kkevsterrr/backdoorme //py3、py2。多种类型的后门、shell生成工具，可以自动维持权限 https://github.com/pasahitz/regsvr32 //C#.使用C#+Empire实现最小体积免杀后门 https://github.com/Cn33liz/StarFighters //基于DotNetToJScript，利用JavaScript和VBScript执行Empire Launcher https://github.com/mdsecactivebreach/SharpShooter //基于DotNetToJScript使用js、vbs，用于检索和执行任意CSharp源码的payload创建框架 https://github.com/mdsecactivebreach/CACTUSTORCH //基于DotNetToJScript使用js、vbs生成恶意payload https://github.com/OmerYa/Invisi-Shell //对powershell文件进行混淆 https://github.com/danielbohannon/Invoke-DOSfuscation //对powershell文件进行混淆，加密操作以及重新编码 https://github.com/danielbohannon/Invoke-Obfuscation //对powershell文件进行混淆，加密操作以及重新编码 https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator //VBA.宏混淆，其中还包括AV/Sandboxes逃避机制 https://github.com/9aylas/Shortcut-Payload-Generator 快捷方式(.lnk)文件Payload生成器.AutoIt编写 劫持注入权限绕过 https://github.com/D4Vinci/PasteJacker //剪贴板劫持利用工具 https://github.com/ChrisAD/ads-payload //利用环境变量与destop.ini绕过windows下的Palo Alto Traps https://github.com/hfiref0x/UACME //C.基于Failure-Free Method(FFM)的包含许多用于多个版本操作系统上绕过Windows用户帐户控制的方法 https://github.com/sailay1996/UAC_Bypass_In_The_Wild //利用Windows store bypass uac https://github.com/St0rn/Windows-10-Exploit //PY\\msf插件，win10 uacbypass https://github.com/Hackplayers/evil-winrm //ruby.利用WinRM shell进行soap协议传输绕过防火墙，来完成测试操作 https://github.com/NYAN-x-CAT/Disable-Windows-Defender //C#.Changing values to bypass windows defender https://github.com/tyranid/DotNetToJScript //C#.能够利用JS/Vbs脚本加载.Net程序的工具 https://github.com/Ben0xA/nps //C#.实现不调用powershell.exe执行powershell命令 https://github.com/Mr-Un1k0d3r/PowerLessShell //PY.实现不调用powershell.exe执行powershell命令 https://github.com/p3nt4/PowerShdll //使用rundll32运行PowerShell，绕过软件限制 https://github.com/ionescu007/r0ak //内核层的瑞士军刀. 在Windows10内核中读/写/执行代码 https://github.com/leechristensen/UnmanagedPowerShell //从非托管程序执行PowerShell，支持进程注入 endpoint 防护软件 shellcode相关 https://www.shellterproject.com //shellter是一款的动态Shellcode注入工具。商业版。 https://github.com/r00t-3xp10it/venom //linux下metasploit Shellcode generator/compiller。Unix/Win/Web/Apk/IOS/MSoffice多种类型生成 https://github.com/secretsquirrel/the-backdoor-factory //PY/C.通过填充无用数据空间，后门程序shellcode生成，dll程序劫持。NoUpdate https://github.com/DimopoulosElias/SimpleShellcodeInjector //C.以十六进制的方式执行shellcode，绕过杀软。 https://github.com/clinicallyinane/shellcode_launcher/ //C++.加载shellcode方式的payload到内存 https://github.com/Zer0Mem0ry/RunPE //C++.通过内存读取，网络传输内容，利用PE执行shellcode https://github.com/brimstone/go-shellcode //GO.加载载荷到内存 https://github.com/TheWover/donut //C.将.Net程序集生成shellcode并以内存的形式加载运行 https://github.com/Mr-Un1k0d3r/DKMC/ //Don’t kill my cat.生成混淆的shellcode，将shellcode存储在多语言图像中 https://github.com/Rvn0xsy/Cooolis-ms //PY.Cooolis-ms 是一个支持Metasploit Framework RPC的一个服务端，用于给Shellcode和PE加载器工作，在一定程度上绕过反病毒软件的静态查杀，同时可以让Cooolis-ms服务端与Metasploit服务器进行分离。 https://github.com/Cooolis/Cooolis.github.io //Cooolis是一个操作系统命令技巧备忘录包含工具。qingxuan。https://cooolis.payloads.online 提权相关 https://github.com/AlessandroZ/BeRoot //PY.通过检查常见的错误配置来查找提权方法. 支持Windows/Linux/Mac https://github.com/lawrenceamer/0xsp-Mongoose //PHP.提权枚举工具包，通过webApi上报信息。 Linux提权相关 https://github.com/Ignitetechnologies/Privilege-Escalation //Linux下的提权方法总结 https://github.com/rebootuser/LinEnum //bash.对Linux系统可提权检测。goodjob,2k。Github:linuxprivchecker; https://github.com/jondonas/linux-exploit-suggester-2 //perl.查找linux哪些补丁没有打，存在提权利用。Github:linux-exploit-suggester; https://github.com/belane/linux-soft-exploit-suggester //查找linux那些软件有漏洞 https://github.com/SecWiki/linux-kernel-exploits //linux-kernel-exploits Linux平台提权漏洞集合，CVE与年份对照排列。3k。G:xairy/kernel-exploits;G:Kabot/Unix-Privilege-Escalation-Exploits-Pack/; https://guif.re/linuxeop //linux提权命令集合 https://github.com/mschwager/0wned //PY.利用python包进行高权限用户创建 https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs //C.脏牛提权漏洞exp集合wiki。Github:DirtyCow-EXP;dirtycow.ninja。2.3k。 https://github.com/euphrat1ca/CVE-2016-5195 //C++,GO.脏牛提权漏洞exp，Linux 平台 和 Android 平台。release。 https://github.com/jas502n/CVE-2018-17182 //Linux 内核VMA-UAF 提权漏洞（CVE-2018-17182） https://github.com/stanleyb0y/sushell //利用su小偷实现低权限用户窃取root用户口令 https://github.com/jas502n/CVE-2018-17182/ //Linux 内核VMA-UAF 提权漏洞 CVE-2018-17182 https://github.com/jas502n/CVE-2018-14665 //CVE-2018-14665，linux下Xorg X服务器提权利用 https://github.com/nmulasmajic/syscall_exploit_CVE-2018-8897 //Linux系统利用Syscall实现提权 https://github.com/can1357/CVE-2018-8897 //Linux系统利用Syscall实现提权 https://github.com/nilotpalbiswas/Auto-Root-Exploit //linux自动提权脚本 https://github.com/WazeHell/PE-Linux //Linux提权工具 Windows提权利用相关 http://www.fuzzysecurity.com/tutorials/16.html //windows平台教程级提权参考文章 https://github.com/bitsadmin/wesng //PY.WES-NG，全称为Windows ExploitSuggester - Next Generation，该工具的运行基于Windows systeminfo实用工具的输出，可以给用户提供目标操作系统可能存在的漏洞列表，并针对这些漏洞给出漏洞利用实施建议。该工具的适用系统范围从Windows XP到Windows 10，还包括Windows Server等服务器/工作站版本。1k。 https://github.com/rasta-mouse/Sherlock //PS.win提权漏洞验证。1k。 https://github.com/SecWiki/windows-kernel-exploits //Windows平台提权漏洞Exp集合 https://github.com/51x/WHP //windows下各种提权与利用工具 https://github.com/taviso/ctftool/ //C.利用Windows文本服务框架（TSF）下CTF文本服务协议实现权限提升、沙箱逃逸、读写输入内容等。 https://github.com/WindowsExploits/Exploits //微软CVE-2012-0217、CVE-2016-3309、CVE-2016-3371、CVE-2016-7255、CVE-2017-0213提权利用 https://github.com/SandboxEscaper/polarbearrepo //C++.Win 10计划任务本地权限提升、win server 2016-2019提权 https://github.com/breenmachine/RottenPotatoNG //C++.CVE漏洞编号：CVE-2016-3225，烂土豆ms16-075利用NBNS本地域名欺骗和WPAD代理欺骗提权 https://github.com/decoder-it/lonelypotato //RottenPotatoNG变种，利用NBNS本地域名欺骗和WPAD代理欺骗提权 https://github.com/ohpe/juicy-potato //RottenPotatoNG变种，利用com对象、用户token进行提权 https://github.com/foxglovesec/Potato //RottenPotatoNG变种，利用本地域名欺骗和代理欺骗提权 https://github.com/DanMcInerney/icebreaker //处于内网环境但又在AD环境之外，icebreaker将会帮助你获取明文Active Directory凭据（活动目录存储在域控服务器可用于提权） https://github.com/hausec/ADAPE-Script //Active Directory权限提升脚本 https://github.com/klionsec/BypassAV-AllThings //利用aspx一句话配合提权payload提权 https://github.com/euphrat1ca/ms15-051 //C++.Windows 内核模式驱动程序中的漏洞可能允许特权提升 (3057191)，WS03-08。release。 https://github.com/sam-b/CVE-2014-4113 //利用Win32k.sys内核漏洞进行提取，ms14-058 https://github.com/unamer/CVE-2018-8120 //影响Win32k组件，针对win7和win2008提权 https://github.com/alpha1ab/CVE-2018-8120 //在win7与win2k8的基础上增加了winXP与win2k3 https://github.com/0xbadjuju/Tokenvator //使用Windows令牌提升权限的工具，提供一个交互命令行界面 https://github.com/dirkjanm/PrivExchange //PY.基于impacket，利用exchange提升system权限。Abusing Exchange: One API call away from Domain。CVE-2019-1040 文件捆绑 https://github.com/islamadel/bat2exe //VB.将bat文件转换为exe二进制文件。 https://github.com/tywali/Bat2ExeConverter //将bat文件转换为exe二进制文件 https://github.com/Juntalis/win32-bat2exe //将bat文件转换为exe二进制文件 http://www.f2ko.de/downloads/Bat_To_Exe_Converter.zip //将bat文件转换为exe二进制文件，可以隐藏窗口。 https://github.com/r00t-3xp10it/trojanizer //将两个可执行文件打包为自解压文件，自解压文件在执行时会执行可执行文件 https://github.com/r00t-3xp10it/backdoorppt //将payload更换图标 https://github.com/r00t-3xp10it/FakeImageExploiter //将payload更换图标。需要wine与resourcehacker环境 https://github.com/DamonMohammadbagher/FakeFileMaker //更换图标和名称 https://github.com/deepzec/Bad-Pdf //生成一个pdf文件，内含payload来窃取win上的Net-NTLM哈希 https://github.com/3gstudent/Worse-PDF //向PDF文件中插入恶意代码，来窃取win上的Net-NTLM哈希 数据取回隐秘传输 https://github.com/TryCatchHCF/Cloakify //躲避DLP/MLS数据泄露防护系统，突破数据白名单控制，躲避AV检测进行数据盗取 https://github.com/sensepost/DET //使用单个或多个通道同时执行数据取回 https://github.com/Arno0x/DNSExfiltrator //利用DNS解析进行数据隐秘传输的工具 https://github.com/Arno0x/ReflectiveDnsExfiltrator //反射DNS解析隐蔽通道进行数据泄露 https://github.com/ytisf/PyExfil //用于数据取回的Python软件包 无线通讯安全 https://github.com/OpenATS/OpenATS //C++.无线电卫星天线追踪系统。 -https://github.com/open-sdr/openwifi //C.焦博士的首款开源Wi-Fi基带芯片设计openwifi https://cn0xroot.com/2019/10/17/build_2g_3g_4g_5g_with_sdr/ //汇总：通过软件无线电构建自己的2-5G基站 | Build your own 2G 3G 4G 5G BTS with SDR。雪碧无线电通信软硬件。 https://github.com/torvalds/linux/blob/master/drivers/net/macsec.c //C.利用Linux macsec进行链路层流量安全加密 https://github.com/srsLTE/srsLTE //C++.开源通讯基站系统.G:RangeNetworks/openbts; https://unicorn.360.com/hackcube/ //360独角兽无线电安全研究院 http://www.right.com.cn/forum/ //恩山无线论坛 通讯安全RFID/SDR/NFC http://www.freebuf.com/news/others/605.html //RFID Hacking–资源大合集 https://github.com/samyk/magspoof //信用卡信息盗取 https://github.com/xcicode/MifareOneTool //C#.简称“M1T”，用于读卡和写卡，配合USB转TTL驱动。 https://github.com/RadioWar/NFCGUI //C#.图形化NFC协议安全分析工具，主要针对Mifare卡，基于libnfc完成，支持所有基于PN532芯片解决方案。Ganso稳定版，Pangu加强版。 https://github.com/LennyLeng/RadioEye //RFID配合常见的NFC使用 https://github.com/Proxmark/proxmark3/ //RFID神器PM3 https://github.com/UnicornTeam/hackcube //独角兽实验室SDR硬件渗透测试平台。G:UnicornTeam/HackCube-Special; https://www.gnuradio.org/ //软件无线电信号处理方案。W:PlutoSDR;G:Nuand/bladeRF;G:jopohl/urh; https://github.com/osqzss/gps-sdr-sim //使用ADALM-Pluto/bladeRF/HackRF/USRP等软件平台进行GPS信号模拟 https://github.com/EttusResearch/uhd //C++.USRP（Universal Software Radio Peripheral，通用软件无线电外设），伪基站。 https://github.com/mossmann/hackrf //C.低成本软件无线电平台,greatscottgadgets.com (官网)。G:sharebrained/portapack-hackrf; WIFI网络审计测试 http://topspeedsnail.com //常见的wifi破解、网站扫描技术演示 https://www.wifislax.com //西班牙wifi审计系统，国内汉化版为无线革新5.1.1 Wifislax-WRC。wifi kali系统类 https://cn.elcomsoft.com/ewsa.html //ewsa，wifi嗅探，握手包密码还原，EWSA-173-HC1UW-L3EGT-FFJ3O-SOQB3 http://www.rt68.cn/ //小林无线，在线握手跑包 https://www.passcape.com //wifipr，握手包密码还原，另外还有windows下密码还原工具。商业版。 https://github.com/MisterBianco/BoopSuite //无线网络审计工具，支持2-5GHZ频段 https://github.com/aircrack-ng/aircrack-ng //C.由数据包嗅探器、检测器、WPA / WPA2-PSK 解密器、WEP 和用于 802.11 无线局域网的分析工具组成。1k。 https://github.com/t6x/reaver-wps-fork-t6x //wps跑pin码攻击，常见wifi攻击 https://github.com/derv82/wifite2 //wifite无线审计工具升级版，联动aircrack-ng与reaver https://github.com/savio-code/fern-wifi-cracker //无线安全审计工具 https://github.com/P0cL4bs/WiFi-Pumpkin //无线安全渗透测试套件 https://github.com/entropy1337/infernal-twin //自动化无线攻击工具Infernal-Wireless https://github.com/m4n3dw0lf/PytheM //Python网络/渗透测试工具 https://github.com/InfamousSYN/rogue //无线网络攻击工具包 https://github.com/chrisk44/Hijacker //手机wifi测试工具 https://www.zimperium.com/zanti-mobile-penetration-testing //手机wifi渗透工具 https://github.com/0v3rl0w/e013 //VB.窃取Wifi密码. https://github.com/cls1991/ng //PY.获取你当前连接wifi的密码与ip https://github.com/wi-fi-analyzer/fluxion //窃取用户wifi密码的进行密码重放攻击 WIFI网络防御 https://github.com/SkypLabs/probequest //嗅探和显示无线网卡附近的Wifi Probe请求 https://github.com/wangshub/hmpa-pi //在树莓派或路由，利用 Wireshark 扫描附近网络 WiFi 设备，当有手机或其它 Wi-Fi 设备在附近时，通过邮件或者微信提醒 https://github.com/besimaltnok/PiFinger //检查wifi是否为\u0026quot;Wifi-Pineapple大菠萝\u0026quot;所开放的恶意热点 https://github.com/WiPi-Hunter/PiSavar //利用PineAP，对于FAKE AP虚假接入点，如\u0026quot;Wifi-Pineapple大菠萝\u0026quot;进行监测 https://bbs.pediy.com/thread-246627.htm //打造Wi-Fi “DOS”攻击工具——Wi-Fi_deauther。类似于大菠萝 https://github.com/SYWorks/waidps //PY.Linux下WiFi网络安全预警工具。 硬件安全物理设备HID https://shop.hak5.org/ //硬件设备商店 https://www.arduino.cc/en/Main/Software //Arduino开发工具(arduino IDE)是一个基于开放原始码的软硬体平台,构建于开放原始码simple I/O介面版,并且具有使用类似于Java,C语言的Processing/Wiring开发环境。一般是开发版本要相对应IDE版本 https://www.balena.io/etcher/ //C.USB Live烧录，rufus。10K. https://lr3800.com/2017/01/15/使用电蚊拍diy-usbkill/ //USBKiller电子杀手 https://github.com/0katz/CVE-2019-12476 //JS.HID绕过win10登录界面，利用浏览器调用powershell https://github.com/insecurityofthings/jackit //用于Mousejack的开发代码 https://github.com/samratashok/Kautilya //PS.为人机接口设备提供各种有效负载的工具包 https://github.com/O-MG/DemonSeed/ //利用hid伪造恶意苹果数据线 https://www.jianshu.com/p/a6927ffe0a20 //adb破解安卓锁屏密码。利用recovery对.key文件进行绕过 https://github.com/mame82/LOGITacker //C.利用LOGITacker，通过RF枚举测试来挖掘Logitech无线输入设备的漏洞。 https://github.com/knownsec/gsm //GO.使用树莓派配合硬件来进行短信转发 https://github.com/Orange-Cyberdefense/fenrir-ocd //使用树莓派绕过有线802.1x保护并使你能够访问目标网络 https://openwrt.org/ //C.针对嵌入式设备的Linux操作系统。G:coolsnowwolf/lede Lean\u0026rsquo;s OpenWrt 中文; https://github.com/spacehuhn/esp8266_deauther/ //C.WiFi安全审计，硬件WiFi ddos https://github.com/tomacwrt/tomacwrt.github.io //基于OpenWRT的渗透工具，配合Nexx WT3020F等类似于TP-LinkMR3040的路由。 物理设备BadUsb https://heimdalsecurity.com/blog/badusb-exploit-vulnerability-fix/ //badusb防御 https://ducktoolkit.com/ //BadUsb\\橡皮鸭\\HID键盘模拟器 https://github.com/hak5darren/USB-Rubber-Ducky/wiki //badusb编写 https://github.com/whid-injector/WHID //C++.基于ESP的WiFiHID注入器。G:spacehuhn/wifi_ducky;G:sensepost/USaBUSe WifiHID注入器，测信道C2C通信;G:basic4/WiDucky; https://www.cnblogs.com/k1two2/p/7083159.html //C.基于esp8266、Atmega 32u4等开发板进行WiFiHID无线连接、在线编辑脚本的WiFiBadusb。testjob。Con:K1two2@Qq.Com; https://github.com/ebursztein/malusb //创建跨平台的HID欺骗payload，并在Windows和OSX上建立反向TCP-shell https://github.com/mame82/P4wnP1_aloa //在树莓派Raspberry Pi上安装常用的测试组件，打造移动测试平台 https://github.com/euphrat1ca/CVE-2019-12476 //P4wnP1_aloa插件.利用域用户重置密码缺陷，绕过win10登录界面，利用浏览器调用powershell执行命令. https://www.freebuf.com/geek/195631.html //intro.成为物理黑客吧！利用树莓派实现P4wnP1项目进行渗透测试 https://github.com/mame82/P4wnP1 //在树莓派安装网络劫持键盘注入(WHID)工具,testjob. https://github.com/360PegasusTeam/GhostTunnel //可在隔离环境下使用HID生成隐蔽后门，释放有效负载后删除自身 https://lr3800.com/2017/10/18/实战-teensy-烧录间谍-u-盘/ //实战 Teensy 烧录间谍 U 盘。G:lr3800/teensy; https://github.com/rawrly/JuiceJacking //BASH.JuiceJacking,利用USB等人机接口设备窃取数据 https://github.com/kenvix/USBCopyer //C#.U盘文件自动拷贝usb copy https://github.com/RedDrip7/USB-Bootkit //物理接触目标计算机时，将恶意USB设备隐蔽的接入到目标计算机硬件设备内（如主板、USB外部设备等）。内置在隐蔽USB设备中的Bootkit攻击代码，在计算机启动时优先于操作系统运行，从而劫持系统加载过程，实现隐蔽的Bootkit攻击。 车联网智能汽车安全 https://github.com/jaredthecoder/awesome-vehicle-security //一个用于了解车辆安全和汽车黑客的资源清单 https://github.com/pasta-auto //智能汽车测试 https://github.com/schutzwerk/CANalyzat0r //PY.专有汽车协议的安全分析工具包 https://github.com/jgamblin/CarHackingTools //BASH.汽车黑客工具箱，汽车信息调查 IoT物联网安全 https://iot-security.wiki/ //伏宸安全实验室 物联网安全百科 https://github.com/V33RU/IoTSecurity101 //IoT工业物联网安全学习的一些文章和资源。文章、搜索引擎工具、博客、视频、ctf靶场、协议包、数据库、固件样本 https://github.com/fkie-cad/awesome-embedded-and-iot-security //嵌入式与iot安全 https://www.freebuf.com/articles/terminal/203311.html //智能摄像头安全分析及案例参考 http://zeroyu.xyz/2019/08/15/How_to_start_IoT_Reverse/index.html //IoT固件逆向入门。常用工具介绍 https://www.freebuf.com/news/153580.html //物联网安全研究之一：IoT架构介绍 https://github.com/hslatman/awesome-industrial-control-system-security //工控系统安全方向优秀资源收集仓库 https://blog.attify.com //Attify关于firmware固件安全，IoT安全相关文章 https://github.com/adi0x90/attifyos //AttifyOS物联网设备渗透测试系统。iot kali系统类。 https://github.com/threat9/routersploit //PY3.类msf物联网漏洞利用框架。 https://github.com/dhondta/dronesploit //PY3.基于sploitkit无人机测试框架。 https://github.com/shodan-labs/iotdb //nmap配合shodan API扫描IoT设备 https://github.com/ElevenPaths/HomePWN //PY.瑞士军刀类型IOT设备安全测试 设备固件安全 https://github.com/scriptingxss/EmbedOS //基于OVF格式的嵌入式安全测试虚拟机。预装IoTGoat固件测试环境、测试方法与工具 https://github.com/scriptingxss/owasp-fstm/ //OWASP固件安全测试条例 https://www.pentestpartners.com/security-blog/how-to-do-firmware-analysis-tools-tips-and-tricks/ //固件硬件逆向分析方法技巧 https://www.jianshu.com/p/3b3df82500b6 //绿盟马良：智能设备漏洞挖掘中几个突破点 http://blog.nsfocus.net/handbook-safety-analysis-intelligent-equipment/ //绿盟：智能设备安全分析手册.pdf https://github.com/attify/firmware-analysis-toolkit //基于attify规则的iot仿真系统测试工具集，包含firmadyne、Binwalk、Firmware-Mod-Kit、MITMproxy 、Firmwalker组件。 https://github.com/firmadyne/firmadyne //bash,PY.基于Linux的iot固件仿真与分析平台。 https://paper.seebug.org/613/ //工控漏洞挖掘方法之固件逆向分析 https://github.com/unprovable/PentestHardware //硬件渗透测试实用手册 https://github.com/cwerling/psptool //PY.分析和解析AMD安全处理器的固件工具包 https://www.amobbs.com/thread-5703833-1-1.html //【正点原子】XCOM串口调试助手软件 https://github.com/nodemcu/nodemcu-flasher //Pascal.firmware Flash tool for nodemcu，包括“ESP8266Flasher.exe”。 智能设备安全 https://github.com/yaseng/iot-security-wiki/ //物联网安全百科。伏宸安全实验 https://github.com/vletoux/SpoolerScanner //检测 Windows 远程打印机服务是否开启的工具 https://github.com/RUB-NDS/PRET //PY2.打印机攻击框架，利用PostScript，PJL和PCL，捕获或操作打印作业，访问打印机的文件系统和内存，甚至对设备造成物理损坏。W:打印机漏洞研究入门;SmartDeviceMonitor打印机设备监控;。2k。 https://github.com/rapid7/IoTSeeker //物联网设备默认密码扫描检测工具 摄像头安全 https://github.com/woj-ciech/kamerka //PY.调用shodan API将扫描到的摄像头地理位置，与twitter地理显示在地图上 https://github.com/Ullaakut/cameradar //GO.针对摄像头RTSP协议渗透测试，附弱口令字典 https://github.com/Ullaakut/camerattack //GO.摄像头远程禁用 https://github.com/NIteshx2/UltimateSecurityCam //PY3.摄像头监测外来人员软件，有防欺骗设置 http://www.dtxiaoting.com //扫描连接的WiFi中摄像头存在情况 路由网关安全 http://stascorp.com/search/?q=Router+Scan //Pascal.RouterScan毛子开发的路由器漏洞利用工具，界面化。GoodJob. https://github.com/jh00nbr/Routerhunter-2.0 路由器漏洞扫描利用。NoUpdate https://github.com/googleinurl/RouterHunterBR //PHP.路由器设备漏洞扫描利用 https://github.com/scu-igroup/telnet-scanner //Telnet服务密码撞库 https://github.com/Viralmaniar/Passhunt //PY.simple。用于搜索网络设备Web应用程序等的默认凭证。包含523个厂家的2084组默认密码 ICS工控安全 https://collaborate.mitre.org/attackics/index.php/Main_Page //ICS工业安全 ATT\u0026amp;CK矩阵类. http://jzgkchina.com //剑指工控 工控基础知识。W:linuxscada.info; https://www.freebuf.com/ics-articles //工控相关文章 https://www.freebuf.com/articles/network/178251.html //工控安全现场实施经验谈之工控系统如何加强主机防护 http://www.freebuf.com/sectool/174567.html //工业控制系统（ICS）安全专家必备的测试工具和安全资源 https://github.com/ITI/ICS-Security-Tools //工控安全资源。国内外文章、脚本、固件、协议库、数据包、相关工具。G:euphrat1ca/ICSwiki; https://github.com/hslatman/awesome-industrial-control-system-security //Industrial Control System (ICS) security安全集 http://www.icsmaster.org/archives/ics/942 //工控安全工具集。G:w3h/icsmaster; https://www.controlthings.io/ //SamuraiSTFU ics kali https://github.com/moki-ics/moki //一键配置类似于kali的工控渗透测试系统的脚本 https://github.com/SadFud/Exploits //PY/BASH.PWN利用框架 CTFs exploit POCs.工控漏洞POC https://gitlab.com/expliot_framework/expliot //PY3.工控安全漏洞测试框架 https://github.com/dark-lbp/isf //PY2.基于routersploit基础开发的ISF(Industrial Control System Exploitation Framework)。wenzheZhu https://github.com/w3h/isf //py2.基于Fuzzbunch命令行基础开发的工控测试框架。工匠实验室。 https://dragos.com/community-tools/ //工业网络安全公司 Dragos Inc.发布的Integrity（Sophia）被动ICS网络资产发现，Cyber​​Lens关于ICS数据包处理\\捕获\\可视化显示。 https://github.com/nsacyber/GRASSMARLIN //Grassmarlin是一款由美国国家安全局开发的，能够帮助运维工程师在IP网络上发现并编目监控和数据采集系统（SCADA）和工业控制系统（ICS）主机的开源软件工具，也被称为被动网络映射器。其数据源十分多样化，包括PCAP文件、路由器和交换机配置文件、CAM表以及实时网络数据包的捕获。该工具能够自动识别可用网络，生成网络拓扑，实现主机间通信的可视化，还能够展示从主机通信中所提取的元数据。 https://github.com/digitalbond/Redpoint //ICS识别所用nse脚本 https://github.com/XHermitOne/icscanner //界面化ics扫描器 ics 西门子S7安全 http://snap7.sourceforge.net/ //以太网32/64位多平台S7 PLC通信套件 https://www.freebuf.com/articles/ics-articles/212283.html //intro.西门子S7通信过程及重放攻击分析。利用snap7与isfs7300进行重放测试。 https://www.freebuf.com/articles/ics-articles/188159.html //工控安全 | 西门子通信协议S7COMM（Part 1） https://github.com/hslatman/awesome-industrial-control-system-security/blob/master/source/s7-cracker.py //s7密码爆破 ics scada安全 https://github.com/nezza/scada-stuff //对SCADA/ICS设备进行逆向与攻击 https://github.com/0xICF/SCADAShutdownTool// //工业控制系统自动化和测试工具，允许安全研究人员和专家测试SCADA安全系统，枚举从属控制器，读取控制器的寄存器值并重写寄存器数据。 ics modbus安全 https://github.com/yanlinlin82/plcscan //通过TCP/102和TCP/502识别互联网上PLC设备和其他Modbus设备 https://github.com/ezelf/modbusKiller //py.Schneider Dos PLC Modicon via Modbus Injection。CVE-2017-6017。Github:Exploit-install/smod。 工控模拟仿真 https://github.com/thiagoralves/OpenPLC_v3 //C++.最基本plc 移动安全 https://github.com/Brucetg/App_Security //App安全学习资源 https://github.com/OWASP/owasp-mstg OWASP Mobile Security Testing Guide移动安全测试资源 https://github.com/MobSF/Mobile-Security-Framework-MobSF //软件自动化审计框架，支持docker运行。android、ios、win https://github.com/mwrlabs/drozer //PY.MWR Labs开源Android 安全测试框架，支持编写自定义模块。 https://github.com/nccgroup/house //JS,PY.运行时手机 App 分析工具包， 带Web GUI 移动端渗透测试框架 https://github.com/nettitude/scrounger //PY.Linux下iOS和Android移动应用程序渗透测试框架 https://gitlab.com/kalilinux/nethunter/build-scripts/kali-nethunter-project //移动端KaliHunter手机渗透测试系统 https://github.com/cSploit/android //JAVA.cSploit: Android network pentesting suite手机渗透工具框架，可兼容msf https://github.com/euphrat1ca/Smartphone-Pentest-Framework //PY/C/C++.SPF移动端渗透测试框架，支持电话通讯协议SS7漏洞利用，进行远程SS7指令操作。Web:shevirah.com/dagah/; https://github.com/metachar/PhoneSploit //PY.通过shodan搜索开启调试模式的安卓设备，利用Adb控制安卓设备。 https://termux.com/ //Termux是一个Android下一个高级的终端模拟器,开源且不需要root,支持apt管理软件包。 https://github.com/Gameye98/Lazymux //PY2.通过Termux打造免root安卓渗透工具 Android/Java安全 https://github.com/frida/frida/ //PY\\JAVA.Frida是一款通过JavaScript代码注入应用程序的跨平台hook框架，二进制逆向动态调试。Github:dweinstein/awesome-frida;G:andreafioraldi/frida-fuzzer;。testjob。 https://github.com/sensepost/objection //PY.移动端动态调试安全检测，Frida公司开发。testjob。 https://github.com/hluwa/ZenTracer //PY.frida插件，Android方法调用追踪 https://github.com/lyxhh/lxhToolHTTPDecrypt //js.基于frida/Burp/flask的app渗透测试，利用HTTP协议，识别app加密算法，解密数据包，调用Burp。 https://github.com/rovo89/Xposed //C++.Android动态修改hook，隐藏root执行权限。 https://github.com/Fuzion24/JustTrustMe //Java.基于xposed模块进行app证书SSL注入抓包。 https://taichi.cool/ //Android魔改框架，可加载 Xposed 模块、修改系统和APP、拦截方法，执行 hook 逻辑等。支持免root与Magisk模式。 https://github.com/asLody/VirtualApp //JAVA.android魔改框架，支持软件层模拟系统安装xposed等模块。greatjob。 https://github.com/android-hacker/VirtualXposed //JAVA.基于VirtualApp 和 epic 免root使用xposed https://github.com/Genymobile/scrcpy //C.基于adb连接使pc控制Android设备 https://github.com/zsdlove/ApkVulCheck //PY3.对安卓apk进行特征值匹配。justsoso。 https://github.com/jboss-javassist/javassist //JAVA.能够操作字节码框架，通过它我们能很轻易的修改class代码文件。2.2K https://github.com/programa-stic //基于Androguard 及Static Android Analysis Framework 的Android App静态分析引擎。 https://github.com/WooyunDota/DroidSSLUnpinning //安卓证书锁定解除的工具 https://github.com/crifan/android_app_security_crack //安卓应用的安全和破解。goodjob。 IOS/macOS安全 https://github.com/axi0mX/ipwndfu //PY.checkm8利用ios底层全版本越狱 https://github.com/dmayer/idb //RUBY.开源的iOS App安全评估工具，作者是Danl A.Mayer。 https://github.com/mwrlabs/needle //PY.MWR Labs开发的一个开源iOS安全测试框架，同样支持开发自定义模块来扩展Needle的功能，目前主要功能包含对iOS应用数据存储，IPC.网络通信，静态代码分析，hooking及二进制文件防护等方面的安全审计。 https://github.com/GeoSn0w/OsirisJailbreak12 //IOS12不完全越狱 https://github.com/chaitin/passionfruit //iOS应用逆向与分析工具，可以大大加速iOS应用安全分析过程 https://sukarodo.me/gr00t/ //IOS12全版本越狱工具 https://github.com/samyk/frisky //针对 ios/mac OSX 应用的嗅探/修改/逆向/注入等工具 https://github.com/LinusHenze/Keysteal //C++.窃取MacOS下KeyChain。CVE-2019-8526 https://github.com/coffeehb/Some-PoC-oR-ExP/blob/master/check_icmp_dos.py //CVE-2018-4407，macos/ios缓冲区溢出可导致系统崩溃 逆向分析破解 https://www.pelock.com/articles/reverse-engineering-tools-review //Reverse engineering tools review 逆向工具测评 https://down.52pojie.cn/ //吾爱破解爱盘工具包。 https://www.peerlyst.com/posts/resource-learning-how-to-reverse-malware-a-guide //恶意软件逆向指南和工具的集合 https://github.com/alphaSeclab/awesome-reverse-engineering //Reverse Engineering Resources About All Platforms(Windows/Linux/macOS/Android/iOS/IoT)3000+逆向资源合集. PC端逆向二进制文件分析 https://github.com/ReFirmLabs/binwalk //PY.固件、二进制、pwn等文件自动化识别与逆向，支持多插件配置。goodjob,5k。 http://www.sweetscape.com/010editor/ //识别不同文件格式（模板）的16进制编辑器，具有文件修复功能。 https://www.x-ways.net/winhex/ //Winhex是一款的十六进制编辑器，在计算机取证，数据恢复，低级数据处理。 https://www.hex-rays.com //IDA pro反汇编工具。商业版。 https://youtu.be/qCQRKLaz2nQ //IDA pro教学视频 https://github.com/xrkk/awesome-ida //IDA Pro有关的资源收集 https://github.com/NationalSecurityAgency/ghidra //JAVA.NSA出品的软件逆向动态调试框架Ghidra，类比IDA https://github.com/dark-lbp/vxhunter //PY.利用IDA Pro 7.x与Ghidra 9.0.1和VxWorks对硬件设备进行调试 https://github.com/ghidraninja/ghidra_scripts //YARA,PY.Ghidra的Binwal\\Yara联动插件 https://github.com/angr/angr //PY.二进制分析工具,支持动态符号执行和静态分析。3k。 https://github.com/radare/radare2 //C.radare2是基于Capstone的跨平台逆向工程平台。包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等。10k。goodjob。 https://github.com/radareorg/cutter //C++.基于QT的radare2框架GUI。5k。 https://github.com/armijnhemel/binaryanalysis-ng //PY3.Binary Analysis Toolkit（BAT）。对固件、二进制、pwn等文件进行递归式解压缩实现识别与逆向。goodjob,0.1k。 https://github.com/x64dbg/x64dbg //C++.x96 Windows调试工具。greatjob。34k。W:immunityinc.com，Immunity Debugger;32位汇编分析调试器Ollydbg;G:horsicq/x64dbg-Plugin-Manager;。 查脱壳分析PE操作 https://github.com/horsicq/Detect-It-Easy //C.官网 ntinfo.biz，PE侦壳工具可以查看EXE/DLL文件编译器信息、是否加壳、入口点地址、输出表/输入表等信息。W:exeinfo.xn.pl https://ntcore.com/?page_id=388 //PE32 \u0026amp; PE64编辑工具，支持.NET文件格式。 https://github.com/rednaga/APKiD //YARA.查找Android应用程序标识符的封隔器，保护器，混淆器 - PEiD for Android. http://www.legendsec.org/1888.html //pkid查壳工具，APK查壳工具PKID ApkScan-PKID。 https://github.com/DrizzleRisk/drizzleDumper //Android脱壳工具。G:TUnpacker;G:BUnpacker;G:halfkiss/ZjDroid; https://www.jianshu.com/p/6a504c7928da //Android常见App加固厂商脱壳方法的整理 汇编反编译框架 https://github.com/endgameinc/xori //RUST.自定义反汇编框架，PE32, 32+ and shellcode。 https://github.com/blacknbunny/peanalyzer32 //PY3.PE 文件分析和反汇编工具 https://github.com/aquynh/capstone //C.Capstone是一个轻量级的多平台多架构支持的反汇编框架。支持包括ARM，ARM64，MIPS和x86/x64平台。4k。 https://github.com/joxeankoret/pyew //PY.基于Capstone的深度代码分析和文件修改工具。支持PE、ELF、OLE2、PDF等格式，并且支持自定义插件 VB/易语言/C#逆向 https://github.com/icsharpcode/ILSpy //C#.针对exe反编译软件。8k。goodjob。 https://github.com/0xd4d/dnSpy //C#.dnSpy is a debugger and .NET assembly editor https://www.vb-decompiler.org/products/cn.htm //VB Decompiler是针对Visual Basic 5.0/6.0开发的程序反编译器 Python逆向 https://sourceforge.net/projects/pyinstallerextractor //PY.pyinstaller .exe反编译为 .pyc https://github.com/countercept/python-exe-unpacker //PY.Linux下py2exe or pyinstaller打包解压缩 http://tools.bugscaner.com/decompyle //.pyc或 .pyo文件在线反编译 https://github.com/rocky/python-uncompyle6 //PY3.支持Python version 1.3 to version 3.7源码反编译，*.pyc。 https://github.com/wibiti/uncompyle2 //PY2.针对python2.7源码反编译 https://sourceforge.net/projects/easypythondecompiler //Easy Python Decompiler利用 \u0026ldquo;Uncompyle2\u0026rdquo; \u0026amp; \u0026ldquo;Decompyle++\u0026quot;，支持.pyc 1.0 - 3.4源码反编译，GUI界面。 https://github.com/zrax/pycdc //C++.Linux全版本*.pyc反编译。 Java逆向 https://github.com/java-decompiler/jd-gui //JAVA.java反编译工具。7k。 https://github.com/skylot/jadx //JAVA.jd-gui升级版，反编译出来的代码未格式化。20k。 https://github.com/deathmarine/Luyten //JAVA.格式化java反编译后代码，解决jd的INTERNAL ERROR问题。3k。 https://github.com/pxb1988/dex2jar //JAVA. android/.dex/.class java文件逆向反编译 安卓逆向APK分析 https://www.jianshu.com/p/a12d04fc748f //Android逆向分析大全 https://securityoversimplicity.wordpress.com/2017/04/29/android-reversing-part-2-tools/ // https://www.andreafortuna.org/2019/07/18/reverse-engineering-and-penetration-testing-on-android-apps-my-own-list-of-tools/ // https://www.pd521.com //逆向未来，android逆向菜鸟速参手册完蛋版，AndroidKiller安卓逆向工具。P:apk改之理; https://github.com/iBotPeaches/Apktool //java.Android逆向apk反编译工具.8K. https://github.com/UltimateHackers/Diggy //bash.基于apktool反编译后正则匹配从 Apk 文件中提取 URLs 的工具。simple 系统监控管理 https://docs.microsoft.com/en-us/sysinternals/ //Windows Sysinternals套件系统管理。autorun（自启动）、Process Explorer（进程管理定位加强）、procmon、procdump（监控应用程序的CPU异常动向, 并在此异常时生成crash dump文件） http://www.xuetr.com/ //PC Hunter是一个驱动级的系统维护工具，能够查看各种Windows的各类底层系统信息，包括进程、驱动模块、内核、内核钩子、应用层钩子，网络、注册表、文件、启动项、系统杂项、电脑体检等。pchunter down4.huorong.cn/hrsword.exe //火绒剑。W:process monitor; https://github.com/mohuihui/antispy //C/C++.枚举32位系统中隐藏至深的进程、文件、网络连接、内核对象等，并且也可以检测用户态、内核态各种钩子 https://github.com/draios/sysdig //C++.系统活动监控，捕获和分析应用程序。它具有强大的过滤语言和可自定义的输出，以及可以使用称为chisels 的Lua脚本扩展的核心功能，sysdig.com。goodjob。6k。 https://github.com/kkamagui/shadow-box-for-arm //C/PY.ARM架构Linux系统监控，同仓库还有shadow-box-for-x86架构系统监控 https://github.com/osquery/osquery //C++.Facebook创建的SQL驱动操作系统检测和分析工具，支持像SQL语句一样查询系统的各项指标，如运行进程/加载内核模块/网络连接/浏览器插件/硬件事件/文件哈希等，osquery.io。14k。 https://www.crystalidea.com/uninstall-tool //Windows卸载，软件安装跟踪。P:CCleaner; http://emptyloop.com/unlocker/ //右键扩充工具，通过删除文件和程序关联的方式解除文件的占用。在解除占用时不会强制关闭占用文件进程 程序调试进程管理 https://www.cheatengine.org //CE（Cheat Engine）是一款内存修改编辑工具，程序函数监控，配合Ultimap功能食用更佳 http://www.angusj.com/resourcehacker //Windows二进制文件浏览编辑 (*.exe; *.dll; .scr; etc) 和资源文件修改 (.res, *.mui)图标属性等。Resource Hacker类似于于Restorator文件资源修改软件。 https://github.com/euphrat1ca/PeDoll //C++.基于inlineHook技术的软件分析工具，C/S架构 https://github.com/everdox/InfinityHook //C++.挂钩系统调用，上下文切换，页面错误等。 系统日志相关 http://www.nirsoft.net/utils/computer_activity_view.html //LastActivityView是一款电脑操作记录查看器，直接调用系统日志，显示安装软件、系统启动、关机、网络连接、执行exe 的发生时间和路径 https://github.com/SwiftOnSecurity/sysmon-config //Sysmon配置文件。系统进程监控，dns查询。 系统注册表监控 https://sourceforge.net/projects/regshot/ //Regshot是注册表比较工具，通过抓取两次注册表快速比较得出两次注册表的不同之处 系统进程 https://bitsum.com/ 系统优化工具，主要功能是基于其特别的算法动态调整各个进程优先级以实现为系统减负的目的，可以用来监视进程动作 https://www.portablesoft.org/ //可以Unlock占用文件的进程，查看文件或文件夹被占用的情况，内核模块和驱动的查看管理，进程模块的内存dump等工具 https://github.com/processhacker/processhacker //C.监控系统资源、内存以及模块信息、软件调试，管理进程 https://github.com/DominicBreuker/pspy //GO.Linux下绕过root权限监控进程运行.GOODJOB. https://github.com/rabbitstack/fibratus //PY.能够捕捉到绝大多数的Windows内核活动-进程/线程创建和终止，上下文转换，文件系统I/O，寄存器，网络活动以及DLL加载/卸载等。 https://github.com/open-falcon //GO/PY.Falco是一款由Sysdig开源的进程异常行为检测工具。它既能够检测传统主机上的应用程序，也能够检测容器环境和云平台（主要是Kubernetes和Mesos）。Github:falcosecurity/falco; 系统文件 https://www.zynamics.com/software.html //BinDiff发现反汇编代码中的差异和相似之处。支持x86、MIPS、ARM/AArch64、PowerPC等架构进行二进制文件对比 http://www.beyondcompare.cc/xiazai.html //Beyond Compare是Scooter Software推出的文件比较工具。主要用于比较两个文件夹或者文件并将差异以颜色标记，比较的范围包括目录，文档内容等 数字取证 https://github.com/alphaSeclab/awesome-forensics //取证相关工具和文章。收集的所有开源工具: sec-tool-list;逆向资源: awesome-reverse-engineering;网络相关的安全资源: awesome-network-stuff;攻击性网络安全资源: awesome-cyber-security;开源远控和恶意远控分析报告: awesome-rat;Webshell工具和分析/使用文章: awesome-webshell; https://github.com/laramies/metagoofil //PY.从文件获取相关网站的用户名与邮箱等数据。documents (pdf,doc,xls,ppt,etc) https://github.com/mozilla/mig //go.火狐mozilla基金会针对海量文件的内容定位工具，支持节点分级部署。Deprecation https://polytechnic.purdue.edu/facilities/cybersecurity-forensics-lab/tools //FileTSAR大规模的数据调查取证 文件取证 https://www.audacityteam.org/ //音频文件和波形图处理工具 https://github.com/redaelli/imago-forensics //PY2.将照片中Exif、MIME等信息提取存入CSV/sqlite中 http://www.magicexif.com/ //将照片图像中的exif信息数据化 http://mediaarea.net/MediaInfo //类似于exiftool来查看内容区域和元数据信息 https://www.sno.phy.queensu.ca/~phil/exiftool/ //检查图像文件的exif元数据 https://www.gimp.org/ //Gimp提供了转换各类图像文件可视化数据的功能，还可以用于确认文件是否是一个图像文件 http://qpdf.sourceforge.net/ //查看pdf文件并整理提取信息 http://zipinfo.com/ //在无需提取的情况下列出了zip文件的内容信息 计算机设备取证 https://www.ontrack.com/products/data-recovery-software/ //easyrecovery文件恢复软件。商业版。易我数据恢复;RECUVA http://www.diskgenius.cn/ //数据恢复/分区管理/备份还原。商业版。 https://clonezilla.org/downloads.php //再生龙(Clonezilla)是一个免费的灾难恢复、硬盘克隆、硬盘映像档制作的部署和解决方案,由台湾的国家高速网络与计算中心(国网中心)所开发 https://www.cgsecurity.org/wiki/TestDisk //磁盘分区修复 https://github.com/decalage2/oletools //PY.用于分析MS OLE2文件（结构化存储，复合文件二进制格式）和MS Office文档 https://github.com/google/bochspwn-reloaded //Bochspwn Reloaded（内核信息泄漏检测）工具 https://github.com/comaeio/LiveCloudKd //C.针对Hyper-V的内存取证 https://github.com/sevagas/swap_digger //针对 Linux swap 进行取证分析的工具 http://extundelete.sourceforge.net/ //linux下的文件恢复 https://github.com/SekoiaLab/Fastir_Collector //Windows取证/信息收集，不限于内存，注册表，文件信息等 https://github.com/Viralmaniar/Remote-Desktop-Caching- //PY.RDP信息复原，png图片格式 https://github.com/snovvcrash/usbrip //PY.Linux下带有CLI接口的开源取证工具，可用于跟踪/监控Linux机器上的USB设备连接事件（即USB事件历史记录，“已连接”和“已断开连接”事件）。 https://www.nirsoft.net/utils/usb_log_view.html //USBLogView一款USB设备监控软件，后台运行，可以记录插入或拔出系统的任何USB的详情信息 https://github.com/CrowdStrike/automactc //PY2.macOS环境自动化取证分类采集器 设备内存取证 https://github.com/google/rekall //PY.提取和分析数字Windows计算机系统 https://github.com/volatilityfoundation/volatility //PY.计算机内存取证 https://github.com/gleeda/memtriage //Windows内存取证分析 https://www.xplico.org/download //内存取证 https://my.comae.com/tools //DumpIt一款免安装的Windows内存镜像取证工具，可以使用其轻松的将一个系统的完整内存镜像下来 https://github.com/volatilityfoundation/volatility //windows内存取证分析 移动设备取证 https://github.com/viaforensics/android-forensics //安卓取证App和框架，可以对安卓设备内各种信息进行提取 https://www.freebuf.com/articles/rookie/195107.html //记一次微信数据库解密过程。微信的加密数据库的解密密码是由“设备的IMEI(MEID)+用户的uin，进行MD5，然后取其前7位小写字母”构成的 https://www.freebuf.com/news/193684.html //iOS取证技巧：在无损的情况下完整导出SQLite数据库 网络取证 https://github.com/Srinivas11789/PcapXray //py.网络取证工具，可以捕获网络数据包，并可视化为包括设备标识的网络图，并突出显示重要的通信和文件操作。 http://f00l.de/pcapfix/ //pcap文件修复 https://github.com/USArmyResearchLab/Dshell //可扩展的网络取证分析框架，支持快速开发插件与解析网络数据包捕获 https://github.com/abrignoni/DFIR-SQL-Query-Repo //收集用于数据取证的SQL查询模板 https://github.com/davidmcgrew/joy //用来捕获和分析内外网流量数据的包，主要用于进行网络调查、安全监控和取证 https://www.netresec.com/?page=Networkminer ////网络取证分析工具，通过嗅探或者分析PCAP文件可以侦测到操作系统，主机名和开放的网络端口主机，解析http 2与TLS加密。产品包括网络取证与监控caploader 流量捕获、polarproxy tls加密流量代理等 协议解析流量分析数据还原 http://www.colasoft.com.cn/download.php //科来科来网络分析系统/ping工具/mac地址扫描工具/数据包重放工具/数据包生成工具 https://github.com/wireshark/wireshark //LUA.议解析流量分析还原。可通过Windows变量名“SSLKEYLOGFILE”的变量导出目标网站证书，进行密钥导入到Wireshark流量解析。 http://www.tcpdump.org //网络数据包截获分析 http://lcamtuf.coredump.cx/p0f3 //C.p0f升级版，被动的流量指纹识别TCP/http https://github.com/zeek/zeek //C++.bro的升级版，主要用于对链路上所有深层次的可疑行为流量进行安全监控，为网络流量分析提供了一个综合平台，特别侧重于语义安全监控。 https://github.com/0x4D31/fatt //PY.利用tshark对流量进行解析 https://github.com/netxfly/xsec-traffic //GO.轻量级的恶意流量分析程序，包括传感器sensor和服务端server 2个组件。 http://tcpick.sourceforge.net //TCP流嗅探和连接跟踪工具 https://github.com/secdev/scapy //PY.内置了交互式网络数据包处理、数据包生成器、网络扫描器网络发现和包嗅探工具，提供多种协议包生成及解析插件，能够灵活的的生成协议数据包，并进行修改、解析。 https://gitee.com/qielige/openQPA //协议分析软件QPA的开源代码，特点是进程抓包、特征自动分析 https://github.com/zerbea/hcxdumptool //从Wlan设备上捕获数据包 https://github.com/NytroRST/NetRipper //支持截获像putty，winscp，mssql，chrome，firefox，outlook，https中的明文密码 https://github.com/shramos/polymorph //支持几乎所有现有协议的实时网络数据包操作框架 https://github.com/nospaceships/raw-socket-sniffer //C.PS.无需驱动抓取Windows流量 https://github.com/netsniff-ng/netsniff-ng //C.a fast zero-copy analyzer,pcap捕获和重放工具 常用报文库开源协议库 https://wiki.wireshark.org/SampleCaptures/ //wireshark维护的报文Captures，包括许多工控协议库等 https://securityonion.readthedocs.io/en/latest/pcaps.html //安全洋葱维护的回溯pcap列表。securityonion-docs https://asecuritysite.com/forensics/pcap //站点内容包含密码学与数字取证 http://packetlife.net/captures/ //站点内容包括协议cheat sheet导图 http://speed.cis.nctu.edu.tw/pcaplib/ //NCTU国立交通大学。聊天/邮件/加解密/文件/网络/流媒体/web https://www.netresec.com/?page=PcapFiles //netresec公司维护pcap包文库。攻防演练流量、恶意软件流量、网络取证靶场流量、SCADA/ICS工控靶场模拟流量、测信道中间人注入。 CTF相关(Capture The Flag) https://ctftime.org //CTF排名比赛介绍 https://ctf-wiki.github.io/ctf-wiki/ //CTFwiki，Misc/Crypto/Web/Assembly/Executable/Reverse/Pwn/Android/ICS https://firmianay.gitbooks.io/ctf-all-in-one //CTF-All-In-One 《CTF 竞赛入门指南》。西电信安协会 https://www.butian.net/School //补天培训。CTF/攻防/硬件/社工/开发/代码审计。goodjob https://github.com/adon90/pentest_compilation //ctf比赛与OSCP考试中常见的知识点和命令 https://github.com/Hacker0x01/hacker101 //RUBY.hacker one联名的Web攻防教学，有ctf靶场和视频.10K https://github.com/balsn/ctf_writeup //CTF writeups from Balsn https://github.com/susers/Writeups //国内玩各大CTF赛题及writeup整理。Github:hongriSec/CTF-Training;Github:balsn/ctf_writeup; https://edwardchoijc.github.io/CTF线下AWD经验总结.html/ //CTF攻防AWD经验总结 https://github.com/NEALWE/AWD_FrameWork //PY2.awd框架，比赛常用脚本。 CTF靶场平台 https://github.com/facebook/fbctf //HACK,PHP.CTF比赛平台搭建。 https://github.com/CTFd/CTFd //py2.基于flask的动态Capture The Flag framework https://github.com/zhl2008/awd-platform //AWD攻防比赛平台 https://github.com/gabemarshall/microctfs //SHELL,JS.小型ctf镜像docker https://github.com/giantbranch/pwn_deploy_chroot //PY.部署多个pwn题到一个docker容器中 https://github.com/PELock/CrackMeZ3S-CTF-CrackMe-Tutorial //C++.为CTF比赛编写CrackMe软件 CTF隐写术 https://www.freebuf.com/sectool/208781.html //将任意文本隐藏在音频视频图片和文本中的多种方式 https://0xrick.github.io/lists/stego/ //隐写术工具集，Steganography - A list of useful tools and resources。包括隐写工具，解析工具 https://github.com/DominicBreuker/stego-toolkit //隐写工具包。Stegosuite https://github.com/livz/cloacked-pixel //PY2.LSB图片数据隐藏 http://www.caesum.com/handbook/Stegsolve.jar //Java.图片隐写查看器，多图层查看器 二进制pwn利用CTF https://github.com/Gallopsled/pwntools //PY.pwn类型，二进制利用框架 https://github.com/ChrisTheCoolHut/Zeratool //PY.pwn类型，二进制利用框架 https://github.com/ChrisTheCoolHut/Rocket-Shot //PY.pwn，自动攻击脚本 安全体系防护相关 https://github.com/Bypass007/Safety-Project-Collection //收集一些比较优秀的开源安全项目，以帮助甲方安全从业人员构建企业安全能力。welljob。 https://github.com/baidu/AdvBox //Advbox是支持多种深度学习平台的AI模型安全工具箱，既支持白盒和黑盒算法生成对抗样本，衡量AI模型鲁棒性，也支持常见的防御算法 https://github.com/quoscient/octopus //区块链智能合约安全分析工具 https://github.com/trimstray/otseca //linux系统审计工具，可以导出系统配置，生成报表 https://github.com/mwrlabs/dref //DNS 重绑定利用框架 https://github.com/chengr28/Pcap_DNSProxy/blob/master/README.zh-Hans.md //Pcap_DNSProxy 是一个基于 WinPcap/LibPcap 用于过滤 DNS 投毒污染的工具 https://github.com/PlagueScanner/PlagueScanner //python.集成ClamAV、ESET、Bitdefender的反病毒引擎 https://github.com/m4rco-/dorothy2 //一款木马、僵尸网络分析框架 https://github.com/jumpserver/jumpserver //Python3.开源堡垒机 https://github.com/github/glb-director //负载均衡组件GLB，数据解析使用了dpdk https://github.com/TKCERT/mail-security-tester //检测邮件防护与过滤系统的测试框架 https://github.com/chaitin/sqlchop-http-proxy //利用HTTP 反向代理，内置 SQLChop 作为 SQL 注入攻击检测模块，可以拦截 SQL 注入流量而放行正常流量 https://github.com/OWASP/SecureTea-Project //当有人私自触碰电脑鼠标或触摸板，进行报警 https://github.com/openitsystem/itops //PY3/DJANGO.AD\\Exchange管理系统 https://github.com/tmobile/pacbot //JAVA.云平台自动化安全监控工具 https://github.com/mydlp //MyDLP是一种简单，简单和开放的DLP（数据丢失预防）解决方案 https://www.alienvault.com/products/ossim //开源开源信息安全管理系统siem安全运维平台解决方案，支持snort\\nmap等多种工具插件 https://github.com/ossec/ossec-hids //C.开源hids（主机入侵检测）堡垒机 入侵检测感知防护 http://m.imooc.com/article/21236 //快速自检电脑是否被黑客入侵过(Windows版) http://www.freebuf.com/articles/system/157597.html //快速自检电脑是否被黑客入侵过（Linux版） http://www.freebuf.com/rookie/179638.html //服务器入侵溯源小技巧整理 https://bithack.io/forum/161 //intro.如何通过一封恶意邮件追踪幕后黑客组织。邮件掉鱼、溯源、攻击者落地 https://github.com/chaitin/yanshi //C++.长亭偃师（yanshi），雷池（SafeLine）防火墙核心引擎使用到的代码生成工具，规则自动生成判断器械 https://github.com/0Kee-Team/WatchAD //PY.360 信息安全中心 0kee Team 域安全入侵感知系统，能够及时准确发现高级域渗透活动，检测覆盖内网攻击杀伤链大部分手法。 EDR终端主机防护 http://edr.sangfor.com.cn/ //深信服。SfAntiBotPro内存检索工具，可以根据输入的字符串快速检索计算机内存，输出包含该字符串的进程信息，在进行恶意域名检测时有事半功倍的效果 http://edr.topsec.com.cn/ //天融信终端威胁防御系统 NSM网络安全监控/入侵检测 https://github.com/baidu/openrasp //基于RASP。Runtime Application Self-Protection，实时应用自我保护，智能针对每个语言定制。testjob,1k。 https://github.com/Security-Onion-Solutions/security-onion //Security Onion洋葱安全入侵检测系统。基于Ubuntu，涵盖ELK\\Snort\\Suricata\\Bro等组件，系统作为传感器分布在网络中监控多个VLAN和子网。hids kali系统类。 https://github.com/snort3/snort3 //C++.snort知名NIDS网络入侵检测 https://github.com/ptresearch/AttackDetection //更新中的snort规则rules https://github.com/OISF/suricata //C.IDS\\IPS\\NSM安全工具，兼容Snort插件 https://github.com/iqiyi/qnsm //C/C++.基于dpdk与Suricata，旁路部署的全流量引擎，集成了DDOS检测和IDPS模块。 https://labs.360.cn/malwaredefender/ //HIPS (主机入侵防御系统)软件，用户可以自己编写规则来防范病毒、木马的侵害。另外，Malware Defender提供了很多有效的工具来检测和删除已经安装在您的计算机系统中的恶意软件 https://documentation.wazuh.com //C.wazuh是C/S架构开源主机入侵检测系统网络安全平台，支持日志收集、文件监控、恶意软件检测、漏洞基线检测等。 https://github.com/StamusNetworks/SELKS //基于Debian的入侵检测系统，组件包含Suricata IDPS与ELK和Scirius https://github.com/grayddq/HIDS //主机型入侵检测系统。一个人的安全部 https://github.com/ysrc/yulong-hids //YSRC开源的驭龙HIDS主机入侵检测系统 https://github.com/EBWi11/AgentSmith-HIDS //c.Linux下基于Hook system_call的内核级HIDS，特点从内核态获取尽可能全的数据。welljob。 无线网络入侵检测 https://github.com/anwi-wips/anwi //无线IDS， 基于低成本的Wi-Fi模块(ESP8266) https://github.com/SYWorks/waidps //PY.Linux下无线网络入侵检测工具 防火墙/waf/网关规则 https://github.com/0xInfection/Awesome-WAF //awesome waf http://www.safedog.cn/ //安全狗web防火墙。商业版。 http://d99net.net/ //D盾防火墙，包含waf与webshel检测功能。商业版。P:xoslab.com 内核级检测文件生成写入; https://www.pfsense.org //PHP.可配置snort规则的防火墙。社区版。 https://github.com/evilsocket/opensnitch //PY/GO.基于QT界面Linux下的应用防火墙 https://github.com/SpiderLabs/ModSecurity //C.跨平台 WAF engine for Apache/IIS/Nginx等 https://github.com/klaubert/waf-fle //ModSecurity Web控制台 https://github.com/SpiderLabs/owasp-modsecurity-crs //GO/C.owasp关于ModSecurity等防火墙规则库 https://github.com/xsec-lab/x-waf //适用于中小企业的云waf https://github.com/jx-sec/jxwaf //lua.JXWAF(锦衣盾)是一款基于openresty(nginx+lua)开发的web应用防火墙，独创的业务安全防护引擎和机器学习引擎可以有效对业务安全风险进行防护，解决传统WAF无法对业务安全进行防护的痛点。Github:starjun/openstar;Github:xsec-lab/x-waf;Github:loveshell/ngx_lua_waf;Github:starjun/openstar; https://github.com/Janusec/janusec //Golang.应用安全网关，具备WAF、CC攻击防御、证书私钥加密、负载均衡、统一Web化管理等功能。 https://github.com/qq4108863/himqtt/ //C.物联网epoll高并发防火墙 Bypass安全防护绕过 https://github.com/AMOSSYS/Fragscapy //PY.防火墙fuzz绕过bypass https://github.com/kirillwow/ids_bypass //IDS Bypass 脚本 https://github.com/milo2012/ipv4bypass //利用ipV6地址绕过waf https://github.com/3xp10it/bypass_waf //防火墙绕过脚本 https://github.com/swisskyrepo/PayloadsAllTheThings //A list of useful payloads and bypass for Web Application Security and Pentest/CTF https://github.com/sirpsycho/firecall //直接向CiscoASA防火墙发送命令， 无需登录防火墙后再做修改 https://blog.xpnsec.com/evading-sysmon-dns-monitoring/ //INTRO.规避Sysmon DNS监控 CDN识别绕过真实IP获取 https://github.com/BugScanTeam/DNSLog //py.基于django监控 DNS 解析记录和 HTTP 访问记录的工具，可以配合盲注、xss、解析对方真实ip使用 https://github.com/al0ne/Vxscan //PY3.目录扫描/js泄露接口，WAF/CDN识别，端口扫描，指纹/服务识别，操作系统识别，弱口令探测，POC扫描，SQL注入，绕过CDN，查询旁站。0.5k。 https://github.com/boy-hack/w8fuckcdn //PY.基于masscan通过扫描全网绕过CDN获取网站IP地址 https://github.com/3xp10it/xcdn //尝试找出cdn背后的真实ip，3xp10it.github.io 博客 https://github.com/christophetd/CloudFlair //PY.利用dns与api进行cloudflare绕过，获取真实ip，集成censys。Github:CloudFail;Github:Cloudmare.1K。 https://github.com/Nitr4x/whichCDN //CDN识别、检测 https://github.com/se55i0n/PortScanner //PY2.目标tcp端口快速扫描、banner识别、cdn检测。 https://github.com/yanxiu0614/subdomain3 //py.子域名，IP，CDN信息爆破 https://github.com/m0rtem/CloudFail //PY.利用错误配置的dns请求与历史dns解析记录查找CloudFlare后的真实IP 沙盒虚拟化容器云平台 http://www.linux-kvm.org //Linux内核虚拟化工具，支持unix/win等多种系统 https://www.qemu.org //纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。qemu-kvm为虚拟机管理工具 https://github.com/moby/moby //GO.Linux下虚拟容器dockerCE。54k。 https://github.com/containers/libpod //GO.podman.io虚拟容器。3k。 https://github.com/hashicorp/vagrant //RUBY.管理虚拟机。19k。 https://www.virtualbox.org //跨平台多系统支持 https://www.vmware.com //跨平台多系统支持。ESXI虚拟化平台管理工具。商业版。 http://www.eve-ng.net //UnifiedNetworking Lab统一网络实验室。基于Ubuntu深度定制。商业版。 https://github.com/zstackio/zstack //Java.类似openstack基于kvm与vmware的虚拟化云管理框架。商业版。 https://www.proxmox.com/ //类似virtualbox的开源虚拟化平台，自带防火墙、邮件网关。 大数据平台安全 https://github.com/shouc/BDA //针对hadoop/spark/mysql等大数据平台的审计与检测 https://github.com/wavestone-cdt/hadoop-attack-library //hadoop测试方式和工具集 代码审计应用测试 https://www.joinfortify.com //HP出品的源代码安全审计工具Fortify SCA通过将其它语言转换成一种中间媒体文件NST（Normal Syntax Trcc），将源代码之间的调用关系、执行环境、上下文等分析清楚。通过匹配所有规则库中的漏洞。商业版。goodjob。 https://securitylab.github.com/tools/codeql //GitHub开源代码审计，插件、函数库形式 https://github.com/microsoft/ApplicationInspector //C#.基于规则代码安全审计 https://github.com/pumasecurity/puma-scan //C#.Visual Studio插件，实时代码审计 https://github.com/wufeifei/cobra //PY.源代码安全审计,支持PHP、Java等开发语言，并支持数十种类型文件。 https://github.com/securego/gosec //go.Go语言源码安全分析工具 https://github.com/GoSSIP-SJTU/TripleDoggy //C.c/c++/object-c源代码检测框架，支持接口调用 https://github.com/presidentbeef/brakeman //Ruby on Rails应用静态代码分析 JS代码审计应用安全 https://github.com/RetireJS/grunt-retire //js.js扩展库漏洞扫描 https://github.com/Aurore54F/JaSt //使用语法检测恶意/混淆的JS文件，https://www.blackhoodie.re/assets/archive/JaSt_blackhoodie.pdf https://github.com/ctxis/beemka //针对Electron App的漏洞利用工具包 https://github.com/doyensec/electronegativity //Electron应用代码审计，App的错误配置和安全问题 php代码审计应用安全 https://github.com/euphrat1ca/SeaySourceCodeCheck //C#.PHP代码审计,法师Seay源代码审计系统2.1版本.noupdate. https://github.com/OneSourceCat/phpvulhunter //php.静态php代码审计.noupdate. https://github.com/ripsscanner/rips //php.php代码审计工具.noupdate. https://github.com/chuan-yun/Molten //C.PHP应用透明链路追踪工具。G:Qihoo360/phptrace; https://github.com/elcodigok/wphardening //py.WordPress插件代码审计 python代码审计应用安全 https://github.com/ga0/pyprotect //C++.给python代码加密，防止逆向 https://github.com/pyupio/safety //PY.检查所有已安装 Python包，查找已知的安全漏洞 https://github.com/facebook/pyre-check/ //PY3.facebook推出的Zoncolan基本版python代码静态审计工具。号称30分钟扫描一亿行代码库，bug漏洞都能找。 https://github.com/shengqi158/pyvulhunter //PY.基于G:yinwang0/pysonar2的Python应用审计.NOUPDATE. https://github.com/PyCQA/bandit //PY.python代码安全漏洞审计 https://github.com/python-security/pyt //PY.用于检测Python Web应用程序中的安全漏洞的静态分析工具 欺骗防御 https://github.com/paralax/awesome-honeypots //开源蜜罐收集 https://www.freebuf.com/articles/paper/207739.html //intro.开源蜜罐测评报告 https://github.com/Cymmetria //欺骗防御公司。Struts2、weblogic、telnet、Cisco ASA、Micros等仿真蜜罐，honeycomb低交互蜜罐框架 https://www.freebuf.com/sectool/204652.html //基于EVE-NG平台上构建企业内网攻防环境 https://www.bamsoftware.com/hacks/zipbomb/ //ZIPBOMB压缩包炸弹 https://github.com/BinaryDefense/artillery //PY.端点蜜罐防护 蜜罐安全 https://github.com/phage-nz/malware-hunting //PY.利用蜜罐进行恶意文件捕获。包含众多蜜罐使用说明 https://github.com/threatstream/mhn //PY.现代蜜网，集成了多种蜜罐的安装脚本，可以快速部署、使用，也能够快速的从节点收集数据 https://github.com/dtag-dev-sec/tpotce //T-POT.里面使用docker技术实现多个蜜罐组合，配合ELK进行研究与数据捕获 https://github.com/n3uz/t-pot-autoinstall //bash.将fork的T-POT蜜罐的一键安装脚本替换为国内加速镜像 https://www.freebuf.com/sectool/190840.html //INTRO.T-Pot多蜜罐平台使用心法 https://github.com/honeytrap/honeytrap //可扩展蜜罐框架，支持探针部署与高交互蜜罐 https://github.com/honeynet/beeswarm //PY.使用agent探针与蜜罐进行实时交互来引诱攻击者 Web服务蜜罐 https://github.com/p1r06u3/opencanary_web //PY.基于TORNADO的低交互蜜罐。支持自动化安装，目前支持常见的16种协议，采用探针/蜜罐-管理的架构。可以考虑二次开发为探针-沙盒-管理的架构 https://gitlab.com/SecurityBender/webhoneypot-framework //PY3.基于docker和docker-compose，现支持wordpress/drupal https://github.com/mushorg/snare //PY3.web安全蜜罐，可克隆指定Web页面 https://github.com/netxfly/x-proxy //GO.代理蜜罐的开发与应用实战。simple 服务蜜罐 https://github.com/micheloosterhof/cowrie //PY2.使用ELK（ElasticSearch，LogStash，Kibana）进行数据分析，目前支持ssh，telnet，sftp等协议 https://github.com/desaster/kippo //PY.蜜罐系统HoneyDrive下的图形化SSH蜜罐。1k。 https://github.com/thinkst/opencanary //PY2.SNMP\\RDP\\SAMBA蜜罐 https://github.com/gosecure/pyrdp //PY3.RDP MITM蜜罐 https://gosecure.net/2018/12/19/rdp-man-in-the-middle-smile-youre-on-camera/ //INTRO.基于PYRDP,打造可记录图像和按键的RDP蜜罐 https://blog.csdn.net/ls1120704214/article/details/88174003 //GO.反击mysql蜜罐。利用MySQL LOCAL INFILE读取客户端文件漏洞分析并使用Golang编写简易蜜罐;从MySQL出发的反击之路;Github:MysqlT，支持大文件无损传输，支持用户验证，支持自定义的 Mysql 版本，随机的盐加密，加上用户验证，让攻击者毫无察觉;Github:Rogue-MySql-Server https://github.com/leeberg/BlueHive //PS.利用Active Directory生成用户账户蜜罐 https://github.com/hacklcs/HFish //GO.redis\\MYSQL\\SSH\\GitHub蜜罐 http://www.imooc.com/article/26398 //NodeJS 应用仓库钓鱼。同理可应用于python库\\apache module 后门等，相关诱饵名称可设置为加解密模块等，或者直接dns劫持。 摄像头蜜罐 https://github.com/alexbredo/honeypot-camera //PY.摄像头蜜罐。tornado模拟WEB服务，图片代替视频，可以考虑后期多加点图片和按钮 https://github.com/EasyDarwin/EasyIPCamera //C.RTSP服务器组件用以构建摄像头蜜罐 工控蜜罐 https://github.com/sjhilt/GasPot //模拟油电燃气工控系统 https://github.com/djformby/GRFICS //IoT工业仿真系统模拟框架，采用MODBUS协议对PLC虚拟机监视和控制 https://github.com/RabitW/IoTSecurityNAT //IoT测试系统，方便快速接入各种设备，进行安全测试 https://github.com/mushorg/conpot //针对ICS/SCADA的低交互工控蜜罐，模拟Modbus和S7comm https://github.com/trombastic/PyScada/ //PY2.基于Django的SCADA操作管理系统 沙盒检测恶意样本分析 https://github.com/cuckoosandbox/cuckoo //PY/JS。自动恶意软件分析系统 https://github.com/euphrat1ca/Panda-Sandbox //PY.钟馗沙箱是基于cuckoo的适配国内软件环境的恶意软件分析系统 https://www.sandboxie.com //基于转换存储的沙盒。社区版。 https://github.com/felicitychou/MalAnalyzer //PY3.基于docker虚拟化的恶意代码沙箱 恶意软件/文件样本数据 https://github.com/open-power-workgroup/Hospital //全国莆田系医院名单 https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_MalwareSample.md/ //恶意样本数据源收集库。myWiki 在线文件检测 https://app.any.run/ //可视化在线恶意文件检测。包含流行恶意文件样本 https://habo.qq.com //在线恶意文件检测 http://r.virscan.org/ //在线杀毒 https://www.appscan.io //盘古app安全移动软件在线检测 http://safe.ijiami.cn //爱加密app安全移动软件在线检测 http://appscan.360.cn //360移动app安全移动软件在线检测 https://service.security.tencent.com/kingkong //腾讯金刚app安全移动软件在线检测 恶意文件查杀 https://www.freebuf.com/articles/network/139697.html //intro.使用深度学习检测DGA（域名生成算法） https://github.com/mwleeds/android-malware-analysis //PY.利用机器学习进行恶意Android安卓应用检测 https://github.com/he1m4n6a/findWebshell //PY.webshell检查工具，可添加后门指纹。 https://github.com/ym2011/ScanBackdoor //一款简洁的Webshell扫描工具 https://github.com/erevus-cn/scan_webshell //webshell扫描工具 https://github.com/yassineaddi/BackdoorMan //可对指定目录进行php webshell检测 https://github.com/nbs-system/php-malware-finder //一款高效率PHP-webshell扫描工具 https://github.com/emposha/PHP-Shell-Detector //测试效率高达99%的webshell检测工具 https://github.com/chaitin/cloudwalker //GO.CloudWalker（牧云）服务器安全管理平台，主要针对webshell查杀。 https://github.com/emposha/Shell-Detector //Webshell扫描工具，支持php/perl/asp/aspx webshell扫描 http://www.chkrootkit.org/ //多方位后门/僵木蠕/rootkit检测工具 http://rkhunter.sourceforge.net/ //后门排查。系统命令（Binary）检测/包括Md5 校验/Rootkit检测/本机敏感目录、系统配置、服务及套间异常检测/三方应用版本检测 http://rootkit.nl/projects/rootkit_hunter.html //rootkit检测工具 https://github.com/KasperskyLab/klara //卡巴斯基开源基于Yara的分布式恶意软件扫描系统， https://github.com/botherder/kraken //GO.实现的Yara恶意软件扫描器 https://github.com/netxfly/sec_check 通过信息采集（账户、连接、端口等）与yara扫描进行安全检测 https://github.com/nao-sec/tknk_scanner yara引擎为基础的恶意软件识别框架 https://github.com/viper-framework //PY2.二进制分析和管理框架，对恶意文件进行分析 https://github.com/Tencent/HaboMalHunter //哈勃分析系统，linux系统病毒分析及安全测试 http://www.clamav.net/downloads //病毒查杀软件 https://github.com/joxeankoret/pigaios //直接对比源代码与编译的二进制文件 https://github.com/felixweyne/ProcessSpawnControl //PS.对恶意程序进行检测与监控 https://github.com/sfaci/masc //扫描网站中的恶意软件， 以及其他一些网站维护功能 https://github.com/Neo23x0/munin //依据文件 Hash 从各种在线恶意软件扫描服务提取信息的工具 https://github.com/1lastBr3ath/drmine //自动化检测网页是否包含挖矿脚本的工具 https://github.com/alexandreborges/malwoverview //simple，将恶意文件进行快速分类 https://github.com/Neo23x0/Loki //一款APT入侵痕迹扫描器 https://github.com/target/strelka //PY3.通过实时扫描文件进行分析和实时监测。 压力测试DDOS/CC/拒绝服务 https://github.com/ywjt/Dshield //PY.DDOS防护 https://github.com/NewEraCracker/LOIC/ //C#.基于Praetox\u0026rsquo;s LOIC project的压测工具，使用mono进行跨平台 https://github.com/IKende/Beetle.DT //C#.分布式压力测试工具 https://github.com/649/Memcrashed-DDoS-Exploit //PY.利用shodan搜索Memcached服务器进行压力测试 https://github.com/jseidl/GoldenEye //PY.DOS测试 https://github.com/mschwager/dhcpwn //PY.DHCP/IP压力测试 https://github.com/Microsoft/Ethr //GO.跨平台，TCP， UDP， HTTP， HTTPS压力测试工具 https://github.com/Markus-Go/bonesi //C.模拟僵尸网络进行ICMP/UDP/TCP/HTTP压测 https://github.com/ajmwagar/lor-axe RUST，多线程、低带宽消耗的HTTP DoS工具 https://github.com/EZLippi/WebBench //C.网站压力测试，最高并发3万 https://github.com/jagracey/Regex-DoS //RegEx拒绝服务扫描器 https://github.com/algo7/bluekeep_CVE-2019-0708_poc_to_exploit //PY.RDP服务远程命令执行/DOS攻击/蓝屏exp http://www.yykkll.com //压测站评测 https://defconpro.net //# https://vip-boot.xyz/login.php //# https://rocketstresser.com/login.php //多协议，支持cdn测试 wiki_FreeConnect https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_FreeConnect.md/ //通讯工具技术相关.myWiki wiki_Selfsource https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_Selfsource.md/ //自服务应用在线资源、文件\\url\\节点检测.myWiki wiki_TipSkill https://github.com/euphrat1ca/security_w1k1/blob/master/wiki_TipSkill.md/ //计算机技术相关.myWiki https://www.anquanke.com/opensource //GitHub安全类目引擎，热度，时间 https://github.com/We5ter/Scanners-Box //增加条目，细化分类。4k。 https://github.com/topics/security //GitHub安全类目 https://xj.hk //星际黑客。 https://www.8aq.net/ //先知;freebuf http://wiki.ioin.in/ //sec-news 安全文摘 https://start.me //情报源。P:p/X20Apn;P:p/GE7JQb/osint;P:p/rxRbpo/ti。 https://www.osint-labs.org //S.R.P OSINT-Labs开源情报实验室 https://www.xssav.com //安全网址导航 https://sec.thief.one //安全热点聚合平台 TheEnd\n","date":"2023-09-18T13:42:00+08:00","image":"/lihan3238.github.io/p/computernetworksecuritylaboratory/lab_hu1273d08991f93a7031c7d21a0b0d5c77_47988_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/computernetworksecuritylaboratory/","title":"网安实验室相关资料链接"},{"content":"在学习编程与计算机知识过程中遇到的有趣的字符串\nHello World “Hello, World!”程序通常指一类输出或显示“Hello, World!”（你好，世界！）字符串的计算机程序。在大多数通用编程语言中，这样的程序只有一小段代码，因此可以用来展示该编程语言的基本语法。“Hello, World!”往往是初学者学习某种编程语言所接触的第一个程序内容，同时它也是用来确认原始码编译器、程序开发或运行环境是否已经安装妥当并被操作者理解的常用手段。\nHello World Lorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum，简称为Lipsum，是指一篇常用于排版设计领域的拉丁文文章，主要的目的为测试文章或文字在不同字型、版型下看起来的效果。中文的类似用法则称为乱数假文、随机假文。\nLorem ipsum 2006-01-02 15:04:05 go语言中的时间格式化字符串，这个时间也许是go语言的诞生时间。\n1月2号下午3点4分5秒2006年 ","date":"2023-09-17T13:54:00+08:00","image":"/lihan3238.github.io/p/funnycodingstring/funnycoding_hucaff0f688dece6afd1893c1858b1d149_8395_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/funnycodingstring/","title":"有趣的字符串"},{"content":"ginWeb框架学习(ubuntu22.04.3) 代码仓库 gin gin官网 gin中文文档 gin安装与环境配置 安装gin 1 2 3 4 # 切换国内代理 GOPROXY=https://goproxy.cn,direct # 安装gin go get -u github.com/gin-gonic/gin 安装postman postman官网 用于调试post请求接口用\n测试gin是否安装成功 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { router := gin.Default() router.GET(\u0026#34;/index\u0026#34;, func(context *gin.Context) { context.String(200, \u0026#34;Hello lihan!\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) } 1 2 3 4 5 # 运行 go run main.go # 访问[主机地址]:8080/index # 例如 127.0.0.1:8080/index # 显示 Hello World! 则安装成功 gin教程 gin启动方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func Index2(context *gin.Context) { context.String(200, \u0026#34;Hello lihan2!\u0026#34;) } func main() { //创建一个默认路由引擎 router := gin.Default() //注册一个路由和处理函数，访问/index的路由时，会执行后面的匿名函数 router.GET(\u0026#34;/index\u0026#34;, func(context *gin.Context) { context.String(200, \u0026#34;Hello lihan!\u0026#34;) }) //另一种方法，可以直接使用已经声明的函数 router.GET(\u0026#34;/index2\u0026#34;, Index2) //启动HTTP服务,gin会默认把web服务器运行在本机的0.0.0.0:8080端口上(即所有网卡IP的8080端口) router.Run(\u0026#34;:8080\u0026#34;) //第二种启动方式，用原生http服务的方式启动，这种方式可以实现更多的自定义配置 //http.ListenAndServe(\u0026#34;:8080\u0026#34;, router) } gin视图 view 响应 response 状态码 状态码 1 2 3 4 5 6 7 8 9 10 11 12 200 表示正常响应 http.StatusOk //常见状态码 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 //状态码分类 1**\t信息，服务器收到请求，需要请求者继续执行操作 2**\t成功，操作被成功接收并处理 3**\t重定向，需要进一步的操作以完成请求 4**\t客户端错误，请求包含语法错误或无法完成请求 5**\t服务器错误，服务器在处理请求的过程中发生了错误 返回字符串 1 2 3 router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;你好啊！\u0026#34;) }) 返回json 重点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //main.go router.GET(\u0026#34;/json\u0026#34;, ginJson) //ginJson函数 func ginJson(c *gin.Context) { //json响应结构体 type UserInfo struct { UserName string `json:\u0026#34;username-json\u0026#34;` //返回给前端的字段名 Age int `json:\u0026#34;age_json\u0026#34;` PassWord string `json:\u0026#34;-\u0026#34;` //\u0026#34;-\u0026#34;不会返回给前端 } //user := UserInfo{\u0026#34;lihan\u0026#34;, 32, \u0026#34;123456\u0026#34;} //c.JSON(200, user) //json响应map //userMap := map[string]string{ //\t\u0026#34;user_name\u0026#34;: \u0026#34;lihan\u0026#34;, //\t\u0026#34;age\u0026#34;: \u0026#34;32\u0026#34;, //} //c.JSON(200, userMap) //直接响应json c.JSON(200, gin.H{\u0026#34;user_name\u0026#34;: \u0026#34;lihan\u0026#34;, \u0026#34;age\u0026#34;: 32}) } 返回xml和yaml 1 2 3 4 5 6 7 8 9 10 11 12 //main.go router.GET(\u0026#34;/xml\u0026#34;, ginXml) router.GET(\u0026#34;/yaml\u0026#34;, ginYaml) //ginXml、ginYaml函数 func ginXml(c *gin.Context) { c.XML(200, gin.H{\u0026#34;user_name\u0026#34;: \u0026#34;lihan\u0026#34;, \u0026#34;age\u0026#34;: 32, \u0026#34;status\u0026#34;: http.StatusOK, \u0026#34;data\u0026#34;: gin.H{\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;lihan\u0026#34;}}) } func ginYaml(c *gin.Context) { c.YAML(200, gin.H{\u0026#34;user_name\u0026#34;: \u0026#34;lihan\u0026#34;, \u0026#34;age\u0026#34;: 32, \u0026#34;status\u0026#34;: http.StatusOK, \u0026#34;data\u0026#34;: gin.H{\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;lihan\u0026#34;}}) } 返回html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //main.go router.LoadHTMLGlob(\u0026#34;templates/*\u0026#34;) router.GET(\u0026#34;/html\u0026#34;, ginHtml) //ginHtml函数 func ginHtml(c *gin.Context) { type UserInfo struct { UserName string Age int PassWord string } user := UserInfo{\u0026#34;lihan\u0026#34;, 32, \u0026#34;123456\u0026#34;} c.HTML(200, \u0026#34;index.html\u0026#34;, user) //c.HTML(200, \u0026#34;index.html\u0026#34;, gin.H{\u0026#34;user_name\u0026#34;: \u0026#34;lihan\u0026#34;, \u0026#34;age\u0026#34;: 32, \u0026#34;status\u0026#34;: http.StatusOK, \u0026#34;data\u0026#34;: gin.H{\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;lihan\u0026#34;}}) } //gin.H()可以向html传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 {{/* templates/index.html */}} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;响应html {{ .UserName}}\u0026lt;/h1\u0026gt; {{/* \u0026lt;h1\u0026gt;响应html {{ .data.name}}\u0026lt;/h1\u0026gt; */}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 响应文件 1 2 3 4 5 6 7 8 9 10 11 12 //main.go //golang中，没有相对文件的路径，只有相对项目的路径 //配置单个文件，网页请求的路由，文件路径 router.StaticFile(\u0026#34;/downloads/lihan.png\u0026#34;, \u0026#34;static/lihan.png\u0026#34;) //配置文件夹，网页请求的路由，文件夹路径 router.StaticFS(\u0026#34;/downloads/files\u0026#34;, http.Dir(\u0026#34;static/texts\u0026#34;)) //配置js、css、图片等资源 router.Static(\u0026#34;/static\u0026#34;, \u0026#34;static\u0026#34;) //html中引用资源 \u0026lt;img src=\u0026#34;/static/resource/baidu.png\u0026#34; alt=\u0026#34;baidu\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/static/css/style.css\u0026#34;\u0026gt; 项目文件夹[gowebstudy] static texts test.txt lihan.png pwd.txt 2.gin_view视图 2.1response响应.go redirect 重定向 HTTP 301 Moved Permanently (永久重定向): 当服务器返回HTTP状态码301时，它告诉客户端请求的资源已永久移动到一个新的URL。 浏览器（或其他HTTP客户端）会记住这个永久重定向，以后的请求都会直接转向新的URL，而不再请求原始URL，可缓存。\nHTTP 302 Found (临时重定向): 当服务器返回HTTP状态码302时，它告诉客户端请求的资源已临时移动到一个新的URL。 浏览器会将这个重定向视为临时性质，因此不会记住新的URL，每次都需要重新请求原始URL，不可缓存\n1 2 3 4 5 6 //main.go router.GET(\u0026#34;/lihan\u0026#34;, ginRedirect) //ginRedirect函数 func ginRedirect(c *gin.Context) { c.Redirect(301, \u0026#34;https://lihan3238.github.io/\u0026#34;) } 请求 request Query 查询参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //main.go func _query(c *gin.Context) { fmt.Println(c.Query(\u0026#34;username\u0026#34;)) //c.GetQuery仅判断是否存在，不判断是否为空 fmt.Println(c.GetQuery(\u0026#34;username\u0026#34;)) //c.QueryArray获取全部username的值，返回一个切片 fmt.Println(c.QueryArray(\u0026#34;username\u0026#34;)) //c.DefaultQuery获取username的值，如果为空则返回默认值 fmt.Println(c.DefaultQuery(\u0026#34;id\u0026#34;,\u0026#34;default_id\u0026#34;)) } //?id=2\u0026amp;username=lihan\u0026amp;username=op func main() { router := gin.Default() router.GET(\u0026#34;/query\u0026#34;, _query) router.Run(\u0026#34;:8080\u0026#34;) } //访问：http://192.168.56.105:8080/query?id=2\u0026amp;username=lihan\u0026amp;username=op //返回： lihan lihan true [lihan op] Param 动态参数 1 2 3 4 5 6 7 8 9 10 //main.go router.GET(\u0026#34;/param/:user_id\u0026#34;, _param) router.GET(\u0026#34;/param/:user_id/:book_id\u0026#34;, _param) //_param函数 func _param(c *gin.Context) { fmt.Println(c.Param(\u0026#34;user_id\u0026#34;)) fmt.Println(c.Param(\u0026#34;book_id\u0026#34;)) } //http://192.168.56.105:8080/param/user1/book2 PostForm 表单参数 要使用Post而非Get请求 可以接收 multipart/form-data 和 application/x-www-form-urlencoded 类型的数据 1 2 3 4 5 6 7 8 9 //main.go router.POST(\u0026#34;/form\u0026#34;, _form) //_form函数 func _form(c *gin.Context) { fmt.Println(c.PostForm(\u0026#34;username\u0026#34;)) fmt.Println(c.PostFormArray(\u0026#34;id\u0026#34;)) fmt.Println(c.DefaultPostForm(\u0026#34;addr\u0026#34;, \u0026#34;default_addr\u0026#34;)) } 1 2 3 4 # 返回 lihan [123456 88888] default_addr GetRawData 获取原始参数 1 2 3 4 5 6 7 8 //main.go router.POST(\u0026#34;/rawdata\u0026#34;, _rawData) //_rawData函数 func _rawData(c *gin.Context) { //fmt.Println(c.GetRawData()) body, _ := c.GetRawData() fmt.Println(string(body)) } 1 2 # 返回 name=abcde 1 2 3 4 Content-Disposition: form-data; name=\u0026#34;name\u0026#34; abcd ----------------------------609676969091043609505229-- GetRawData 序列化Json与类型绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //main.go router.POST(\u0026#34;/rawdata2\u0026#34;, _rawData2) //_rawData2函数 func _rawData2(c *gin.Context) { body, _ := c.GetRawData() contentType := c.GetHeader(\u0026#34;Content-Type\u0026#34;) switch contentType { case \u0026#34;application/json\u0026#34;: type User struct { Username string `json:\u0026#34;name\u0026#34;` Password int `json:\u0026#34;pwd\u0026#34;` } var user User err := json.Unmarshal(body, \u0026amp;user) if err != nil { fmt.Println(err.Error()) } fmt.Println(user) } } 1 {lihan 123456} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func bandJson(c *gin.Context, obj any) (err error) { body, _ := c.GetRawData() contentType := c.GetHeader(\u0026#34;Content-Type\u0026#34;) switch contentType { case \u0026#34;application/json\u0026#34;: err := json.Unmarshal(body, obj) if err != nil { fmt.Println(err.Error()) return err } } return nil } func _rawData2(c *gin.Context) { type User struct { Username string `json:\u0026#34;name\u0026#34;` Password int `json:\u0026#34;pwd\u0026#34;` } var user User err := bandJson(c, \u0026amp;user) if err != nil { fmt.Println(err.Error()) } fmt.Println(user) } 四大请求方式 Restful风格指的是网络应用中资源定位和资源操作的风格。 不是标准，只是一种风格。\nGET : 从服务器取出资源（一项或多项） POST : 在服务器新建一个资源 PUT : 在服务器更新资源（客户端提供改变后的完整资源） PATCH(少) : 在服务器更新资源（客户端提供改变的属性） DELETE : 从服务器删除资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //以文字资源为例 //GET\t/articles\t列出所有文章 //GET\t/articles/:id\t获取文章详情 //POST\t/articles\t新建一篇文章 //PUT\t/articles/:id\t更新某篇文章的信息 //DELETE\t/articles/:id\t删除某篇文章 //main.go router.GET(\u0026#34;/articles\u0026#34;, _getList) // 文章列表 router.GET(\u0026#34;/articles/:id\u0026#34;, _getDetail) // 文章详情 router.POST(\u0026#34;/articles\u0026#34;, _create) // 新建文章 router.PUT(\u0026#34;/articles/:id\u0026#34;, _update) // 修改文章 router.DELETE(\u0026#34;/articles/:id\u0026#34;, _delete) // 删除文章 //函数 type ArticleModel struct { Title string `json:\u0026#34;title\u0026#34;` Content string `json:\u0026#34;content\u0026#34;` } type Response struct { Code int `json:\u0026#34;code\u0026#34;` Data any `json:\u0026#34;data\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` } func _bandJson(c *gin.Context, obj any) (err error) { body, _ := c.GetRawData() contentType := c.GetHeader(\u0026#34;Content-Type\u0026#34;) switch contentType { case \u0026#34;application/json\u0026#34;: err := json.Unmarshal(body, obj) if err != nil { fmt.Println(err.Error()) return err } } return nil } func _getList(c *gin.Context) { //包含搜索、分页等功能 articleList := []ArticleModel{ {Title: \u0026#34;Go语言入门\u0026#34;, Content: \u0026#34;本文是Go语言入门指南\u0026#34;}, {Title: \u0026#34;Stellarise群星攻略\u0026#34;, Content: \u0026#34;本文是Stellarise群星攻略\u0026#34;}, {Title: \u0026#34;马克思主义学习指南\u0026#34;, Content: \u0026#34;本文是马克思注意学习指南\u0026#34;}, {Title: \u0026#34;李寒个人介绍\u0026#34;, Content: \u0026#34;本文是李寒个人介绍\u0026#34;}, } //c.JSON(200, articleList) //接口封装 c.JSON(200, Response{0, articleList, \u0026#34;success\u0026#34;}) } func _getDetail(c *gin.Context) { //获取params中的id fmt.Println(c.Param(\u0026#34;id\u0026#34;)) //省略查询数据库的过程 article := ArticleModel{Title: \u0026#34;李寒个人介绍\u0026#34;, Content: \u0026#34;本文是李寒个人介绍\u0026#34;} c.JSON(200, Response{0, article, \u0026#34;success\u0026#34;}) } func _create(c *gin.Context) { //接受前端传来的JSON数据 var article ArticleModel err := _bandJson(c, \u0026amp;article) if err != nil { c.JSON(200, Response{1, nil, \u0026#34;参数错误\u0026#34;}) return } //省略插入数据库的过程 c.JSON(200, Response{0, article, \u0026#34;success\u0026#34;}) } func _update(c *gin.Context) { //获取params中的id fmt.Println(c.Param(\u0026#34;id\u0026#34;)) //省略查询数据库的过程 //接受前端传来的JSON数据 var article ArticleModel err := _bandJson(c, \u0026amp;article) if err != nil { c.JSON(200, Response{1, nil, \u0026#34;参数错误\u0026#34;}) return } //省略插入数据库的过程 c.JSON(200, Response{0, article, \u0026#34;success\u0026#34;}) } func _delete(c *gin.Context) { //省略查询数据库的过程 //获取params中的id fmt.Println(c.Param(\u0026#34;id\u0026#34;)) //省略删除数据库的过程 c.JSON(200, Response{0, map[string]string{}, \u0026#34;success\u0026#34;}) } 请求头与响应头 Request Header 请求头 请求头参数获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //获取请求头 router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { //单词首字母大小写不区分，单词之间用\u0026#34;-\u0026#34;分割 //用于获取一个请求头 fmt.Println(c.GetHeader(\u0026#34;User-Agent\u0026#34;)) fmt.Println(c.Request.Header.Get(\u0026#34;User-Agent\u0026#34;)) //fmt.Println(c.GetHeader(\u0026#34;user-agent\u0026#34;)) //fmt.Println(c.GetHeader(\u0026#34;user-Agent\u0026#34;)) //Header是一个map[string][]string类型 fmt.Println(c.Request.Header) //获取所有请求头,区分大小写 fmt.Println(c.Request.Header[\u0026#34;User-Agent\u0026#34;]) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;ok\u0026#34;}) }) 利用请求头，将爬虫和用户区别对待\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //利用请求头，将爬虫和用户区别对待 // router.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { userAgent := c.GetHeader(\u0026#34;User-Agent\u0026#34;) //方法一 正则去匹配 //字符串的包含匹配 if strings.Contains(userAgent, \u0026#34;python\u0026#34;) { //爬虫来了 c.JSON(200, gin.H{\u0026#34;data\u0026#34;: \u0026#34;这是一个爬虫\u0026#34;}) return } c.JSON(200, gin.H{\u0026#34;data\u0026#34;: \u0026#34;这是一个用户\u0026#34;}) }) Response Header 响应头 1 2 3 4 5 //设置响应头 router.GET(\u0026#34;/res\u0026#34;, func(c *gin.Context) { c.Header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/text; charset=utf-8\u0026#34;) c.JSON(200, gin.H{\u0026#34;data\u0026#34;: \u0026#34;看看响应头\u0026#34;}) }) bind绑定参数 gin中bind可以很方便地将前端传递来的数据与 结构体 进行 参数绑定 以及 参数校验。\n参数绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //ShouldBindJSON type UserInfo struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Sex string `json:\u0026#34;sex\u0026#34;` } router.POST(\u0026#34;/\u0026#34;, func(c *gin.Context) { var userInfo UserInfo err := c.ShouldBindJSON(\u0026amp;userInfo) if err != nil { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;你错\u0026#34;}) return } c.JSON(200, userInfo) }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //ShouldBindQuery //tag对应为form type UserInfo struct { Name string `json:\u0026#34;name\u0026#34; form:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34; form:\u0026#34;age\u0026#34;` Sex string `json:\u0026#34;sex\u0026#34; form:\u0026#34;sex\u0026#34;` } router.POST(\u0026#34;/query\u0026#34;, func(c *ginContext) { var userInfo UserInfo err := c.ShouldBindQuery(\u0026amp;userInfo) if err != nil { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;你错\u0026#34;}) return } c.JSON(200, userInfo) }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //ShouldBindUri //tag对应为uri type UserInfo struct { Name string `json:\u0026#34;name\u0026#34; form:\u0026#34;name\u0026#34; uri:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34; form:\u0026#34;age\u0026#34; uri:\u0026#34;age\u0026#34;` Sex string `json:\u0026#34;sex\u0026#34; form:\u0026#34;sex\u0026#34; uri:\u0026#34;sex\u0026#34;` } router.POST(\u0026#34;/uri/:name/:age/:sex\u0026#34;, func(c *gin.Context) { var userInfo UserInfo err := c.ShouldBindUri(\u0026amp;userInfo) if err != nil { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;你错了\u0026#34;}) return } c.JSON(200, userInfo) }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //ShouldBind //会根据请求头中的content-type去自动绑定 //form-data的参数也用这个，tag用form //默认的tag就是form,可以绑定json，query，param，yaml，xml type UserInfo struct { Name string `form:\u0026#34;name\u0026#34;` Age int `form:\u0026#34;age\u0026#34;` Sex string `form:\u0026#34;sex\u0026#34;` } router.POST(\u0026#34;/form\u0026#34;, func(c *gin.Context) { var userInfo UserInfo err := c.ShouldBind(\u0026amp;userInfo) if err != nil { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;你错了\u0026#34;}) return } c.JSON(200, userInfo) }) 参数验证 常用验证器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 不能为空，并且不能没有这个字段 required: 必填字段，如: binding:\u0026#34;required\u0026#34; // 针对字符串的长度 min 最小长度，如: binding:\u0026#34;min=5\u0026#34; max 最大长度，如: binding:\u0026#34;max=18\u0026#34; len 长度，如: binding:\u0026#34;en=6\u0026#34; // 针对数字的大小 eg 等于，如: binding:\u0026#34;eg=3\u0026#34; ne 不等于，如: binding:\u0026#34;ne=12\u0026#34; gt 大于，如: binding:\u0026#34;gt=18\u0026#34; gte 大于等于，如: binding:\u0026#34;gte=18\u0026#34; lt 小于，如:binding:\u0026#34;lt=18\u0026#34; lte 小于等于，如: binding:\u0026#34;lte=18\u0026#34; // 针对同级字段的 eqfield 等于其他字段的值，如: PassWord string binding:\u0026#34;eqfield=Password\u0026#34; nefield 不等于其他字段的值 忽略字段，如: binding:\u0026#34;_\u0026#34; type SignUserInfo struct { // binding:\u0026#34;required\u0026#34;不能为空或不传 Name string `json:\u0026#34;name\u0026#34; binding:\u0026#34;required\u0026#34;` //用户名 Mail string `json:\u0026#34;mail\u0026#34;` //邮箱 // binding:\u0026#34;min=6,max=12\u0026#34;最小长度6，最大长度12 Password string `json:\u0026#34;password\u0026#34; binding:\u0026#34;min=6,max=12\u0026#34;` //密码 RePassword string `json:\u0026#34;re_password\u0026#34; binding:\u0026#34;eqfield=Password\u0026#34;` //确认密码 } gin内置验证器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 枚举 只能是red 或green oneof=red green // 字符串 contains=fengfeng // 包含fengfeng的字符串 excludes // 不包含 startswith // 字符串前缀 endswith // 字符串后缀 // 数组 dive // dive后面的验证就是针对数组中的每一个元素 // 网络验证 ip ipv4 ipv6 uri url // uri 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源 // url 在于Locater，是统一资源定位符，提供找到该资源的确切路径 // 日期验证 1月2号下午3点4分5秒在2006年 datetime=2006-1-2 1 2 3 4 5 6 7 8 type SignUserInfo struct { Sex string `json:\u0026#34;sex\u0026#34; binding:\u0026#34;oneof=男 女\u0026#34;` //性别 HobbyList []string `json:\u0026#34;hobby_list\u0026#34; binding:\u0026#34;required,dive,startswith=ilove\u0026#34;` //爱好 IP string `json:\u0026#34;ip\u0026#34; binding:\u0026#34;ip\u0026#34;` //ip地址 //必须用datetime=2006-01-02 15:04:05这个时间，不能换成别的时间 //1月2号下午3点4分5秒2006年 Date string `json:\u0026#34;date\u0026#34; binding:\u0026#34;datetime=2006-01-02 15:04:05\u0026#34;` //日期 } 自定义验证器错误信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //main.go router.POST(\u0026#34;/\u0026#34;, func(c *gin.Context) { type User struct { Name string `json:\u0026#34;name\u0026#34; binding:\u0026#34;required\u0026#34; msg:\u0026#34;用户名校验失败\u0026#34;` Age int `json:\u0026#34;age\u0026#34; binding:\u0026#34;required,gt=10\u0026#34; msg:\u0026#34;年龄校验失败\u0026#34;` } var user User err := c.ShouldBindJSON(\u0026amp;user) if err != nil { //c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: err.Error()}) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: GetValidMsg(err, \u0026amp;user)}) return } c.JSON(200, gin.H{\u0026#34;data\u0026#34;: user}) }) //GetValidMsg函数 func GetValidMsg(err error, obj any) string { // 将err接口断言为具体类型 //使用的时候传文件指针 getObj := reflect.TypeOf(obj) if errs, ok := err.(validator.ValidationErrors); ok { //断言成功 //循环每一个错误信息 for _, e := range errs { if f, exist := getObj.Elem().FieldByName(e.Field()); exist { msg := f.Tag.Get(\u0026#34;msg\u0026#34;) return msg } } } return err.Error() } 自定义验证器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //main //自定义验证器 sign if v, ok := binding.Validator.Engine().(*validator.Validate); ok { v.RegisterValidation(\u0026#34;sign\u0026#34;, signValid) } router.POST(\u0026#34;/\u0026#34;, func(c *gin.Context) { var user User err := c.ShouldBind(\u0026amp;user) if err != nil { c.JSON(200, err.Error()) return } c.JSON(200, gin.H{\u0026#34;data\u0026#34;: user}) return }) //signValid函数和user结构体 type User struct { //自定义验证器 sign Name string `form:\u0026#34;name\u0026#34; binding:\u0026#34;required,sign\u0026#34; msg:\u0026#34;请输入名字\u0026#34;` Age int `form:\u0026#34;age\u0026#34; binding:\u0026#34;required,gt=10\u0026#34; msg:\u0026#34;请输入年龄\u0026#34;` } func signValid(fl validator.FieldLevel) bool { //不允许name为nameList中的值 var nameList []string = []string{\u0026#34;lihan\u0026#34;, \u0026#34;lihan3238\u0026#34;, \u0026#34;Lihan\u0026#34;} for _, nameStr := range nameList { name := fl.Field().Interface().(string) if name == nameStr { return false } } return true } 上传下载文件 上传文件 单文件 1 2 3 4 5 6 7 8 9 10 11 12 // 为 multipart forms 设置较低的内存限制 (默认是 32 MiB) // 单位是字节，\u0026lt;\u0026lt; 是左移预算符号，等价于 8 * 2^20 // gin对文件上传大小的默认值是32MB router.MaxMultipartMemory = 8 \u0026lt;\u0026lt; 20 // 8 MiB router.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { file, _ := c.FormFile(\u0026#34;file\u0026#34;) fmt.Println(file.Filename) fmt.Println(file.Size / 1024) //单位为KB //保存文件到本地 c.SaveUploadedFile(file, \u0026#34;uploads/\u0026#34;+file.Filename) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;}) }) 服务器保存文件的几种方式 SaveUploadedFile 保存文件到本地 1 2 SaveUploadedFile(file, \u0026#34;uploads/\u0026#34;+file.Filename) //文件对象,文件路径:注意要从项目根路径开始写 读取文件内容 1 2 3 4 5 6 7 8 router.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { file, _ := c.FormFile(\u0026#34;file\u0026#34;) readerFile, _ := file.Open() data, _ := io.ReadAll(readerFile) fmt.Println(string(data)) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;}) }) Create+Copy 1 2 3 4 5 6 7 8 9 10 11 router.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { file, _ := c.FormFile(\u0026#34;file\u0026#34;) readerFile, _ := file.Open() writerFile, _ := os.Create(\u0026#34;uploads/\u0026#34; + file.Filename) defer readerFile.Close() defer writerFile.Close() n, _ := io.Copy(writerFile, readerFile) fmt.Println(n) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;上传成功！\u0026#34;}) })\t上传多个文件 1 2 3 4 5 6 7 8 router.POST(\u0026#34;/uploads\u0026#34;, func(c *gin.Context) { form, _ := c.MultipartForm() files := form.File[\u0026#34;file\u0026#34;] for _, file := range files { c.SaveUploadedFile(file, \u0026#34;uploads/\u0026#34;+file.Filename) } c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: fmt.Sprintf(\u0026#34;上传成功%d个文件!\u0026#34;, len(files))}) }) 下载文件 1 2 3 4 5 6 7 8 9 10 11 12 router.GET(\u0026#34;/download\u0026#34;, func(c *gin.Context) { //c.File(\u0026#34;uploads/logo.png\u0026#34;) //有些响应，比如图片，浏览器就会显示这图片，而不是下载，所以我们需要使浏览器起下载行为 c.Header(\u0026#34;Content-Type\u0026#34;, \u0026#34;applicationoctet-stream\u0026#34;) //一定要指定下载文件名（可以与源文件名同），不然默认download无后缀名 c.Header(\u0026#34;Content-Disposition\u0026#34;,\u0026#34;attachment; filename=1.png\u0026#34;) //设置文件传输方式为二进制（乱码问题关） c.Header(\u0026#34;Content-Transfer-Encoding\u0026#34;,\u0026#34;binary\u0026#34;) //指定源文件 c.File(\u0026#34;uploads/logo.png\u0026#34;) } 如果是前后端模式下，后端就只需要响应一个文件数据 文件名和其他信息就写在请求头中\n1 2 3 c.Header(\u0026#34;fileName\u0026#34;,\u0026#34;xxx .png\u0026#34;) c.Header(\u0026#34;msg\u0026#34;，\u0026#34;文件下载成功\u0026#34;) c.File(\u0026#34;uploads/12 .png\u0026#34;) 中间件和路由 中间件 单个路由的中间件 1 2 3 4 5 6 7 8 9 10 11 12 //main.go router.GET(\u0026#34;/\u0026#34;, m1, func(c *gin.Context) { fmt.Println(\u0026#34;index...\u0026#34;) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;index\u0026#34;}) })//执行顺序：m1-\u0026gt;index //m1中间件 func m1(c *gin.Context) { fmt.Println(\u0026#34;m1...\u0026#34;) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;m1\u0026#34;}) c.Abort() //阻止后续的处理函数执行 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //main.go router.GET(\u0026#34;/\u0026#34;, m1, func(c *gin.Context) { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;index\u0026#34;}) fmt.Println(\u0026#34;index...in\u0026#34;) //next前是请求 //Abort后不会执行之后的请求和响应，但是会执行已执行过请求的响应 c.Next() //next后是响应 fmt.Println(\u0026#34;index...out\u0026#34;) }) //m1 func m1(c *gin.Context) { c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;m1\u0026#34;}) fmt.Println(\u0026#34;m1...in\u0026#34;) c.Next() fmt.Println(\u0026#34;m1...out\u0026#34;) } 1 2 3 4 5 #返回 m1...in index...in index...out m1...out 全局注册中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //main.go router.Use(m10, m11) // 全局注册中间件 router.GET(\u0026#34;/1\u0026#34;, func(c *gin.Context) { fmt.Println(\u0026#34;index1......in\u0026#34;) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;index1\u0026#34;}) c.Next() fmt.Println(\u0026#34;index1......out\u0026#34;) }) router.GET(\u0026#34;/2\u0026#34;, func(c *gin.Context) { fmt.Println(\u0026#34;index2......in\u0026#34;) c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;index2\u0026#34;}) c.Next() fmt.Println(\u0026#34;index2......out\u0026#34;) }) //中间件 func m10(c *gin.Context) { fmt.Println(\u0026#34;m10......in\u0026#34;) c.Next() fmt.Println(\u0026#34;m10......out\u0026#34;) } func m11(c *gin.Context) { fmt.Println(\u0026#34;m11......in\u0026#34;) c.Next() fmt.Println(\u0026#34;m11......out\u0026#34;) } 1 2 3 4 5 6 m10......in m11......in index2......in index2......out m11......out m10......out 中间件传递数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //main.go router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { name, _ := c.Get(\u0026#34;name\u0026#34;) fmt.Println(name) _user, _ := c.Get(\u0026#34;user\u0026#34;) user, ok := _user.(Person) // 使用类型断言 if !ok { fmt.Println(\u0026#34;类型断言失败\u0026#34;) } else { fmt.Println(user.Name, user.Age) } c.JSON(200, gin.H{\u0026#34;msg\u0026#34;: \u0026#34;index1\u0026#34;}) }) //中间件 func m10(c *gin.Context) { fmt.Println(\u0026#34;m10......in\u0026#34;) c.Set(\u0026#34;name\u0026#34;, \u0026#34;lihan\u0026#34;) c.Set(\u0026#34;user\u0026#34;, Person{ Name: \u0026#34;lihan\u0026#34;, Age: 18, }) } 路由分组 路由分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type UserInfo struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } type ArticleInfo struct { Title string `json:\u0026#34;title\u0026#34;` Id int `json:\u0026#34;id\u0026#34;` } type Response struct { Code int `json:\u0026#34;code\u0026#34;` Data any `json:\u0026#34;data\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` } func UserListView(c *gin.Context) { var userList []UserInfo = []UserInfo{ {\u0026#34;lihan\u0026#34;, 18}, {\u0026#34;李寒\u0026#34;, 22}, {\u0026#34;op\u0026#34;, 28}, } c.JSON(200, Response{200, userList, \u0026#34;success\u0026#34;}) } func ArticleListView(c *gin.Context) { var articleList []ArticleInfo = []ArticleInfo{ {\u0026#34;gin\u0026#34;, 1}, {\u0026#34;go\u0026#34;, 2}, {\u0026#34;vue\u0026#34;, 3}, } c.JSON(200, Response{200, articleList, \u0026#34;success\u0026#34;}) } func UserRouterInit(api *gin.RouterGroup) { api1 := api.Group(\u0026#34;api_1\u0026#34;) { api1.GET(\u0026#34;/users1\u0026#34;, UserListView) api1.POST(\u0026#34;/users2\u0026#34;, UserListView) } } func ArticleRouterInit(api *gin.RouterGroup) { api2 := api.Group(\u0026#34;api_2\u0026#34;) { api2.GET(\u0026#34;/users3\u0026#34;, ArticleListView) api2.POST(\u0026#34;/users4\u0026#34;, ArticleListView) } } func main() { router := gin.Default() api := router.Group(\u0026#34;api\u0026#34;) UserRouterInit(api) ArticleRouterInit(api) router.GET(\u0026#34;/users\u0026#34;, UserListView) router.Run(\u0026#34;:8080\u0026#34;) } 路由分组中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; type Res struct { Code int `json:\u0026#34;code\u0026#34;` Data any `json:\u0026#34;data\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` } func _UserListView(c *gin.Context) { type UserInfo struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } var userList []UserInfo = []UserInfo{ {Name: \u0026#34;张三\u0026#34;, Age: 18}, {Name: \u0026#34;李四\u0026#34;, Age: 19}, {Name: \u0026#34;王五\u0026#34;, Age: 20}, } c.JSON(200, Res{200, userList, \u0026#34;success\u0026#34;}) } func Middleware(c *gin.Context) { token := c.GetHeader(\u0026#34;token\u0026#34;) if token == \u0026#34;3238\u0026#34; { c.Next() return } c.JSON(200, Res{401, nil, \u0026#34;token error\u0026#34;}) c.Abort() } //中间件 func _UserRouterInit(router *gin.RouterGroup) { userManager := router.Group(\u0026#34;user_manager\u0026#34;) userManager.Use(Middleware) { userManager.GET(\u0026#34;/users\u0026#34;, _UserListView) // api/user_manager/users } } func main() { router := gin.Default() api := router.Group(\u0026#34;api\u0026#34;) api.GET(\u0026#34;/login\u0026#34;, func(c *gin.Context) { c.JSON(200, Res{200, nil, \u0026#34;login success\u0026#34;}) }) //不在中间件中的路由，不需要验证 _UserRouterInit(api) router.Run(\u0026#34;:8080\u0026#34;) } 闭包：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func Middleware(c *gin.Context) { token := c.GetHeader(\u0026#34;token\u0026#34;) if token == \u0026#34;3238\u0026#34; { c.Next() return } c.JSON(200, Res{401, nil, \u0026#34;token error\u0026#34;}) c.Abort() } //中间件 //_UserRouterInit userManager.Use(Middleware) 可写为： func Middleware(msg string) gin.HandlerFunc { return func(c *gin.Context) { token := c.GetHeader(\u0026#34;token\u0026#34;) if token == \u0026#34;3238\u0026#34; { c.Next() return } c.JSON(200, Res{401, nil, msg}) c.Abort() } } //中间件 //_UserRouterInit userManager.Use(Middleware(\u0026#34;token error\u0026#34;)) 优点：可以传参，自定义，闭包 gin.Default()中间件 等于gin.New()加上Logger(), Recovery()若干中间件\ngin log日志 记录bug 记录用户操作，猜测用户行为 gin内置日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { file, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(file, os.Stdout) //同时写入文件和控制台 router := gin.Default() router.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;hello world\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) } //在项目目录下生成gin.log文件 [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) [GIN-debug] GET /index --\u0026gt; main.main.func1 (3 handlers) [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8080 [GIN] 2023/09/22 - 13:33:20 | 200 | 16.375µs | 192.168.56.1 | GET \u0026#34;/index\u0026#34; [GIN] 2023/09/22 - 13:33:20 | 404 | 506ns | 192.168.56.1 | GET \u0026#34;/favicon.ico\u0026#34; 定义格式 定义路由格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, numHandlers int) { log.Printf( \u0026#34;[lihan] %s %s %s %d\\n\u0026#34;, httpMethod, absolutePath, handlerName, numHandlers, ) } file, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(file, os.Stdout) //同时写入文件和控制台 router := gin.Default() router.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;hello world\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) 查看路由: 1 router.Routes() // 它会返回已注册的路由列表 环境切换(去掉debug日志) 1 2 gin.SetMode(gin.ReleaseMode) router := gin.Default() 定义日志格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func myLogFormat(param gin.LogFormatterParams) string { // 你的自定义格式 return fmt.Sprintf( \u0026#34;[lihan]\t%s\t|%d|\t%s%s%s\t%s\\n\u0026#34;, param.TimeStamp.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;), param.StatusCode, //param.Method, param.MethodColor(), param.Method, param.ResetColor(), //根据不同的请求类型输出不同颜色 param.Path, ) } func main() { gin.SetMode(gin.ReleaseMode) gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, numHandlers int) { log.Printf( \u0026#34;[lihan] %s %s %s %d\\n\u0026#34;, httpMethod, absolutePath, handlerName, numHandlers, ) } file, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(file, os.Stdout) //同时写入文件和控制台 router := gin.New() //router.Use(gin.LoggerWithFormatter(myLogFormat)) router.Use(gin.LoggerWithConfig(gin.LoggerConfig{Formatter: myLogFormat})) router.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;hello world\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) } 修改前： 修改后： 第三方日志 logrus 下载 1 go get github.com/sirupsen/logrus 日志等级 1 2 3 4 5 6 7 8 logrus.SetLevel(logrus.DebugLevel) logrus.Error(\u0026#34;出错了\u0026#34;) logrus.Warnln(\u0026#34;警告\u0026#34;) logrus.Infof(\u0026#34;信息\u0026#34;) logrus.Debugf(\u0026#34;debug\u0026#34;) logrus.Println(\u0026#34;打印\u0026#34;) fmt.Println(logrus.GetLevel()) 更改日志级别\n日志只会显示大于等于设置的日志级别的日志 默认日志级别为info 日志级别一般是和系统挂钩，开发环境一般是debug，线上环境可能是warning。 1 logrus.SetLevel(logrus.DebugLevel) 日志等级\n1 2 3 4 5 6 7 PanicLevel// 会抛一个异常 FatalLevel// 打印日志之后就会退出 ErrorLevel WarnLevel InfoLevel DebugLevel TraceLevel// 低级别 设置特定字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;github.com/sirupsen/logrus\u0026#34; func main() { log_1 := logrus.WithField(\u0026#34;app\u0026#34;, \u0026#34;4.3logrus设置特定字段\u0026#34;).WithField(\u0026#34;service\u0026#34;, \u0026#34;logrus\u0026#34;) log_2 := logrus.WithFields(logrus.Fields{ \u0026#34;user_id\u0026#34;: \u0026#34;22\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.56.105\u0026#34;, }) log_3 := log_1.WithFields(logrus.Fields{ \u0026#34;user_id\u0026#34;: \u0026#34;22\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.56.105\u0026#34;, }) log_1.Errorf(\u0026#34;出错了\u0026#34;) log_2.Errorf(\u0026#34;出错了\u0026#34;) log_3.Errorf(\u0026#34;出错了\u0026#34;) } 设置输出格式\nForceColors: 是否强制使用额色输出。 DisableColors: 是否禁用额色输出。 ForceQuote: 是否强制引用所有值。 DisableQuote: 是否禁用引用所有值。 DisableTimestamp: 是否禁用时间戳记录 FullTimestamp:是否在连接到 TTY 时输出完整的时间戳 TimestampFormat: 用于输出完整时间戳的时间戳格式。 1 2 3 4 5 6 7 8 9 10 11 12 //输出行号 //设置输出格式为json格式 logrus.SetFormatter(\u0026amp;logrus.JSONFormatter{}) //设置输出时间戳 logrus.SetFormatter(\u0026amp;logrus.TextFormatter{ ForceColors: true, TimestampFormat: \u0026#34;2006-01-02 15:04:05\u0026#34;, FullTimestamp: true, }) 控制台颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; func main() { // 前景色 fmt.Println(\u0026#34;\\033[30m 黑色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[31m 红色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[32m 绿色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[33m 黄色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[34m 蓝色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[35m 紫色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[36m 青色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[37m 灰色 \\033[0m\u0026#34;) // 背景色 fmt.Println(\u0026#34;\\033[40m 黑色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[41m 红色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[42m 绿色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[43m 黄色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[44m 蓝色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[45m 紫色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[46m 青色 \\033[0m\u0026#34;) fmt.Println(\u0026#34;\\033[47m 灰色 \\033[0m\u0026#34;) } Hook 例如实现一个名称写入日志都加一个 field 我们需要实现两个方法以实现 Hook 接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type MyHook struct { } func (hook MyHook) Levels() []logrus.Level { return logrus.AllLevels } func (hook MyHook) Fire(entry *logrus.Entry) error { entry.Data[\u0026#34;app\u0026#34;] = \u0026#34;lihan\u0026#34; return nil } func main() { logrus.AddHook(\u0026amp;MyHook{}) logrus.Warnln(\u0026#34;warning\u0026#34;) logrus.Error(\u0026#34;error\u0026#34;) } logrus hook 是一个值得深入学习的设计，你可以轻易适用 hook 来实现多文件写入。 比如，warn\u0026amp;error 级别的日志独立输出到 error_warn.log 文件里，其他都放在一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;os\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) type MyHook struct { } func (hook MyHook) Levels() []logrus.Level { return []logrus.Level{logrus.WarnLevel, logrus.ErrorLevel} } func (hook MyHook) Fire(entry *logrus.Entry) error { //entry.Data[\u0026#34;app\u0026#34;] = \u0026#34;lihan\u0026#34; //fmt.Println(entry.Level) file, _ := os.OpenFile(\u0026#34;4.日志log/error_warn.log\u0026#34;, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666) line, _ := entry.String() file.Write([]byte(line + \u0026#34;\\n\u0026#34;)) return nil } func main() { logrus.AddHook(\u0026amp;MyHook{}) logrus.Warnln(\u0026#34;warning\u0026#34;) logrus.Error(\u0026#34;error\u0026#34;) logrus.Debug(\u0026#34;debug\u0026#34;) logrus.Infoln(\u0026#34;info\u0026#34;) } 日志分割 按照时间分割 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) type FileDateHook struct { file *os.File logPath string fileDate string //判断日期切换目录 appName string } func (hook FileDateHook) Levels() []logrus.Level { return []logrus.Level{logrus.WarnLevel, logrus.ErrorLevel} } func (hook FileDateHook) Fire(entry *logrus.Entry) error { timer := entry.Time.Format(\u0026#34;2006-01-02_15-04\u0026#34;) line, _ := entry.String() if hook.fileDate == timer { hook.file.Write([]byte(line)) return nil } //有新时间 hook.file.Close() os.MkdirAll(fmt.Sprintf(\u0026#34;%s/%s\u0026#34;, hook.logPath, timer), os.ModePerm) filename := fmt.Sprintf(\u0026#34;%s/%s/%s.log\u0026#34;, hook.logPath, timer, hook.appName) hook.file, _ = os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) hook.fileDate = timer hook.file.Write([]byte(line)) return nil } func InitFile(logPath, appName string) { fileDate := time.Now().Format(\u0026#34;2006-01-02_15-04\u0026#34;) //创建目录 err := os.MkdirAll(fmt.Sprintf(\u0026#34;%s/%s\u0026#34;, logPath, fileDate), os.ModePerm) if err != nil { logrus.Error(err) return } filename := fmt.Sprintf(\u0026#34;%s/%s/%s.log\u0026#34;, logPath, fileDate, appName) file, err := os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) if err != nil { logrus.Error(err) return } filehook := FileDateHook{file, logPath, fileDate, appName} logrus.AddHook(\u0026amp;filehook) } func main() { InitFile(\u0026#34;4.日志log/logs_1\u0026#34;, \u0026#34;lihan_log\u0026#34;) for { time.Sleep(20 * time.Second) logrus.GetLevel() logrus.Warnln(\u0026#34;warning\u0026#34;) logrus.Error(\u0026#34;error\u0026#34;) logrus.Infoln(\u0026#34;info\u0026#34;) } } 按照等级分割 err,warn,info,all.log\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) const ( alllog = \u0026#34;all\u0026#34; errlog = \u0026#34;err\u0026#34; warnlog = \u0026#34;warn\u0026#34; infolog = \u0026#34;info\u0026#34; ) type FileLevelHook struct { file *os.File errFile *os.File warnFile *os.File infoFile *os.File logPath string } func (hook FileLevelHook) Levels() []logrus.Level { return logrus.AllLevels } func (hook FileLevelHook) Fire(entry *logrus.Entry) error { line, _ := entry.String() switch entry.Level { case logrus.ErrorLevel: hook.errFile.Write([]byte(line)) case logrus.WarnLevel: hook.warnFile.Write([]byte(line)) case logrus.InfoLevel: hook.infoFile.Write([]byte(line)) } hook.file.Write([]byte(line)) return nil } func InitLevel(logPath string) { err := os.MkdirAll(fmt.Sprintf(\u0026#34;%s\u0026#34;, logPath), os.ModePerm) if err != nil { logrus.Error(err) return } allFile, _ := os.OpenFile(fmt.Sprintf(\u0026#34;%s/%s.log\u0026#34;, logPath, alllog), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) errFile, _ := os.OpenFile(fmt.Sprintf(\u0026#34;%s/%s.log\u0026#34;, logPath, errlog), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) warnFile, _ := os.OpenFile(fmt.Sprintf(\u0026#34;%s/%s.log\u0026#34;, logPath, warnlog), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) infoFile, _ := os.OpenFile(fmt.Sprintf(\u0026#34;%s/%s.log\u0026#34;, logPath, infolog), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600) filehook := FileLevelHook{allFile, errFile, warnFile, infoFile, logPath} logrus.AddHook(\u0026amp;filehook) } func main() { InitLevel(\u0026#34;4.日志log/log_level\u0026#34;) logrus.Error(\u0026#34;error\u0026#34;) logrus.Warnln(\u0026#34;warning\u0026#34;) logrus.Infoln(\u0026#34;info\u0026#34;) logrus.Println(\u0026#34;print\u0026#34;) } gin集成logrus 1 看不下去了呜哇哇哇！！！ ","date":"2023-09-11T13:40:00+08:00","image":"/lihan3238.github.io/p/ginwebstudy/gin_hue87b07cedf5bdfb5822b08cbf7ba1c33_87064_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/ginwebstudy/","title":"ginWeb框架学习"},{"content":"健身房锻炼经验 1.练腿： 有氧训练： 在跑步机上进行了3分钟的有氧锻炼，级别设置在8。 单腿前抬： 进行了左右腿的交替前抬，这有助于加强髋部和腹部肌肉。 肩部拉伸： 使用弹力绳进行了肩部的拉伸，这有助于改善肩部灵活性和稳定性。 杠铃下蹲： 进行了4组下蹲练习，每组6次，重量分别为20千克、20千克和20千克。这是用于加强大腿和臀部的力量练习。 后腿举： 进行了4组每边10次的后腿举，这有助于锻炼小腿后部的肌肉。 夹腿： 使用35千克的负重进行了4组，每组10次的夹腿练习，这有助于加强大腿内侧的肌肉。 地滚轮： 使用瑜伽滚轮进行了放松和伸展，有助于缓解肌肉紧张和提高柔韧性。 效果 第二天我打了个羽毛球，第三天起床剧痛，疼了一晚上。\n2.练肩 弹力绳热身肩部： 在健身前用弹力绳进行的热身活动，有助于活跃肩部肌肉和关节。 双手握哑铃片晃八字热身肩部： 哑铃肩部推举热身： 每只手6kg哑铃，共12次。 哑铃肩部推举： 每只手10-12.5kg哑铃，一组8次，4组。 双飞鸟： 侧平举变种，每只手使用5公斤的哑铃进行12次，然后使用2.5公斤的哑铃进行12次，共进行4组。 杠铃前平举： 将空杆杠铃从平举到眼睛高度，每组进行12次，共进行了4组。 坐姿杠铃提腿： 使用共20-40公斤的杠铃，每组进行12次，共进行了4组。 效果 第二天没什么感觉，感觉还可以上强度。\n","date":"2023-09-10T11:24:00+08:00","image":"/lihan3238.github.io/p/exerciseplan/fight_hub9f43d2ede21455221e8aae55f2c24ab_9476_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/exerciseplan/","title":"健身房锻炼经验"},{"content":"新网卡配置\n前置 姓名、主机名、用户名 1 2 3 4 5 您的姓名-\u0026gt;指的是计算机登录时，显示的名字，与下面的2行密码(这个密码是用户名的密码，非姓名的密码，而且这个密码可以)配合登录计算机，登录之后就没什么用了 计算机名-\u0026gt;指的是计算机登录之后的主机名，也就是hostname，在shell终端中输入hostname，会显示该名称，同时，shell终端的命令提示符格式就是：user@hostname:~$: 这个hostname就是这个计算机名，至于它的作用，自行百度即可 用户名：-\u0026gt;指的是计算机登录之后的用户名，在shell终端中使用w命令可以查看当前所有登录过的用户名，使用who/whoami可以查看当前登录的用户名，使用ssh远程登录时，需要使用的就是用户名 配置虚拟机双网卡 如果为ubuntu新添加了网卡，那么通过命令ifconfig -a可以看到所有网卡，但是可能有网卡没有工作，这个情况下使用ifconfig就会看到出现网卡比使用参数-a少，那没有出现的网卡就是没有生效。\n所有网卡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 xanarry@vbs:~$ ip addr enp0s3: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 inet6 fe80::a00:27ff:fe34:4ea1 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:34:4e:a1 txqueuelen 1000 (Ethernet) RX packets 489 bytes 46089 (46.0 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 337 bytes 44455 (44.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp0s8: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet6 fe80::a00:27ff:fea2:190e prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:a2:19:0e txqueuelen 1000 (Ethernet) RX packets 46 bytes 4880 (4.8 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 20 bytes 2761 (2.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 90 bytes 6813 (6.8 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 90 bytes 6813 (6.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 工作网卡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 xanarry@vbs:~$ ifconfig enp0s3: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 inet6 fe80::a00:27ff:fe5e:ad3f prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:5e:ad:3f txqueuelen 1000 (Ethernet) RX packets 78 bytes 9938 (9.9 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 70 bytes 13068 (13.0 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 84 bytes 6324 (6.3 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 84 bytes 6324 (6.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 如何生效： ubuntu20网络的配置信息将不在保存在/etc/network/interfaces文件中，虽然该文件依然存在，但是内容是空的。新系统已经使用netplan管理网络，对于配置信息，使用vim打开文件sudo vim /etc/netplan/00-installer-config.yaml，内容如下，可以看到网卡enp0s3下面有参数dhcp4: true，说明该网卡开启了dhch地址分配，但是并没有出现enp0s8，所以手动加入enp0s8。\n注意：yaml文件名在不同的机器上文件名可能不同。\n1 2 3 4 5 network: ethernets: enp0s3: dhcp4: true version: 2 添加过后的内容为：\n1 2 3 4 5 6 7 network: ethernets: enp0s3: dhcp4: true enp0s8: dhcp4: true version: 2 最后执行\n1 sudo netplan apply 生效\n参考https://ubuntu.com/server/docs/network-configuration 万能https://git.cuc.edu.cn/ccs/linux-2023/LiMingxuan scp传输文件 1 2 scp test.txt lihan@192.168.56.103:/home/lihan/leo lihan@192.168.56.103\u0026#39;s password: 一定要加上\u0026rsquo;:\u0026rsquo;,不能多打空格！！ 记得无论是linux\u0026ndash;\u0026gt;windows还是回传，都是在windows命令行操作 1 2 scp lihan@192.168.56.103:/home/lihan/leo/test.txt D:\\大二学习\\Linux\\自学 lihan@192.168.56.103\u0026#39;s password: vim操作 按i进行插入 :q!不保存退出 :wq!保存退出 记得sudo ssh免密登录 1.ssh登录Bad permission 1 2 3 4 5 6 7 8 9 10 找到.ssh文件夹。它通常位于C:\\Users，例如C:\\Users\\Akkuman。 右键单击.ssh文件夹，然后单击“属性”。 找到并点击“安全”标签。 然后单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。 你会注意到所有用户都将被删除。让我们添加所有者。在同一窗口中，单击“编辑”按钮。 接下来，单击“添加”以显示“选择用户或组”窗口。 单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择您的用户帐户。 然后单击“确定”（大约三次）以关闭所有窗口。 完成所有操作后，再次关闭并打开VSCode 并尝试连接到远程SSH主机。 现在这个问题应该解决了 2.ssh免密登录配置（以windows远程登录虚拟机linux为例） 确保linux和windows都有ssh后，首先在windows下生成公私钥 1 ssh-keygen -b 4096 弹出提示命名（如果只有一个公私钥对就直接按回车用默认命名），进行命名 弹出提示密码，直接回车两次跳过设置密码\n将生成在C:\\Users\\leo.ssh下的公钥xxxx.pubscp发送到linux的/home/lihan/.ssh目录下，并替换authorized_keys文件内容 注意 如果有多个免密登录配置，记得在windows的C:\\Users\\leo.ssh目录下，修改config文件，指定公私钥地址 若仍存在问题 1 2 3 4 5 6 7 8 sudo vim /etc/ssh/sshd_config 修改 PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 添加 RSAAuthentication yes 共享文件夹 首先安装客机增强键\n下载VBoxGuestAddtions_7.0.10\n下载好后，在储存介质中挂载 打开虚拟机安装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #提权 sudo su #更新apt-get apt-get update \u0026amp;\u0026amp; apt-get upgrade #安装依赖工具 apt-get install dkms \u0026amp;\u0026amp; apt-get install build-essential3. reboot4. 登陆后 #选择设备-\u0026gt;安装增强功能（报错不用管 叉掉） ![](9.png) #挂载cdrom mount /dev/cdrom /mnt/ 出现 warning不用管 #安装 /mnt/VBoxLinuxAddtions.run #卸载 umount /mnt/ 挂载共享文件夹 执行共享文件夹的挂载命令 1 2 3 sudo mount -t vboxsf [你设置的共享文件夹名称名称] [挂载后的本地路径] #例如 sudo mount -t vboxsf virtualBoxFile /home/lihan/win_share 安装好后就可以删掉客机增强键的包了 使用sudo出现问题：xxx is not in the sudoers file 输入指令 1 2 # 进入root用户中，$变成了# su 输入指令 1 2 sudo adduser vboxuser sudo 注意，vboxuser就是我被玩坏，需恢复的用户，大家记得替换成自己的用户名 重启后就好了 linux clash https://dreamacro.github.io/clash/zh_CN/introduction/service.html\n然后打开clash.razord.top/配置，7890或者9090端口\n","date":"2023-09-09T00:00:00+08:00","image":"/lihan3238.github.io/p/linuxstudy/ubuntu_hud870f7800e877f7914ab28e061c73a0c_17473_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/linuxstudy/","title":"linux虚拟机安装与配置"},{"content":"Go语言学习 \u0026ndash;\n代码仓库 例子—基于go的即时通信系统 教程：https://www.yuque.com/aceld/mo95lb/dsk886 以ubuntu22.04.3桌面版+VScode为例，Linux搭建详见Linux教程,go安装和VScode安装网上自己看。 go version go1.21.0 linux/amd64 1.main \u0026ndash;\n1 2 3 4 5 6 7 8 package main //定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包 import \u0026#34;fmt\u0026#34; //告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { fmt.Println(\u0026#34;Hello Go\u0026#34;)//Print不加\\n,Println自带加\\n } //程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） 1 2 3 //运行 go run test1_hello.go Hello Go 2.变量 \u0026ndash;\n2.1 指定变量类型 声明后若不赋值，使用默认值0 1 2 3 4 5 6 7 8 9 10 // var v_name v_type // v_name = value package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Printf(\u0026#34; = %d\\n\u0026#34;, a) } \u0026ndash;\n2.2 根据值自行判定变量类型 1 var v_name = value \u0026ndash;\n2.3 省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。 1 2 3 4 5 6 7 v_name := value // 例如 var a int = 10 var b = 10 c : = 10 \u0026ndash;\n2.4 例子 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { //第一种 使用默认值 var a int fmt.Printf(\u0026#34;a = %d\\n\u0026#34;, a) //第二种 var b int = 10 fmt.Printf(\u0026#34;b = %d\\n\u0026#34;, b) //第三种 省略后面的数据类型,自动匹配类型 var c = 20 fmt.Printf(\u0026#34;c = %d\\n\u0026#34;, c) //第四种 省略var关键字 d := 3.14 fmt.Printf(\u0026#34;d = %f\\n\u0026#34;, d) } 1 2 3 4 5 go run var.go a = 0 b = 10 c = 20 d = 3.140000 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \\\\多变量声明 package main import \u0026#34;fmt\u0026#34; var x, y int var ( //这种分解的写法,一般用于声明全局变量 a int b bool ) var c, d int = 1, 2 var e, f = 123, \u0026#34;liudanbing\u0026#34; //这种不带声明格式的只能在函数体内声明 //g, h := 123, \u0026#34;需要在func函数体内实现\u0026#34; func main() { g, h := 123, \u0026#34;需要在func函数体内实现\u0026#34; fmt.Println(x, y, a, b, c, d, e, f, g, h) //不能对g变量再次做初始化声明 //g := 400 _, value := 7, 5 //实际上7的赋值被废弃，变量 _ 不具备读特性 //fmt.Println(_) //_变量的是读不出来的 fmt.Println(value) //5 } 1 2 3 4 go run mutiVar.go 0 0 0 false 1 2 123 liudanbing 123 需要在func函数体内实现 5 3.常量 \u0026ndash;\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 \u0026ndash;\n3.1 常量定义格式 1 2 3 4 5 const identifier [type] = value //显示类型定义 const b string = \u0026#34;abc\u0026#34; //隐式类型定义 const b = \u0026#34;abc\u0026#34; \u0026ndash;\n3.2 常量枚举 1 2 3 4 5 const ( Unknown = 0 Female = 1 Male = 2 )//数字 0、1 和 2 分别代表未知性别、女性和男性 \u0026ndash;\n3.3 常量表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： package main import \u0026#34;unsafe\u0026#34; const ( a = \u0026#34;abc\u0026#34; b = len(a) c = unsafe.Sizeof(a) ) func main(){ println(a, b, c) } 1 abc, 3, 16//字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。 \u0026ndash;\n3.4 常量iota 1 2 3 4 5 6 7 8 9 10 type Allergen int const ( _ = iota // ignore first value by assigning to blank identifier IgEggs Allergen = 1 // 1 \u0026lt;\u0026lt; 0 which is 00000001 IgChocolate // 1 \u0026lt;\u0026lt; 1 which is 00000010 IgNuts = 1 \u0026lt;\u0026lt; iota // 1 \u0026lt;\u0026lt; 2 which is 00000100 IgStrawberries // 1 \u0026lt;\u0026lt; 3 which is 00001000 IgShellfish // 1 \u0026lt;\u0026lt; 4 which is 00010000 ) 1 1 2 4 8 16 \u0026ndash;\n1 2 3 4 5 const ( Apple, Banana = iota + 1, iota + 2 Cherimoya, Durian Elderberry, Fig ) 1 2 3 4 5 6 // Apple: 1 // Banana: 2 // Cherimoya: 2 // Durian: 3 // Elderberry: 3 // Fig: 4 iota:自增，不在乎位置，每一行自增 const组中仅仅有一个标示符在一行的时候，它将使用增长的iota取得前面的表达式并且再运用它 4.函数 1 2 3 func function_name( [parameter list] ) [return_types] { 函数体 } \u0026ndash;\n4.1 函数多返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;Mahesh\u0026#34;, \u0026#34;Kumar\u0026#34;) fmt.Println(a, b) } //Kumar Mahesh \u0026ndash;\n4.2 ini/main和import init 函数可以在package main中或其他package中，可在同一package多次出现 main 函数只能在package main中 这两个函数在定义时不能有参数和返回值，且会自动执行。 package main就必须包含一个main函数 如果一个包会被多个包同时导入，那么它只会被导入一次 当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。 \u0026ndash;\n\u0026ndash;\n4.3 go指针 Go 语言的取地址符是 \u0026amp;，放到一个变量前使用就会返回相应变量的内存地址。 函数中引用传递\u0026rsquo;*' 变量指向地址\u0026rsquo;\u0026amp;' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; func main() { /* 定义局部变量 */ var a int = 100 var b int= 200 fmt.Printf(\u0026#34;交换前，a 的值 : %d\\n\u0026#34;, a ) fmt.Printf(\u0026#34;交换前，b 的值 : %d\\n\u0026#34;, b ) /* 调用 swap() 函数 * \u0026amp;a 指向 a 指针，a 变量的地址 * \u0026amp;b 指向 b 指针，b 变量的地址 */ swap(\u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;交换后，a 的值 : %d\\n\u0026#34;, a ) fmt.Printf(\u0026#34;交换后，b 的值 : %d\\n\u0026#34;, b ) } func swap(x *int, y *int) { var temp int temp = *x /* 保存 x 地址上的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y */ } \u0026ndash;\n4.4 defer函数 defer在Go里可以放在某个函数或者方法调用的前面，让该函数或方法延迟执行\n1 2 3 //语法 defer function([parameter_list]) // 延迟执行函数 defer method([parameter_list]) // 延迟执行方法 defer在函数体内执行，在函数A内调用了defer func()，只要defer func()这行代码被执行到，func这个函数就会被延迟到函数A return或panic之前执行。\n函数调用了os.Exit()退出，defer不会被执行了。 如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Demo(){ defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { Demo() } /* 4 3 2 1 */ \u0026ndash;\n4.5 recover错误拦截 运行时panic异常一旦被引发就会导致程序崩溃。\nGo语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。\nrecover只有在defer调用的函数中有效。 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func Demo(i int) { //定义10个元素的数组 var arr [10]int //错误拦截要在产生错误前设置 defer func() { //设置recover拦截错误信息 err := recover() //产生panic异常 打印错误信息 if err != nil { fmt.Println(err) } }() //根据函数参数为数组元素赋值 //如果i的值超过数组下标 会报错误：数组下标越界 arr[i] = 10 } func main() { Demo(10) //产生错误后 程序继续 fmt.Println(\u0026#34;程序继续执行...\u0026#34;) } //输出： //runtime error: index out of range //程序继续执行... 5.输入输出 \u0026ndash;\n\u0026ndash;\n5.1 输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。 func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) func main() { name := \u0026#34;沙河小王子\u0026#34; fmt.Print(\u0026#34;在终端打印该信息。\u0026#34;) fmt.Printf(\u0026#34;我是：%s\\n\u0026#34;, name) fmt.Println(\u0026#34;在终端打印单独一行显示\u0026#34;) } \u0026ndash;\n5.2 输入 1 2 3 4 5 6 7 8 9 10 func Scan(a ...interface{}) (n int, err error) func Scanf(format string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) fmt.Scan(\u0026amp;name, \u0026amp;age, \u0026amp;isMale)//fmt.Scan在没有扫描完所有变量之前是不会结束扫描的 fmt.Scanf(\u0026#34;name:%s age:%d isMale:%v\u0026#34;, \u0026amp;name, \u0026amp;age, \u0026amp;isMale)//遇到换行即结束扫描，如果还有没输入的变量值，该变量会按默认值处理 fmt.Scanln(\u0026amp;name, \u0026amp;age, \u0026amp;married)//遇到换行即结束扫描，如果还有没输入的变量值，该变量会按默认值处理 6.slice切片、map \u0026ndash;\n6.1 数组 Go 数组的长度不可改变，不同大小的数组是不同的变量类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //声明数组 var arrayName [size]dataType var balance [10]float32 //初始化数组 var numbers = [5]int{1, 2, 3, 4, 5} numbers := [5]int{1, 2, 3, 4, 5} // 将索引为 1 和 3 的元素初始化 balance := [5]float32{1:2.0,3:7.0} //二维数组初始化 a := [3][4]int{ {0, 1, 2, 3} , /* 第一行索引为 0 */ {4, 5, 6, 7} , /* 第二行索引为 1 */ {8, 9, 10, 11}} /* 第三行索引为 2 */ //数组传参 void myFunction(param [10]int)//param []int { } \u0026ndash;\n6.2 slice Go 语言切片是对数组的抽象 与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 切片不需要说明长度。 1 2 3 4 5 6 7 8 var identifier []type //make()创建切片 var slice1 []type = make([]type, len) //简写为 slice1 := make([]type, len, cap) //len有值的元素数量 切片长度 //cap可省略，切片容量 \u0026ndash;\n应用举例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //切片在未初始化之前默认为 nil，长度为 0 s :=[] int {1,2,3 } //直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3 s := arr[:] //初始化切片s,是数组arr的引用 s := arr[startIndex:endIndex] //将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片,是数组arr的部分引用 s1 := s[startIndex:endIndex] //通过切片s初始化切片s1,仍然是引用 //len() 获取长度 cap() 获取容量 len(x) cap(x) \u0026ndash;\n增加切片的容量 创建新的大切片，拷贝原分片的内容\n1 2 3 4 5 6 7 8 var numbers []int /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) \u0026ndash;\n6.3 map 一种无序的键值对集合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //第一种声明 var test1 map[string]string //在使用map前，需要先make，make的作用就是给ma配数据空间 test1 = make(map[string]string, 10) //第二种声明 test2 := make(map[string]string) //第三种声明 test3 := map[string]string{ \u0026#34;one\u0026#34; : \u0026#34;php\u0026#34;, \u0026#34;two\u0026#34; : \u0026#34;golang\u0026#34;, \u0026#34;three\u0026#34; : \u0026#34;java\u0026#34;, } // 增改键值对 myMap[\u0026#34;apple\u0026#34;] = 5 // 删除键值对 delete(myMap, \u0026#34;apple\u0026#34;) // 检索值 value = myMap[\u0026#34;banana\u0026#34;] \u0026ndash;\n1 2 3 4 5 6 7 8 //嵌套map language := make(map[string]map[string]string) language[\u0026#34;php\u0026#34;] = make(map[string]string, 2) language[\u0026#34;php\u0026#34;][\u0026#34;id\u0026#34;] = \u0026#34;1\u0026#34; language[\u0026#34;php\u0026#34;][\u0026#34;desc\u0026#34;] = \u0026#34;php是世界上最美言\u0026#34; language[\u0026#34;golang\u0026#34;] = make(map[string]string2) language[\u0026#34;golang\u0026#34;][\u0026#34;id\u0026#34;] = \u0026#34;2\u0026#34; language[\u0026#34;golang\u0026#34;][\u0026#34;desc\u0026#34;] = \u0026#34;golang抗并发good\u0026#34; 7.结构体 \u0026ndash;\n7.1 结构体定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type MyStruct struct { Field1 Type1 Field2 Type2 // 可以有更多字段 } //例如 type Person struct { FirstName string LastName string Age int } //创建实例 p1 := Person{ FirstName: \u0026#34;John\u0026#34;, LastName: \u0026#34;Doe\u0026#34;, Age: 30, } //访问结构体字段 fmt.Println(p1.FirstName) // 输出 \u0026#34;John\u0026#34; fmt.Println(p2.LastName) // 输出 \u0026#34;Smith\u0026#34; \u0026ndash;\n7.2 结构体方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func (receiver ReceiverType) MethodName() ReturnType { // 方法的实现 } //例如 func (p Person) FullName() string { return p.FirstName + \u0026#34; \u0026#34; + p.LastName } //调用 fmt.Println(p1.FullName()) // 输出 \u0026#34;John Doe\u0026#34; fmt.Println(p2.FullName()) // 输出 \u0026#34;Alice Smith\u0026#34; //使用指针接收器，方法接收的是结构体的指针而不是副本，使得修改能够影响原始结构体 func (receiver *ReceiverType) MethodName() { // 方法的实现 } func (p *Person) IncrementAge() { p.Age++ } p1.IncrementAge() fmt.Println(p1.Age) // 输出 31 8.方法值和方法表达式 \u0026ndash;\n8.1 方法值 方法值是一种将方法绑定到特定实例的函数。它允许您将一个方法作为普通的函数值进行传递、存储和调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } func main() { c := Circle{Radius: 5} // 方法值的用法 areaFunc := c.Area area := areaFunc() fmt.Printf(\u0026#34;圆的面积：%f\\n\u0026#34;, area) } \u0026ndash;\n8.2 方法表达式 方法表达式允许您将方法绑定到类型而不是实例，并将其作为函数值进行传递、存储和调用 接口类型可以由多种不同的类型实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; type Geometry interface { Area() float64 } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } func CalculateArea(g Geometry) float64 { return g.Area() } func main() { c := Circle{Radius: 5} // 方法表达式的用法 areaFunc := (*Circle).Area area := areaFunc(\u0026amp;c) fmt.Printf(\u0026#34;圆的面积：%f\\n\u0026#34;, area) // 使用接口调用方法表达式 area2 := CalculateArea(\u0026amp;c) fmt.Printf(\u0026#34;通过接口计算的圆的面积：%f\\n\u0026#34;, area2) } \u0026ndash;\n8.3 方法值允许将方法绑定到特定实例并将其用作函数值 方法表达式允许将方法绑定到类型并将其用作函数值。\n这两个概念对于 Go 中的面向对象编程和接口实现非常有用。\n9.interface与类型断言 \u0026ndash;\n9.1 interface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //定义接口 type Person interface { // 声明方法 method1(参数列表)返回值列表 method2(参数列表)返回值列表 } //实现接口 func (t 自定义类型）method1(参数列表）返回值列表 { //方法实现 } func (t 自定义类型）method2(参数列表）返回值列表 { //方法实现 } \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //在Go中，接口的实现是隐式的。如果一个类型包含了接口中定义的所有方法，那么它被视为实现了该接口。 type Shape interface { Area() float64 Perimeter() float64 } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius } func (c Circle) Perimeter() float64 { return 2 * math.Pi * c.Radius } //使用接口可以编写通用的代码，不依赖于具体的类型。例如，可以编写一个函数来计算任何形状的面积和周长： func PrintShapeDetails(s Shape) { fmt.Printf(\u0026#34;Area: %f\\n\u0026#34;, s.Area()) fmt.Printf(\u0026#34;Perimeter: %f\\n\u0026#34;, s.Perimeter()) } func main() { c := Circle{Radius: 5} PrintShapeDetails(c) } 9.2 类型断言 golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了interface{}的接口 var a interface{} 定义了一个类型为空接口的变量，可以储存任何值 1 2 3 4 5 6 7 8 9 10 11 12 13 var i interface{} i = 42 value, ok := i.(int) if ok { fmt.Printf(\u0026#34;i 是一个整数: %d\\n\u0026#34;, value) } else { fmt.Println(\u0026#34;i 不是一个整数\u0026#34;) } //直接断言使用 var a interface{} fmt.Println(\u0026#34;Where are you,Jonny?\u0026#34;, a.(string)) 9.3 工厂函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //创建并返回一个新的类型实例 package main import \u0026#34;fmt\u0026#34; // 定义一个接口 type Shape interface { Area() float64 } // 定义一个类型，实现了 Shape 接口 type Circle struct { Radius float64 } // Circle 类型的方法，用于计算面积 func (c Circle) Area() float64 { return 3.14159265359 * c.Radius * c.Radius } // 工厂函数，用于创建 Circle 类型的实例 func NewCircle(radius float64) *Circle { return \u0026amp;Circle{Radius: radius} } func main() { // 使用工厂函数创建 Circle 对象 c1 := NewCircle(5.0) c2 := NewCircle(2.0) // 调用 Circle 对象的方法 area1 := c1.Area() area2 := c2.Area() fmt.Printf(\u0026#34;Circle 1 Area: %f\\n\u0026#34;, area1) fmt.Printf(\u0026#34;Circle 2 Area: %f\\n\u0026#34;, area2) } 10.反射reflect \u0026ndash;\n变量包括（type, value）两部分 type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer. \u0026ndash;\n比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; type Reader interface { ReadBook() } type Writer interface { WriteBook() } //具体类型 type Book struct { } func (this *Book) ReadBook() { fmt.Println(\u0026#34;Read a book.\u0026#34;) } func (this *Book) WriteBook() { fmt.Println(\u0026#34;Write a book.\u0026#34;) } func main() { b := \u0026amp;Book{} var r Reader r = b r.ReadBook() var w Writer w = r.(Writer) w.WriteBook() } \u0026ndash;\nreflect.TypeOf()是获取pair中的type reflect.ValueOf()获取pair中的value 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var num float64 = 1.2345 fmt.Println(\u0026#34;type: \u0026#34;, reflect.TypeOf(num)) fmt.Println(\u0026#34;value: \u0026#34;, reflect.ValueOf(num)) } 运行结果: type: float64 value: 1.2345 \u0026ndash;\n从已知原有类型创建新的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 realValue := value.Interface().(已知的类型) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var num float64 = 1.2345 pointer := reflect.ValueOf(\u0026amp;num) value := reflect.ValueOf(num) // 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic // Golang 对类型要求非常严格，类型一定要完全符合 // 如下两个，一个是*float64，一个是float64，如果弄混，则会panic convertPointer := pointer.Interface().(*float64) convertValue := value.Interface().(float64) fmt.Println(convertPointer) fmt.Println(convertValue) } 运行结果： 0xc42000e238 1.2345 \u0026ndash;\n未知原有类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (u User) ReflectCallFunc() { fmt.Println(\u0026#34;Allen.Wu ReflectCallFunc\u0026#34;) } func main() { user := User{1, \u0026#34;Allen.Wu\u0026#34;, 25} DoFiledAndMethod(user) } // 通过接口来获取任意参数，然后一一揭晓 func DoFiledAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;get Type is :\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;get all Fields is:\u0026#34;, getValue) // 获取方法字段 // 1. 先获取interface的reflect.Type，然后通过NumField进行遍历 // 2. 再通过reflect.Type的Field获取其Field // 3. 最后通过Field的Interface()得到对应的value for i := 0; i \u0026lt; getType.NumField(); i++ { field := getType.Field(i) value := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } // 获取方法 // 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历 for i := 0; i \u0026lt; getType.NumMethod(); i++ { m := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 运行结果： get Type is : User get all Fields is: {1 Allen.Wu 25} Id: int = 1 Name: string = Allen.Wu Age: int = 25 ReflectCallFunc: func(main.User) 11.结构体标签 12.goroutine \u0026ndash;\n协程：coroutine。也叫轻量级线程。 可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过1万个。 一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。 有人把Go比作21世纪的C语言。第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持并发。同时，并发程序的内存管理有时候是非常复杂的，而Go语言提供了自动垃圾回收机制。 Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程 主goroutine退出后，其它的工作goroutine也会自动退出 只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。 runtime.Goexit()只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // 终止当前 goroutine, import \u0026#34;runtime\u0026#34; fmt.Println(\u0026#34;B\u0026#34;) // 不会执行 }() fmt.Println(\u0026#34;A\u0026#34;) // 不会执行 }() //不要忘记() //死循环，目的不让主goroutine结束 for { } } 13.channel \u0026ndash;\ngoroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。 channel是一个数据类型，主要用来解决go程的同步问题以及go程之间数据共享（数据传递）的问题。 引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。 我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。 和其它的引用类型一样，channel的零值也是nil。 \u0026ndash;\n13.1定义channel变量 1 2 3 4 5 //chan是创建channel所需使用的关键字。Type 代表指定channel收发数据的类型。 make(chan Type) //等价于make(chan Type, 0) make(chan Type, capacity) //当 参数capacity= 0 时，channel 是无缓冲阻塞读写的；当capacity \u0026gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。 \u0026ndash;\n13.2接收发送数据 阻塞：由于某种原因数据没有到达，当前go程（线程）持续处于等待状态，直到条件满足，才解除阻塞。\n同步：在两个或多个go程（线程）间，保持数据内容一致性的机制。\n1 2 3 4 channel \u0026lt;- value //发送value到channel \u0026lt;-channel //接收并将其丢弃 x := \u0026lt;-channel //从channel中接收数据，并赋值给x x, ok := \u0026lt;-channel //功能同上，同时检查通道是否已关闭或者是否为空 \u0026ndash;\n默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;子go程结束\u0026#34;) fmt.Println(\u0026#34;子go程正在运行……\u0026#34;) c \u0026lt;- 666 //666发送到c }() num := \u0026lt;-c //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) fmt.Println(\u0026#34;main go程结束\u0026#34;) } \u0026ndash;\n无缓冲的channel\n无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何数据值的通道。\n这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。\n这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 0) //创建无缓冲的通道 c //内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(c), cap(c)) go func() { defer fmt.Println(\u0026#34;子go程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Printf(\u0026#34;子go程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(c), cap(c)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main进程结束\u0026#34;) } \u0026ndash;\n有缓冲的channel 有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。\n这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。\n只有通道中没有要接收的值时，接收动作才会阻塞。\n只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。\n这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { c := make(chan int, 3) //带缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(c), cap(c)) go func() { defer fmt.Println(\u0026#34;子go程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Printf(\u0026#34;子go程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(c), cap(c)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main进程结束\u0026#34;) } \u0026ndash;\n13.3 关闭channel 关闭channel后，无法向channel 再发送数据(引发 panic 错误后导致接收立即返回零值)； 关闭channel后，可以继续从channel接收数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; ) func main() { c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() for { //ok为true说明channel没有关闭，为false说明管道已经关闭 if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Finished\u0026#34;) } \u0026ndash;\n13.4单向channel及应用 声明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var ch1 chan int // ch1是一个正常的channel，是双向的 var ch2 chan\u0026lt;- float64 // ch2是单向channel，只用于写float64数据 var ch3 \u0026lt;-chan int // ch3是单向channel，只用于读int数据 //可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel 转换为普通 channel： c := make(chan int, 3) var send chan\u0026lt;- int = c // send-only var recv \u0026lt;-chan int = c // receive-only send \u0026lt;- 1 //\u0026lt;-send //invalid operation: \u0026lt;-send (receive from send-only type chan\u0026lt;- int) \u0026lt;-recv //recv \u0026lt;- 2 //invalid operation: recv \u0026lt;- 2 (send to receive-only type \u0026lt;-chan int) //不能将单向 channel 转换为普通 channel d1 := (chan int)(send) //cannot convert send (type chan\u0026lt;- int) to type chan int d2 := (chan int)(recv) //cannot convert recv (type \u0026lt;-chan int) to type chan int 14.封装 \u0026ndash;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package model import( \u0026#34;fmt\u0026#34; ) type person struct{ Name string age int //其他包不能访问 sal float64 //其他包不能访问 } //写一个工程模式的函数，相对于一个构造函数 func NewPerson(name string) *person{ return \u0026amp;person{ Name : name } } //为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法 func (p *person) SetAge(age int) { if age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150 { p.age = age }else{ fmt.Println(\u0026#34;年龄范围不正确\u0026#34;) } } func (p *person) GetAge() int { return p.age } func (p *person) SetSal(sal float64) { if sal \u0026gt;= 3000 \u0026amp;\u0026amp; sal \u0026lt;= 30000 { p.sal = sal }else{ fmt.Println(\u0026#34;薪水范围不正确\u0026#34;) } } func (p *person) GetSal() float64 { return p.sal } 15.Select \u0026ndash;\nselect可以监听channel上的数据流动。\nselect的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。\n与switch语句相比，select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：\n1 2 3 4 5 6 7 8 select { case \u0026lt;- chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u0026lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } 16. GO Modules \u0026ndash;\nGO111MODULE\nGo语言提供了 GO111MODULE这个环境变量来作为 Go modules 的开关，其允许设置以下参数：\n● auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。 ● on：启用 Go modules，推荐设置，将会是未来版本中的默认值。 ● off：禁用 Go modules，不推荐设置。\n1 $ go env -w GO111MODULE=on \u0026ndash;\nGOPROXY\n这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。\nGOPROXY 的默认值是：https://proxy.golang.org,direct\nproxy.golang.org国内访问不了,需要设置国内的代理.\n● 阿里云 https://mirrors.aliyun.com/goproxy/ ● 七牛云 https://goproxy.cn,direct\n1 2 $ go env -w GOPROXY=https://goproxy.cn,direct //假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。 \u0026ndash;\nGONOPROXY/GONOSUMDB/GOPRIVATE\n这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。\n更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。\n而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。\n并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：\n1 2 3 4 5 6 7 8 9 $ go env -w GOPRIVATE=\u0026#34;git.example.com,github.com/eddycjy/mquote\u0026#34; 设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。 如果不想每次都重新设置，我们也可以利用通配符，例如： $ go env -w GOPRIVATE=\u0026#34;*.example.com\u0026#34; 这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。 \u0026ndash;\n使用Go Modules初始化项目 开启 go modules 1 $ go env -w GO111MODULE=on 初始化项目 1 2 3 4 5 6 7 8 //创建项目目录 $ mkdir -p $HOME/aceld/modules_test $ cd $HOME/aceld/modules_test //执行Go modules 初始化 //go mod init [myproject] $ go mod init github.com/aceld/modules_test go: creating new go.mod: module github.com/aceld/modules_test //如果你的项目位于 GitHub 上的 github.com/yourusername/myproject 代码库中，你可以将模块名称设置为 github.com/yourusername/myproject，以确保模块名称在全局范围内都是唯一的。这样，其他人在使用你的项目作为依赖项时，就可以通过该模块名称来引用它。 初始化后，会：\n创建一个新的 go.mod 文件，该文件位于你的项目根目录中。这个文件将用于管理项目的依赖关系。\n在 go.mod 文件中指定项目的模块名称为 myproject。\n设置 Go 版本，它是当前项目所使用的 Go 语言版本。\n依赖管理 1 2 3 4 5 6 7 8 9 10 11 12 //添加一个依赖 go get github.com/gin-gonic/gin //这将下载依赖项并将其添加到你的go.mod文件中 //更新依赖 go get -u github.com/gin-gonic/gin //移除依赖 go get -u -d github.com/gin-gonic/gin@none //清理未使用的依赖 go mod tidy 在 Go Modules 模式下，项目的依赖项通常是保存在项目文件夹外部的。依赖项会被下载并保存在模块缓存目录中，而不是直接存储在项目文件夹内。\ntips 1.用切片操作string性能最佳 2.正则表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //正则表达式包 import ( \u0026#34;regexp\u0026#34; ) //编译正则表达式 pattern := \u0026#34;ab+c\u0026#34; regex, err := regexp.Compile(pattern) if err != nil { // 处理编译错误 } //匹配文本 text := \u0026#34;abbc\u0026#34; if regex.MatchString(text) { fmt.Println(\u0026#34;文本与模式匹配\u0026#34;) } else { fmt.Println(\u0026#34;文本与模式不匹配\u0026#34;) } //提取匹配内容 text := \u0026#34;abbc\u0026#34; matched := regex.FindString(text) fmt.Println(\u0026#34;匹配的文本:\u0026#34;, matched) //匹配多次 text := \u0026#34;abbcabccab\u0026#34; matches := regex.FindAllString(text, -1) fmt.Println(\u0026#34;所有匹配的文本:\u0026#34;, matches) //替换匹配文本 text := \u0026#34;abbcabccab\u0026#34; replacement := \u0026#34;X\u0026#34; newText := regex.ReplaceAllString(text, replacement) fmt.Println(\u0026#34;替换后的文本:\u0026#34;, newText) ","date":"2023-09-07T14:34:00+08:00","image":"/lihan3238.github.io/p/golangstudytest/%E5%90%8E%E7%AB%AF8%E5%B0%8F%E6%97%B6%E8%BD%AC%E8%81%8CGolang%E5%B7%A5%E7%A8%8B%E5%B8%88_hu8f5dabb0437f7f9a265abf52ff4a0c38_356076_120x120_fill_box_smart1_3.png","permalink":"lihan3238.github.io/p/golangstudytest/","title":"golang基础学习"}]